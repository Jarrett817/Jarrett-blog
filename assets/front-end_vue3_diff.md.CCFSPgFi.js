import{_ as d,G as e,E as t,ao as a}from"./chunks/framework.C1rSk1pR.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"front-end/vue3/diff.md","filePath":"front-end/vue3/diff.md","lastUpdated":1737179313000}'),f={name:"front-end/vue3/diff.md"},o=a('<h2 id="简单-diff" tabindex="-1">简单 diff <a class="header-anchor" href="#简单-diff" aria-label="Permalink to &quot;简单 diff&quot;">​</a></h2><p>遍历新旧两组子节点中数量较多的那组，逐个进行递归 patch，比较两组子节点数量，数量多说明有新子节点需要挂载，数量少说明有节点需要卸载。key 的租用在于方便找到可复用的节点，尽可能通过移动 dom 节点来完成更新，避免频繁的销毁、创建 dom 元素</p><p>核心逻辑是：拿新的一组子节点中的节点去旧的一组子节点中寻找可复用的节点，如果找到就记录索引位置，称为最大索引。如果一个节点值小于最大索引，则说明该节点对应的真实 dom 元素需要移动</p><h2 id="双端-diff-vue2" tabindex="-1">双端 diff（vue2） <a class="header-anchor" href="#双端-diff-vue2" aria-label="Permalink to &quot;双端 diff（vue2）&quot;">​</a></h2><p>简单 diff 的移动操作并不是最优的。</p><p>双端 diff 对新旧两组子节点分别设置了两对首尾指针</p><p>newStartIdx、oldStartIdx、newEndIdx、oldEndIdx</p><p>依次进行 oldStartIdx-&gt;newStartIdx，oldEndIdx-&gt;newEndIdx，oldStartIdx-&gt;newEndIdx，oldEndIdx-&gt;newStartIdx，如果可复用，进行元素移动，如果不可复用，跳过不做处理。非理想条件下，一趟下来没有任何可复用元素，进入 else 的处理逻辑，直接取 newStartIdx 对应的元素，在 oldChildren 中寻找可复用节点，如果有，进行移动处理。新增、删除元素需要做额外的条件判断，否则会遗漏处理</p><h2 id="快速-diff-vue3" tabindex="-1">快速 diff（vue3） <a class="header-anchor" href="#快速-diff-vue3" aria-label="Permalink to &quot;快速 diff（vue3）&quot;">​</a></h2><p>最早应用于 ivi、inferno 框架，vue3 借鉴并扩展了它。</p><p>快速 diff 算法包含了<code>预处理</code>步骤。借鉴了纯文本 diff 算法的思路</p><p>在对两端文本进行 diff 之前，可以先进行全等比较，这被称为快捷路径。</p><p>在 dom diff 中，使用头指针 j，和 oldEndIdx、newEndIdx，对首尾进行比对，直到出现不同节点，只需处理不同的部分即可。根据 j 和两个尾指针的值做添加、删除元素的判断。</p><p>对于处理元素的复用移动，需要用到最长递增子序列。根据未处理节点的数量创建一个元素全为-1 的数组，将用来存储新的一组子节点中的节点在旧的一组子节点中的位置索引，用其计算出一个最长递增子序列，辅助完成 dom 移动。最长递增子序列所指向的节点即为不需要移动的节点，尽最大可能减少操作的 dom 数量。</p>',14),n=[o];function i(r,p,l,s,c,_){return t(),e("div",null,n)}const x=d(f,[["render",i]]);export{u as __pageData,x as default};
