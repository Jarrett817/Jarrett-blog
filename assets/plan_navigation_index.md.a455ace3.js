import{_ as e,c as a,o as r,Q as o}from"./chunks/framework.7454da9a.js";const b=JSON.parse('{"title":"前端导航方案","description":"","frontmatter":{},"headers":[],"relativePath":"plan/navigation/index.md","filePath":"plan/navigation/index.md","lastUpdated":1712060347000}'),l={name:"plan/navigation/index.md"},t=o(`<h1 id="前端导航方案" tabindex="-1">前端导航方案 <a class="header-anchor" href="#前端导航方案" aria-label="Permalink to &quot;前端导航方案&quot;">​</a></h1><h2 id="痛点" tabindex="-1">痛点 <a class="header-anchor" href="#痛点" aria-label="Permalink to &quot;痛点&quot;">​</a></h2><p>在使用 vue-router 进行中后台项目开发时，存在以下痛点</p><ol><li>router.push 到一个新页面，需要有返回操作，返回操作可能会有参数携带，并且需要显示上级页面名称及当前页面名称</li><li>多级面包屑的跳转，考虑参数携带</li><li>基于 qiankun 等的微应用的主子跳转、子子跳转，新开 tab 的问题</li><li>出于安全问题浏览器不提供上一个历史记录的接口</li></ol><h2 id="相关特性" tabindex="-1">相关特性 <a class="header-anchor" href="#相关特性" aria-label="Permalink to &quot;相关特性&quot;">​</a></h2><ul><li><code>http.referer</code> 只能够获取除了 <code>hash</code> 之外的 <code>url</code></li><li><code>document.referrer</code> 行为与 <code>http.referer</code> 不一致，通过 a 标签跳转可以获取除了 <code>hash</code> 外的完整 <code>url</code>，链接直接点开或者粘贴网址进入都为空字符串，经测试，<code>push</code> 等方法无法改变 <code>document</code>.<code>referrer</code>，但是可以改变 <code>http.referer</code>，不包括 <code>hash</code></li><li><code>history</code> 历史栈，<code>router.push</code> 即 <code>history.pushState</code> 压栈，<code>router.replace</code> 即 <code>history.replaceState</code> 修改当前记录，<code>a</code> 标签的跳转不会压栈，<code>vue-router</code> 的重定向也不会压栈</li><li><code>back()</code>和 <code>go(-1)</code>，mdn 描述为一致，都等于点击浏览器的回退，但是在一些说法中有人提出 <code>go(-1)</code>会重载页面，<code>back</code> 不会重载</li><li><code>back/forward cache</code>。浏览器的前进/回退缓存，可以缓存浏览过的页面快照（包括 <code>JavaScript</code> 堆），使用 <code>bfcache</code> 恢复的重复访问总是比非 <code>bfcache</code> 导航更快</li></ul><h2 id="需求描述" tabindex="-1">需求描述 <a class="header-anchor" href="#需求描述" aria-label="Permalink to &quot;需求描述&quot;">​</a></h2><p>在需要返回按钮的页面，获取上一个路由的路由信息及正确的路由返回</p><h2 id="方案" tabindex="-1">方案 <a class="header-anchor" href="#方案" aria-label="Permalink to &quot;方案&quot;">​</a></h2><h3 id="方案一" tabindex="-1">方案一 <a class="header-anchor" href="#方案一" aria-label="Permalink to &quot;方案一&quot;">​</a></h3><p>选择采用 <code>sessionStorage</code>，记录上一页的路由信息</p><p>全局混入全局前置路由守卫，记录离开页面的路由信息，如</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki solarized-dark"><code><span class="line"><span style="color:#268BD2;">router</span><span style="color:#839496;">.</span><span style="color:#268BD2;">beforeEach</span><span style="color:#839496;">((to, from, next) </span><span style="color:#93A1A1;font-weight:bold;">=&gt;</span><span style="color:#839496;"> {</span></span>
<span class="line"><span style="color:#839496;">  </span><span style="color:#268BD2;">sessionStorage</span><span style="color:#839496;">.</span><span style="color:#268BD2;">set</span><span style="color:#839496;">(</span><span style="color:#268BD2;">to</span><span style="color:#839496;">.</span><span style="color:#268BD2;">name</span><span style="color:#839496;">, </span><span style="color:#268BD2;">from</span><span style="color:#839496;">);</span></span>
<span class="line"><span style="color:#839496;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>同时提供一个返回方法，获取缓存的路由信息并使用 <code>push</code> 返回</p><h4 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h4><ul><li>自动记录，用户无需关注参数的传递</li></ul><h4 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h4><ul><li>仅限两级跳转的简单场景，多级跳转情况下，来源路由会反调</li></ul><h3 id="方案二" tabindex="-1">方案二 <a class="header-anchor" href="#方案二" aria-label="Permalink to &quot;方案二&quot;">​</a></h3><p>同样采用 <code>sessionStorage</code>存储路由信息</p><p>全局混入 <code>beforeRouteLeave</code> 或者<code>beforeRouteEnter</code>方法，记录离开页面的路由信息</p><h4 id="优点-1" tabindex="-1">优点 <a class="header-anchor" href="#优点-1" aria-label="Permalink to &quot;优点&quot;">​</a></h4><ul><li>仅在路由表里定义的组件会触发，且可以通过在 meta 里定义属性，做到精准控制对缓存的存取</li></ul><h4 id="缺点-1" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-1" aria-label="Permalink to &quot;缺点&quot;">​</a></h4><ul><li>同样只适用于两级跳转的简单场景</li></ul><h4 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h4><h3 id="方案三" tabindex="-1">方案三 <a class="header-anchor" href="#方案三" aria-label="Permalink to &quot;方案三&quot;">​</a></h3><p><code>document.referrer</code>虽然不能做到获取<code>hash</code>，但是可以判断与当前页是否同源</p><p>结合思路二，将上一页的路由信息存在<code>session</code></p><p>在确保项目内合理使用<code>push、replace</code>的情况下，通过<code>referrer</code>判断，如果上一页与当前页同源，直接调用 <code>router.back()</code>，<code>router.go(-1)</code></p><p>否则<code>referrer</code>为空字符串，此时<code>replace</code>到缓存信息中的路由，</p><h4 id="优点-2" tabindex="-1">优点 <a class="header-anchor" href="#优点-2" aria-label="Permalink to &quot;优点&quot;">​</a></h4><ul><li>理论上体验会更好，可以保留浏览器的原生行为，在条件允许的情况下支持<code>back/forward Cache</code>，可以缓存浏览过的页面快照（包括 <code>JavaScript</code> 堆），使用 <code>bfcache</code> 恢复的重复访问总是比非 <code>bfcache</code> 导航更快</li><li>能够保证<code>history</code>栈的顺序，无论是使用 <code>push</code>还是 <code>replace</code> 回退，都会导致 <code>history</code> 栈不正确</li></ul><h4 id="缺点-2" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-2" aria-label="Permalink to &quot;缺点&quot;">​</a></h4><ul><li>浏览器出于安全考虑，无法获取到真正完整的 <code>referrer</code> 地址，因此还是需要配合路由信息缓存</li></ul><h3 id="方案四" tabindex="-1">方案四 <a class="header-anchor" href="#方案四" aria-label="Permalink to &quot;方案四&quot;">​</a></h3><p>自行维护一个<code>history</code>栈</p><ul><li><a href="https://github.com/zack24q/vue-navigation" target="_blank" rel="noreferrer">vue-navigation</a></li><li><a href="https://github.com/hezhongfeng/vue-page-stack" target="_blank" rel="noreferrer">vue-page-stack</a></li></ul><p>以上两个库主要是针对<code>keep-alive</code>缓存页面，没有去存储上页的路由信息</p><h4 id="优点-3" tabindex="-1">优点 <a class="header-anchor" href="#优点-3" aria-label="Permalink to &quot;优点&quot;">​</a></h4><ul><li>维护了一个访问历史栈，与浏览器的 back/forward 同步</li><li>做了 keep-alive 缓存</li></ul><h4 id="缺点-3" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-3" aria-label="Permalink to &quot;缺点&quot;">​</a></h4><ul><li>没有存储相关的路由信息，需要修改使用，取栈顶的 path 去路由表中匹配</li><li>没有对 back 行为做限制，可以结合 referrer</li><li>每次的 push/replace 都会触发对应的缓存存取操作</li></ul><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/referrer" target="_blank" rel="noreferrer">referrer mdn</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2017/02/js-page-url-document-referrer/" target="_blank" rel="noreferrer">referrer 张鑫旭</a></li><li><a href="https://www.ruanyifeng.com/blog/2019/06/http-referer.html" target="_blank" rel="noreferrer">http-referer 阮一峰</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2022/05/history-scrollrestoration/" target="_blank" rel="noreferrer">浏览器滚动保存行为 张鑫旭</a></li><li><a href="https://stackoverflow.com/questions/3528324/how-to-get-the-previous-url-in-javascript" target="_blank" rel="noreferrer">stackoverflow 如何获取上一个 url</a></li><li><a href="https://github.com/vuejs/vue-router/issues/3617" target="_blank" rel="noreferrer">vuejs issue-面包屑</a></li><li><a href="https://stackoverflow.com/questions/36447977/how-to-get-previous-url-including-hash-fragment-using-javascript" target="_blank" rel="noreferrer">stackoverflow 获取上一个页面的 url，包括 hash</a></li><li><a href="https://stackoverflow.com/questions/39288915/detect-previous-path-in-react-router" target="_blank" rel="noreferrer">stackoverflow 在 react-router 中检测上一个路径</a></li><li><a href="https://developer.chrome.com/docs/devtools/application/back-forward-cac" target="_blank" rel="noreferrer">谷歌开发者文档 back/forward 缓存</a></li><li><a href="https://developer.chrome.com/blog/referrer-policy-new-chrome-default/" target="_blank" rel="noreferrer">谷歌开发者文档，请求头 referrer</a></li><li><a href="https://web.dev/i18n/zh/referrer-best-practices/#%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0-csrf-%E4%BF%9D%E6%8A%A4" target="_blank" rel="noreferrer">谷歌开发者文档 referer 最佳实践</a></li><li><a href="https://web.dev/bfcache/?utm_source=devtools#never-use-the-unload-event" target="_blank" rel="noreferrer">永远不要使用 unload 事件</a></li><li><a href="https://github.com/vuejs/vue/issues/8109" target="_blank" rel="noreferrer">vue issue bfCache 失效</a></li><li><a href="https://github.com/vercel/next.js/issues/4136" target="_blank" rel="noreferrer">next.js issue 讨论 一</a></li><li><a href="https://github.com/vercel/next.js/discussions/36723" target="_blank" rel="noreferrer">next.js issue 讨论 二</a></li></ul>`,45),c=[t];function s(i,n,d,h,p,u){return r(),a("div",null,c)}const m=e(l,[["render",s]]);export{b as __pageData,m as default};
