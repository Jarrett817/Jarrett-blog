import{_ as i,E as a,H as l,az as n}from"./chunks/framework.BCNbIE3H.js";const o="/Jarrett-blog/assets/nodejs-API.pca4yKXi.png",t="/Jarrett-blog/assets/event-loop.wlPTvWLp.png",v=JSON.parse('{"title":"node","description":"","frontmatter":{"title":"node","desc":"《JavaScript设计模式》、《大话设计模式》笔记","keywords":"设计模式、笔记","date":"2020-02-17T01:01:00.000Z","cover":"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg"},"headers":[],"relativePath":"front-end/nodejs/index.md","filePath":"front-end/nodejs/index.md","lastUpdated":1766575023000}'),s={name:"front-end/nodejs/index.md"};function d(r,e,p,u,h,c){return l(),a("div",null,e[0]||(e[0]=[n('<h1 id="nodejs" tabindex="-1">nodejs <a class="header-anchor" href="#nodejs" aria-label="Permalink to &quot;nodejs&quot;">​</a></h1><h2 id="nodejs-是什么" tabindex="-1">nodejs 是什么？ <a class="header-anchor" href="#nodejs-是什么" aria-label="Permalink to &quot;nodejs 是什么？&quot;">​</a></h2><p>不是 web 框架，也不是编程语言，而是一个将多种技术组合起来的平台 用到了 v8 引擎，libuv，c/c++实现的 c-ares、http-parser、OpenSSL、zlib 等 <img src="'+o+'" alt="NodeJS的API.png" loading="lazy"> 源代码看 0.10 版本，因为使用了很久一段时间</p><h2 id="nodejs-bindings" tabindex="-1">nodejs bindings <a class="header-anchor" href="#nodejs-bindings" aria-label="Permalink to &quot;nodejs bindings&quot;">​</a></h2><ul><li>为了让 js 能够调用 c++库，需要对其进行封装，使它符合某些要求，如对 http_parser 封装为 http_parser_bindings.cpp</li><li>用 node 提供的编译工具将其编译为.node 文件，于是 js 可以直接 require 这个.node 文件</li><li>binding 是 js 调用 c++库的桥梁</li></ul><p><a href="http://nodejs.cn/api/addons.html#addons_function_arguments" target="_blank" rel="noreferrer">官方示例</a></p><h2 id="libuv-v8" tabindex="-1">libuv&amp;v8 <a class="header-anchor" href="#libuv-v8" aria-label="Permalink to &quot;libuv&amp;v8&quot;">​</a></h2><h3 id="libuv" tabindex="-1">libuv <a class="header-anchor" href="#libuv" aria-label="Permalink to &quot;libuv&quot;">​</a></h3><ul><li>libuv 让 nodejs 具备跨平台的异步 IO 能力</li><li>因为 FreeBSD 系统上有 kqueue、windows 上有 IOCP、Linux 上有 epoll，nodejs 之父 Ryan 为了实现一个跨平台的异步 I/O 库写了 libuv，会根据系统自动选择合适的方案</li><li>可以用于 TCP/UDP/DNS/文件等异步操作</li></ul><h3 id="v8" tabindex="-1">v8 <a class="header-anchor" href="#v8" aria-label="Permalink to &quot;v8&quot;">​</a></h3><ul><li>将 js 源代码变成本地代码并执行</li><li>维护调用栈，确保 JS 的执行顺序</li><li>内存管理，为所有对象分配内存</li><li>垃圾回收，重复利用无用的内存</li><li>实现 JS 的标准库</li></ul><p>注意点：</p><ul><li>v8 不提供 DOM API，dom 是浏览器提供的</li><li>v8 执行 JS 是单线程的</li><li>可以开启两个线程分别执行 JS</li><li>V8 本身是包含多个线程的，如垃圾回收为单独线程</li><li>自带 Event Loop，但 nodejs 基于 libuv 实现了一版</li></ul><h2 id="nodejs-event-loop-简述" tabindex="-1">nodejs Event Loop 简述 <a class="header-anchor" href="#nodejs-event-loop-简述" aria-label="Permalink to &quot;nodejs Event Loop 简述&quot;">​</a></h2><p>事件存在优先级，处理起来分先后 操作系统可以触发事件，JS 可以处理事件，Event Loop 就是对事件处理的顺序管理</p><p>--</p><p><img src="'+t+'" alt="timers.png" loading="lazy"></p><ul><li>poll 阶段处理大部分的请求</li><li>timers 检查计时器</li><li>poll 轮询，检查系统事件</li><li>check 检查 setImmediate 回调</li><li>其他阶段用得较少</li></ul>',18)]))}const _=i(s,[["render",d]]);export{v as __pageData,_ as default};
