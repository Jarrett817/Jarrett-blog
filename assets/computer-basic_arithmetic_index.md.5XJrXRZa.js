import{_ as i,E as a,H as n,az as h,aE as l,aF as k,aG as p,aH as t,aI as e}from"./chunks/framework.C0ZVvu-t.js";const A=JSON.parse('{"title":"数据结构与算法","description":"","frontmatter":{"title":"数据结构与算法","desc":"数据结构与算法笔记","keywords":"设计模式、笔记","date":"2020-02-17T01:01:00.000Z","cover":"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg"},"headers":[],"relativePath":"computer-basic/arithmetic/index.md","filePath":"computer-basic/arithmetic/index.md","lastUpdated":1756951172000}'),r={name:"computer-basic/arithmetic/index.md"};function E(d,s,g,y,c,F){return n(),a("div",null,s[0]||(s[0]=[h(`<h1 id="数据结构与算法" tabindex="-1">数据结构与算法 <a class="header-anchor" href="#数据结构与算法" aria-label="Permalink to “数据结构与算法”">​</a></h1><h2 id="时间空间复杂度" tabindex="-1">时间空间复杂度 <a class="header-anchor" href="#时间空间复杂度" aria-label="Permalink to “时间空间复杂度”">​</a></h2><p>算法是用来操作数据、解决问题的一组方法。主要是用事后统计法和事前分析估算衡量算法之间的优劣。 事后统计是通过统计、监控、利用计时器对不同算法的运行时间进行比较，从而确定算法效率的高低，但是有非常大的局限性。 事前分析估算是在计算机程序编写之前，依据统计方法对算法进行估算 比如斐波那契数列 0，1，1，2，3，5，7，13，求第 n 个斐波那契数</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 递归实现</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fun1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fun1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fun1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 循环实现</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fun2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> first </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> second </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> first </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> second;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    first </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> second;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    second </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> second;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>时间复杂度即运行消耗的时间，空间复杂度即消耗的内存空间 我们在计算时间复杂度时，代码每运行一次，记作一个单位时间，for(let i=0;i&lt;n;i++)循环就是 n 个单位时间，以此类推计算出某个函数或者某个循环的时间复杂度 <strong>T(n)=O(f(n))</strong>公式</p><ul><li>T(n)表示代码执行的时间</li><li>n 表示数据规模大小</li><li>f(n)表示每行代码执行的次数总和</li><li>因为这时一个公式，所以用 f(n)表示。公式中的 O，表示代码的执行时间 T(n)与 f(n)表达式成正比，代表的是一种增长趋势</li></ul><p><strong>大数据规模时可以忽略掉“常数、低阶次、系数”都可省略，主要是找出对趋势起决定性作用的那个部分。</strong> **大 O 时间复杂度实际上并不是具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以也叫做渐进时间复杂度，简称时间复杂度 ** n<em>2 及以上阶的时间复杂度效率很低，递归的时间复杂度约为 2</em>n，呈指数级，因此效率很低 ​</p><p>时间复杂度还可分为最好情况、平均情况和最坏情况。 <img src="`+l+'" alt="image.png" loading="lazy"> 还可以考虑概率，但实际应用中，我们一般只看最坏的情况。</p><h2 id="数组" tabindex="-1">数组 <a class="header-anchor" href="#数组" aria-label="Permalink to “数组”">​</a></h2><p>数组下标都是从 0 开始，内存空间的地址是连续的</p><h3 id="为什么很多语言中数组都从-0-开始编号" tabindex="-1">为什么很多语言中数组都从 0 开始编号 <a class="header-anchor" href="#为什么很多语言中数组都从-0-开始编号" aria-label="Permalink to “为什么很多语言中数组都从 0 开始编号”">​</a></h3><h3 id="如何实现随机访问" tabindex="-1">如何实现随机访问 <a class="header-anchor" href="#如何实现随机访问" aria-label="Permalink to “如何实现随机访问”">​</a></h3><p>数组是一种线性表数据结构，是一组连续的内存空间，存储具有相同类型的数据</p><h4 id="关键词解析" tabindex="-1">关键词解析 <a class="header-anchor" href="#关键词解析" aria-label="Permalink to “关键词解析”">​</a></h4><blockquote><p>线性表。排成线的结构，每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈也是线性表结构 非线性表。二叉树、堆、图。因为这些数据类型不是简单的前后关系 连续的内存空间和相同类型的数据。数组正是因为如此，才得以有了随机访问的特性，但是对于数据的删除和插入，数组就显得有些低效，为了保证连续性需要做大量的搬移工作</p></blockquote><p><img src="'+k+'" alt="image.png" loading="lazy"></p><p>如图，一个长度为 10 的数组，计算机给数组分配了一块连续内存空间 1000-1039</p><p>首地址 base_address=1000</p><p>计算机会给每个内存单元分配一个地址，寻址公式<code>a[i]_address=base_address+i*data_type_size</code></p><p><code>data_type_size</code>表示数组中每个元素大小，通过首地址+下标乘以元素大小取到内存地址</p><p><strong>数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)</strong></p><h3 id="为何数组的插入和删除操作是低效的" tabindex="-1">为何数组的插入和删除操作是低效的 <a class="header-anchor" href="#为何数组的插入和删除操作是低效的" aria-label="Permalink to “为何数组的插入和删除操作是低效的”">​</a></h3><p>在中间插入元素，后面的都要移动，仅在末尾插入不需移动，平均时间复杂度为(1+2+...n)/n=O(n)</p><p>但如果不需要保持数组的有序性，直接插入到最后一个位置就可以了</p><p>要优化可以将多次的删除、插入操作集中在一起执行，这样元素尽量被少移动，大大减少了数据搬移的消耗</p><h3 id="容器能否代替数组" tabindex="-1">容器能否代替数组 <a class="header-anchor" href="#容器能否代替数组" aria-label="Permalink to “容器能否代替数组”">​</a></h3><p><strong>不能</strong></p><p>比如 java 的 ArrayList、C++ STL 中的 vector</p><p>使用容器的好处在于，将很多数组操作的细节封装了起来，比如数组插入、删除时搬移其他数据时。还有个优势是支持动态扩容。</p><p>数组需要预先指定大小，因为需要分配连续的内存空胶囊，比如我们只申请了 10，但是要用 11 时，我们需要重新分配一块更大的空间，将原来的数据复制过去，然后将新的数据插入</p><p>而 ArrayList 会在存储空间不够时，自动将空间扩容为 1.5 倍大小</p><h4 id="数组的适用场景" tabindex="-1">数组的适用场景 <a class="header-anchor" href="#数组的适用场景" aria-label="Permalink to “数组的适用场景”">​</a></h4><ul><li>java 的 ArrayList 无法存储基本类型，int、long，需要封装为 Integer、Long 类，但是自动装箱、自动拆箱有一定的性能消耗</li><li>数据大小事先已知，操作简单</li><li>定义类型的时候更加容易。多维数组的类型声明可能会需要嵌套的泛型</li></ul><h3 id="解答-数组下标从-0-开始" tabindex="-1">解答：数组下标从 0 开始 <a class="header-anchor" href="#解答-数组下标从-0-开始" aria-label="Permalink to “解答：数组下标从 0 开始”">​</a></h3><ul><li>数组下标的确切定义是偏移（offset），如果从 1 开始计数，每次还得(k-1)*type_size，从 1 开始编号，多了一次不必要的操作，数组作为基础数据结构需要高性能，所以从 0 开始</li><li>历史原因。C 是从 0 开始，java 等等都沿用</li></ul><h2 id="链表" tabindex="-1">链表 <a class="header-anchor" href="#链表" aria-label="Permalink to “链表”">​</a></h2><p>链表与数组的差别在于，数组需要连续的存储空间，这就会导致如果所需的连续空降过大，会导致内存申请失败，即便总的多余内存时足够的，这时候，链表就更合适，因为链表不需要连续的存储空间，它可以将一组零散的内存块串联起来使用</p><p>链表常见的有三种</p><ul><li>单链表</li><li>双向链表</li><li>循环链表</li></ul><p>每个链表的节点除了存储数据之外，还需要记录链表上下一个节点的地址，这个地址叫做后继指针 next</p><p>只有头节点和尾节点是特殊的，头节点记录链表的基地址，尾节点指向一个空地址 null</p><p>链表同样支持数据的插入、删除、查找，在链表中进行插入、删除操作是非常快速的，因为不需要大量的数据搬移操作，但是数组由于不连续，没法随机访问，只能一个一个遍历节点，时间复杂度 O(n)</p><h3 id="循环链表" tabindex="-1">循环链表 <a class="header-anchor" href="#循环链表" aria-label="Permalink to “循环链表”">​</a></h3><p>循环链表是一种特殊的单链表，尾节点指针指向头节点</p><h3 id="双向链表" tabindex="-1">双向链表 <a class="header-anchor" href="#双向链表" aria-label="Permalink to “双向链表”">​</a></h3><p>每个节点有前驱后继两个指针，比单向链表需要更多的内存空间，更加好找前驱节点</p><h3 id="链表的删除" tabindex="-1">链表的删除 <a class="header-anchor" href="#链表的删除" aria-label="Permalink to “链表的删除”">​</a></h3><p>链表的删除有两种情况</p><ol><li>删除节点中某个值等于给定值的节点</li><li>删除给定指针指向的节点</li></ol><p>第一种情况，单向链表和双向链表都需要依次遍历每个节点，O(n)</p><p>第二种情况，明显双向链表更好用，因为删除某个节点需要知道前驱节点，单链表又得遍历查找一遍</p><p>另外还有对于一个有序链表按值查找，我们可以按值决定往前还是往后查找，每次查找只需要查找一半的数据</p><p>实际使用中，双向链表也是更加广泛的，当内存空间充足的时候，追求代码的执行速度，双向链表是更好的，这也是空间换时间的思路。但如果内存吃紧，那就得采取时间换空间的思路</p><p>双向链表和循环链表还可以组合成双向循环链表</p><h3 id="链表-vs-数组" tabindex="-1">链表 VS 数组 <a class="header-anchor" href="#链表-vs-数组" aria-label="Permalink to “链表 VS 数组”">​</a></h3><p>数组简单易用，连续内存空间可以借助 CPU 的缓存机制，预读数组中的数据，而链表不是连续存储，CPU 缓存不友好</p><p>数组的缺点大小固定，连续的存储空间不够会导致内存不足，即便是内存足够，数组的扩容是需要把原数组拷贝一份的，<strong>这个操作相当费时</strong>，而链表本身没有大小限制，天然支持动态扩容，这是它与数组最大的区别</p><p>当然链表也比数组更加耗费内存，先不说前驱后继指针导致的内存空间翻倍，频繁的插入和删除操作，会导致内存的频繁申请和释放，容易造成内存碎片，高级语言会导致频繁的垃圾回收，所以对于数组和链表的使用，需要自己权衡场景</p><h3 id="lru-缓存淘汰算法" tabindex="-1">LRU 缓存淘汰算法 <a class="header-anchor" href="#lru-缓存淘汰算法" aria-label="Permalink to “LRU 缓存淘汰算法”">​</a></h3><p>思路：维护一个有序单链表，越靠近尾部的节点是越早之前访问的，当有一个新的数据被访问时，我们从链表头开始顺序遍历链表</p><ol><li>如果此数据已在链表中，我们遍历得到它后，删除，插入到头部</li><li>如果没在链表中，如果缓存未满，插入头部，如果缓存已满，删除尾节点，将新数据插入头部</li></ol><p>此时总是需要遍历的，时间复杂度 O(n)</p><p>优化可以用散列表，可以降到 O(1)</p><h3 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to “注意事项”">​</a></h3><ol><li>理解指针或者引用的含义。C 语言有指针，Java 没有，叫做引用，其实都是一样的意思，存储的是所指内存对象的内存地址。变量赋值给指针，其实是把变量的地址赋值给指针，指针或者引用指向这个变量，通过指针可以找到这个变量</li><li>警惕指针丢失和内存泄露。不需要的引用要及时断掉，引用也不要指错对象</li><li>使用哨兵简化实现难度。不管链表是不是空，head 指针一直指向哨兵节点，有哨兵节点的链表叫做<strong>带头链表</strong>。其实就是加了一个头节点，返回时候返回头节点的 next 就可以</li><li>留意边界条件处理。链表为空？链表只有一个节点？链表只包含两个节点？代码逻辑能否处理头节点和尾节点？</li><li>画图举例。光想容易不清晰，画出来更容易</li><li>多练习，没有捷径</li></ol><h2 id="栈" tabindex="-1">栈 <a class="header-anchor" href="#栈" aria-label="Permalink to “栈”">​</a></h2><p>栈是一种操作受限的线性表，只允许一端插入和删除数据。从功能上来说，数组和链表都可以代替栈，但是操作的接口太多了。对于某些场景，需要这种约束事情才会变得更加可控</p><p>使用数组实现叫做顺序栈，使用链表叫做链式栈。入栈和出栈的空间复杂度是 O(1)，时间复杂度也是 O(1)</p><p>出栈不涉及内存的重新申请和数据搬移，但是入栈的时候，如果空间不够，就需要重新申请内存和数据搬移，时间复杂度为 O(n)</p><h3 id="栈在函数调用中的应用" tabindex="-1">栈在函数调用中的应用 <a class="header-anchor" href="#栈在函数调用中的应用" aria-label="Permalink to “栈在函数调用中的应用”">​</a></h3><p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成栈这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，函数执行完就弹栈</p><p><img src="'+p+`" alt="image.png" loading="lazy"></p><h3 id="栈在表达式求值中的应用" tabindex="-1">栈在表达式求值中的应用 <a class="header-anchor" href="#栈在表达式求值中的应用" aria-label="Permalink to “栈在表达式求值中的应用”">​</a></h3><p>求 <code>34+13\\*9+44-12/3</code> 的值</p><p>编译器会通过两个栈，从左到右遍历表达式，遇到数字就压入操作数栈，遇到运算符，就与运算符栈的栈顶元素进行比较，优先级高的压入栈，优先级低或者相同的，从栈顶取出操作符和两个操作数进行计算，以此类推</p><h3 id="栈在括号匹配中的应用" tabindex="-1">栈在括号匹配中的应用 <a class="header-anchor" href="#栈在括号匹配中的应用" aria-label="Permalink to “栈在括号匹配中的应用”">​</a></h3><p>如何检查表达式中括号使用的合法性？</p><p>可以用栈保存未匹配的左括号，从左到右依次扫描字符串，左括号压入栈中，遇到右括号，从栈顶取出一个左括号，如果匹配，则扫描剩下的字符串，如果右括号不能配对，或者栈中没有数据，说明格式非法</p><h2 id="队列" tabindex="-1">队列 <a class="header-anchor" href="#队列" aria-label="Permalink to “队列”">​</a></h2><p>先进先出，入队出队，不允许其他操作，也是一种操作受限的线性表结构</p><p>有循环队列、阻塞队列、并发队列</p><p>实现队列可以用数组也可以用栈，分别叫顺序队列、链式队列</p><p>底层语言的数组在实现队列时，会导致头、尾下标的持续变化，所以需要在入队时，没有空间的情况下集中进行一次数据搬移的操作，另外，用循环队列可以更好地解决这个问题，循环的入队就可以了</p><h3 id="阻塞队列和并发队列" tabindex="-1">阻塞队列和并发队列 <a class="header-anchor" href="#阻塞队列和并发队列" aria-label="Permalink to “阻塞队列和并发队列”">​</a></h3><h4 id="阻塞队列" tabindex="-1">阻塞队列 <a class="header-anchor" href="#阻塞队列" aria-label="Permalink to “阻塞队列”">​</a></h4><p>队列为空，从队列头取数据会被阻塞，因为没有数据可取，队列已满，插入数据会被阻塞。</p><p>这就是生产者——消费者模型的定义</p><h4 id="并发队列" tabindex="-1">并发队列 <a class="header-anchor" href="#并发队列" aria-label="Permalink to “并发队列”">​</a></h4><p>线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。在实战篇讲 Disruptor 的时候，我会再详细讲并发队列的应用。</p><h3 id="线程池没有空闲线程时-新的任务请求如何处理" tabindex="-1">线程池没有空闲线程时，新的任务请求如何处理？ <a class="header-anchor" href="#线程池没有空闲线程时-新的任务请求如何处理" aria-label="Permalink to “线程池没有空闲线程时，新的任务请求如何处理？”">​</a></h3><ol><li>非阻塞，直接拒绝任务请求</li><li>阻塞，请求排队，等到有空闲线程时取出排队的请求继续处理</li></ol><h3 id="基于链表和数组的队列对于排队请求有什么区别" tabindex="-1">基于链表和数组的队列对于排队请求有什么区别？ <a class="header-anchor" href="#基于链表和数组的队列对于排队请求有什么区别" aria-label="Permalink to “基于链表和数组的队列对于排队请求有什么区别？”">​</a></h3><p>链表支持无限排队的无界队列，可能会导致过多请求排队等待，等待时间长</p><p>数组队列大小有限，当线程池中排队的请求超过队列大小时，接下来的请求会被拒绝，对空间响应时间敏感的系统来说，更加合理</p><p>对于大部分资源有限的场景，当没有空闲资源时，基本都可以通过队列的数据结构来实现请求排队</p><h2 id="递归" tabindex="-1">递归 <a class="header-anchor" href="#递归" aria-label="Permalink to “递归”">​</a></h2><p>递归需要满足三个条件</p><ol><li>一个问题的解可以分解为几个子问题的解。比如电影院找座位，想知道自己的座位可以分解为前一排的人在哪一排的子问题</li><li>这个问题与分解之后的子问题，除了数据规模不同，求解的思路完全一样</li><li>存在递归终止条件</li></ol><p>需要会写递归公式</p><blockquote><p>写递归要注意避免堆栈溢出，可以通过限制递归调用的最大深度，超过该深度直接报错。但这种办法没有完全解决问题，仅在最大深度比较小的时候使用，比如 10、50。</p></blockquote><blockquote><p>还要警惕重复计算，可以使用散列表来保存已经求解过 f(k)，当递归调用到时，先看下是否已经求解过了，是的话直接从三列表中取值返回，不需要重复计算</p></blockquote><p>递归的空间复杂度是 O(n)，因为每调用一次函数都会在内存栈中保存一次数据</p><p>递归有利有弊。它的表达力很强，写起来很简洁，弊端在于空间复杂度高，有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题，实际开发中，要根据实际情况来选择是否用递归的形式来实现</p><p>可以将递归改为迭代循环的非递归写法，但其实本质没有变，对于某些问题？还是无法避免</p><p>递归中还可能出现存在环形链表的问题，可以用快慢指针检测出环形链表的存在</p><h2 id="排序" tabindex="-1">排序 <a class="header-anchor" href="#排序" aria-label="Permalink to “排序”">​</a></h2><h3 id="为什么插入排序比冒泡排序更受欢迎" tabindex="-1">为什么插入排序比冒泡排序更受欢迎 <a class="header-anchor" href="#为什么插入排序比冒泡排序更受欢迎" aria-label="Permalink to “为什么插入排序比冒泡排序更受欢迎”">​</a></h3><p>排序算法的执行效率分析</p><ol><li>最好、最坏情况、平均情况时间复杂度</li><li>时间复杂度的系数、常数、低阶。虽然一般情况下都可忽略，但是由于我们平时处理的数据可能规模不大，这个时候需要把这些考虑进去</li><li>比较次数和交换次数。基于比较的排序算法的执行过程，涉及元素大小的比较、元素的交换或移动，应该把比较次数和交换次数也考虑进去</li></ol><h3 id="排序算法的内存消耗" tabindex="-1">排序算法的内存消耗 <a class="header-anchor" href="#排序算法的内存消耗" aria-label="Permalink to “排序算法的内存消耗”">​</a></h3><p>算法有空间复杂度，空间复杂度为 O(1)的排序算法叫做原地排序</p><h3 id="排序算法的稳定性" tabindex="-1">排序算法的稳定性 <a class="header-anchor" href="#排序算法的稳定性" aria-label="Permalink to “排序算法的稳定性”">​</a></h3><p>待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变，叫做<strong>稳定的排序算法</strong>，否则叫做<strong>不稳定的排序算法</strong></p><h3 id="冒泡排序" tabindex="-1">冒泡排序 <a class="header-anchor" href="#冒泡排序" aria-label="Permalink to “冒泡排序”">​</a></h3><p>每次对相邻的两个元素进行比较交换。可以优化当某次冒泡没有数据交换时，不再执行后续的冒泡操作</p><h4 id="分析" tabindex="-1">分析 <a class="header-anchor" href="#分析" aria-label="Permalink to “分析”">​</a></h4><ol><li>冒泡排序是原地排序算法</li><li>是稳定的排序算法</li><li>最好情况时间复杂度 O(n)，最坏情况，当排序数据都是倒序排列的，需要 n 次冒泡操作，最坏情况时间复杂度 O(n^2)</li></ol><p>对于包含 n 个数据的数据，排列方式不同，冒泡排序的执行时间也是不同的，可以用有序度、逆序度来分析</p><p>2，4，3，1，5，6 的有序元素有 11 对，如(2,4),(2,5)，有序度 11，完全有序的数组，有序度是 n*(n-1)/2，叫做满有序度</p><p>逆序度以此类推，逆序度=满有序度-有序度</p><h3 id="插入排序" tabindex="-1">插入排序 <a class="header-anchor" href="#插入排序" aria-label="Permalink to “插入排序”">​</a></h3><p>将数据分为两个区间，已排序区间和未排序区间，核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入</p><p>不同的查插入点方法，元素的比较次数是有区别的，但对于一个给定的初始序列，移动操作的次数总是固定的，等于逆序度</p><h4 id="分析-1" tabindex="-1">分析 <a class="header-anchor" href="#分析-1" aria-label="Permalink to “分析”">​</a></h4><ol><li>插入排序是一个原地排序算法，因为不需要额外的存储空间，空间复杂度是 O(1)</li><li>插入排序中，对于值相同的元素，可以选择将后面出现的元素插入到前面出现的元素的后面，所以是稳定的排序算法</li><li>如果原本已经有序，复杂度为 O(n)，如果是倒叙，最坏情况时间复杂度是 O(n^2)，平均时间复杂度为 O(n^2)</li></ol><h3 id="选择排序" tabindex="-1">选择排序 <a class="header-anchor" href="#选择排序" aria-label="Permalink to “选择排序”">​</a></h3><p>从未排序的区间中找最小的元素，与已排序的元素的末尾+1 的元素进行交换</p><p>基本跟插入排序类似</p><h4 id="分析-2" tabindex="-1">分析 <a class="header-anchor" href="#分析-2" aria-label="Permalink to “分析”">​</a></h4><ol><li>是原地排序算法</li><li>不稳定。因为每次都要交换元素位置</li></ol><p>冒泡和插入排序在时间复杂度上是一样的，但冒泡排序涉及了 K 次交换操作，每次三个赋值语句，总耗时 3*K，插入排序数据移动操作只需要 K 个单位时间，性能上插入排序是更好的</p><h3 id="归并排序" tabindex="-1">归并排序 <a class="header-anchor" href="#归并排序" aria-label="Permalink to “归并排序”">​</a></h3><p>排序一个数组，先把数组从中间分成前后两部分，再对前后两部分分别排序，递归的形式，最终整个数组就排好序了</p><p>是<strong>分治思想</strong>的体现</p><h4 id="分析-3" tabindex="-1">分析 <a class="header-anchor" href="#分析-3" aria-label="Permalink to “分析”">​</a></h4><ol><li>是稳定的排序算法。合并过程中可以保证值相同的元素，合并前后的顺序不变</li><li>时间复杂度 O(nlogn)，归并算法的执行效率与要排序的原始数组的有序程度无关，时间复杂度很稳定，都是 O(nlogn)</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>T(n) = 2*T(n/2) + n</span></span>
<span class="line"><span>     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n</span></span>
<span class="line"><span>     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n</span></span>
<span class="line"><span>     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n</span></span>
<span class="line"><span>     ......</span></span>
<span class="line"><span>     = 2^k * T(n/2^k) + k * n</span></span>
<span class="line"><span>     ......</span></span></code></pre></div><ol start="3"><li>不是原地排序算法，空间复杂度 O(n)</li></ol><h3 id="快速排序" tabindex="-1">快速排序 <a class="header-anchor" href="#快速排序" aria-label="Permalink to “快速排序”">​</a></h3><p>也是利用分治思想。选择一组数据中任意一个数据作为哨兵 pivot，遍历数据，将大于 pivot 的放到右边，小于 pivot 的放到左边，pivot 在中间，我们得到三部分的数据</p><p>我们可以递归哨兵左右的数据，直至区间缩小为 1，这样数据就有序了</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>递推公式：</span></span>
<span class="line"><span>quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>终止条件：</span></span>
<span class="line"><span>p &gt;= r</span></span></code></pre></div><p><img src="`+t+`" alt="image.png" loading="lazy"></p><p>快速排序与归并排序的差别在于归并的处理过程由下到上，先处理子问题再合并，快排相反，从上到下，先分区，再处理子问题，归并虽然稳定、时间复杂度为 O(nlogn)，但是是非原地算法。而快速排序通过巧妙的原地分区函数，实现原地排序，解决了归并排序<strong>占用太多内存</strong>的问题</p><h4 id="分析-4" tabindex="-1">分析 <a class="header-anchor" href="#分析-4" aria-label="Permalink to “分析”">​</a></h4><ol><li>快速排序是一种原地、不稳定的排序算法。如果每次分区都能整好把数组分成大小接近相等的两个小区间，那么快排的时间复杂度递推求解公式跟归并是相同的，时间复杂度 O(nlogn)，但如果不是，比如每次分区都是不均等的，最坏情况时间复杂度就为 O(n^2)</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>T(n) = T(n/10) + T(9*n/10) + n； n&gt;1</span></span></code></pre></div><p>用快速排序可以以 O(n)的时间复杂度找到数组中第 K 大的元素，因为每次都会选中一个哨兵 pivot，利用好这个哨兵的下标位置，就能很容易找到第 K 大的元素</p><h3 id="桶排序" tabindex="-1">桶排序 <a class="header-anchor" href="#桶排序" aria-label="Permalink to “桶排序”">​</a></h3><p>线型排序算法</p><p>核心思想是将要排序的数据分到几个有序的桶里，每个桶里再单独进行排序，各自排序完后再取出组合，组成的序列就是有序的了</p><p>桶排序的时间复杂度 O(n)。如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k _ logk)。m 个桶排序的时间复杂度就是 O(m _ k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。</p><p>看起来很不错，但是桶排序对于数据的要求实际上是非常苛刻的</p><ol><li>首先，数据要很容易划分成桶，并且桶与桶之间有着天然的大小顺序。这样每个桶排完序才能直接合并</li><li>数据在各个桶内的分布如果是均匀的，很好，但如果不均匀，极端情况下都分到一个桶里，那就变成 O(nlogn)</li></ol><p>桶排序适合用在外部排序中</p><blockquote><p>外部排序。数据都存储在外部磁盘中，很大，但是我们的内存有限，无法全部加载到内存中</p></blockquote><p>比如 10G 的订单数据，但是我们只有 100mb 内存，需要加载进来按订单金额排序</p><p>我们可以获取订单金额的范围，比如是 1 元-10 万元，将其划分到 10 个桶里，第一个桶是 1-10000，第二个 10000-20000...如果理想的话，数据分布均匀，每个桶里就会有 10mb 左右的数据，逐个用快排排序，最后合并起来就是一份从小到大的订单数据</p><p>但是数据不可能那么均匀，我们可以针对数据量大的区间接着划分小区间，直到能读取到合适的数据量为止</p><h3 id="计数排序" tabindex="-1">计数排序 <a class="header-anchor" href="#计数排序" aria-label="Permalink to “计数排序”">​</a></h3><p>是桶排序的一种特殊情况，往桶里塞入相同的数据，这样就不需要桶内排序，直接合并就完事了，只涉及遍历扫描，时间复杂度 O(n)</p><p>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合。而且，技术排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数（其实 js 用键值对就不存在这个问题）</p><h3 id="基数排序" tabindex="-1">基数排序 <a class="header-anchor" href="#基数排序" aria-label="Permalink to “基数排序”">​</a></h3><p>比如给手机号排序，可以从最后一位开始排序，时间复杂度 O(n)</p><p>如果是给英文单词排序，长度不一，但是可以通过补 0 来解决，因为 ASCII 码，所有字母都大于 0，补 0 不会影响原有得大小顺序。</p><p>技术排序对数据有要求，需要可以分割出独立的位来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序</p><h3 id="排序优化" tabindex="-1">排序优化 <a class="header-anchor" href="#排序优化" aria-label="Permalink to “排序优化”">​</a></h3><p><img src="`+e+`" alt="表格" loading="lazy"></p><p>线性排序算法时间复杂度较低，适用场景特殊，通用的排序函数不能选择线型排序算法</p><p>快速排序较为适合，但是快速排序的最坏情况时间复杂度是 O(n^2)，主要还是因为分区点选的不够合理，最理想的分区点是被分开的两个分区中，数据的数量差不多</p><p>有两个比较常用、简单的分区法</p><ol><li>三数取中法。从区间的首尾中分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点，但是如果排序的数组比较大，那可能就要五数取中或者十数取中</li><li>随机法。随机选择一个元素作为分区点</li></ol><p>在实际使用中，排序并不一定仅限于单一场景，通过针对不同情况灵活运用才能让执行效率更高。比如 qsort 函数</p><p>qsort 会优先使用归并排序，因为数据量小的时候，归并排序更快，空间换时间，但是数据量大的时候，会改用快速排序（三数取中法）。当元素个数小于等于 4 时，qsort 使用插入排序</p><h2 id="查找算法" tabindex="-1">查找算法 <a class="header-anchor" href="#查找算法" aria-label="Permalink to “查找算法”">​</a></h2><h3 id="二分查找" tabindex="-1">二分查找 <a class="header-anchor" href="#二分查找" aria-label="Permalink to “二分查找”">​</a></h3><p>复杂度 O(logn)，效率极高，但是有局限性</p><ol><li>二分查找依赖顺序表结构数组，其他的数据结构不适用</li><li>数组必须有序。二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中，针对动态变化的数据集合，二分查找将不再适用</li><li>如果数据量很小，没有必要用二分查找，顺序遍历即可。但是如果数据项都是长度超过 300 的字符串就要使用二分，因为 300 长度字符串的大小对比很耗时</li><li>数据量太大也不适合二分。因为二分查找要求数组，而数组是内存空间连续的数据结构，如果数据量太大，对内存空间的要求太苛刻。（JS 的数组由于是对象模拟出来的，不必在意这个）</li></ol><h4 id="二分查找的变形问题" tabindex="-1">二分查找的变形问题 <a class="header-anchor" href="#二分查找的变形问题" aria-label="Permalink to “二分查找的变形问题”">​</a></h4><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">46</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">46</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">46</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">90</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bSearch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> low </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> high </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (low </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> high) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mid </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> low </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((high </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> low) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (array[mid] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      high </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mid </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      low </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mid </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (low </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array[low] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> low;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h4 id="查找第一个值等于给定值的元素" tabindex="-1">查找第一个值等于给定值的元素 <a class="header-anchor" href="#查找第一个值等于给定值的元素" aria-label="Permalink to “查找第一个值等于给定值的元素”">​</a></h4><p>分两种情况，算上右侧边界，需要定 right=nums.length-1，否则不用减 1</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number[]}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> search</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nums</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> right) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> middle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (nums[middle] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> middle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (nums[middle] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> middle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> middle;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h2 id="移除元素" tabindex="-1">移除元素 <a class="header-anchor" href="#移除元素" aria-label="Permalink to “移除元素”">​</a></h2><p>这种题目的关键在于，数组元素在内存中的地址是连续的，不能单独删除某个元素，，只能覆盖 可以采用双层 for 循环，一层遍历数组元素，一层在发现需要移除元素后，将数组集体向前移动一位，但是时间复杂度为 O(n^2)，因此不推荐 使用双指针法，只需要一层 for 循环，遇到目标元素时，会区分出快慢指针，从而移动元素位置，时间复杂度为 O(n)</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number[]}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> val</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> removeElement</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nums</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slowIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (nums[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> val) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      nums[slowIndex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[i];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slowIndex;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h2 id="滑动窗口" tabindex="-1">滑动窗口 <a class="header-anchor" href="#滑动窗口" aria-label="Permalink to “滑动窗口”">​</a></h2><p>像一个窗口一样，每当和大于目标值时，就移动左右窗口，这道题有个坑，就是每当和大于目标值时，计算子串长度不需要加 1，因为在这一步里必然会减去左侧的一个值，必然需要减去 1</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number[]}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> minSubArrayLen</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nums</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> subLength </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 给一个不可能的值，没有改变就说明不存在目标子串</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[right</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      subLength </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> subLength </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> subLength;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[left</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 可能存在全部相加也不大于等于目标值的情况</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h2 id="有序数组的平方排序" tabindex="-1">有序数组的平方排序 <a class="header-anchor" href="#有序数组的平方排序" aria-label="Permalink to “有序数组的平方排序”">​</a></h2><p>这类题可以用双指针法，直接将时间复杂度降到了 O(n)</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number[]}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number[]}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sortedSquares</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nums</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (nums[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[j] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[j]) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      result[k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[j] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[j];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      result[k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[i];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div>`,192)]))}const D=i(r,[["render",E]]);export{A as __pageData,D as default};
