import{g as N,a4 as z,r as c,s as u,w as H,n as b,J as C,H as p,E as k,L as v,Q as m,I as U,G as W,a1 as y,K as I,R as V,T as J,ak as e,_ as G}from"./framework.BCNbIE3H.js";import{a as $,N as X,C as Z,B as Q,d as K}from"./theme.4eZgU6vD.js";const Y=JSON.parse('[{"src":"[[toc]]\\n\\n# 🚀 AI 时代下前端开发的竞争力重塑：从交付代码到交付价值\\n\\n> _\\"AI 不是要取代开发者，而是要重新定义开发者的价值\\"_ —— 玉伯\\n\\n![玉伯-即刻](./images/yubo-jike.jpeg)\\n\\n## 🌊 AI 时代前端开发工种面临的挑战与机遇\\n\\n### 💼 **工种定义的重塑：从\\"代码工人\\"到\\"价值创造者\\"**\\n\\n**传统前端开发者的困境：**\\n\\n在 AI 工具普及之前，前端开发者主要面临以下问题：\\n\\n- **🔄 重复性工作**：CRUD 页面、表单、样式、交互、兼容...\\n- **⏰ 交付效率瓶颈**：前后端联调、样式交互细节...沟通成本高\\n- **🔧 技术债务累积**：技术更迭快，升级成本高；不抽象 = 处处维护，高度抽象 = 无力维护...\\n\\n**AI 时代的机遇与挑战：**\\n\\n随着 AI 工具的普及，前端开发工种正在发生根本性转变：\\n\\n#### **🎯 挑战：AI 工具带来的\\"能力焦虑\\"**\\n\\n- **🤖 代码生成能力**：AI 的代码生成能力终会更好用、更易用\\n- **🔄 角色重新定位**：从\\"代码实现者\\"转向\\"需求理解者\\"和\\"价值创造者\\"\\n\\n#### **🚀 机遇：从\\"交付代码\\"到\\"交付价值\\"**\\n\\n**传统模式：代码交付**\\n\\n```\\n需求 → 设计 → 编码 → 测试 → 部署 → 交付代码\\n```\\n\\n**AI 时代模式：价值交付**\\n\\n```md:line-numbers {1}\\n需求理解 → 方案设计 → AI 辅助实现、测试 → 用户体验优化 → 业务价值验证 → 持续迭代\\n```\\n\\n**核心转变：**\\n\\n<div class=\\"grid grid-cols-1 md:grid-cols-3 gap-6 my-8\\">\\n\\n::: warning 🔄 关注点转移\\n**之前**：如何写出更好的代码  \\n**现在**：如何创造更大的业务价值\\n:::\\n\\n::: info 🛠️ 工具使用方式\\n**之前**：手写每一行代码  \\n**现在**：AI 生成代码，开发者优化和组合\\n:::\\n\\n::: tip 📊 成功指标变化\\n**之前**：代码质量、性能指标  \\n**现在**：用户体验、业务指标、转化率\\n:::\\n\\n</div>\\n\\n---\\n\\n## 1️⃣ AI 时代的马太效应\\n\\n### 💡 马太效应：赢者通吃的时代\\n\\n**在 AI 时代，技术选型比以往任何时候都重要。**\\n\\n强者愈强，弱者愈弱。选择主流技术栈，意味着：\\n\\n- 🎯 更好的 AI 支持\\n- 🌟 更丰富的生态资源\\n- 🛡️ 更稳定的社区支持\\n\\n## 2️⃣ AI 时代技术选型的三大核心原则\\n\\n<div class=\\"grid grid-cols-1 md:grid-cols-3 gap-6 my-8\\">\\n\\n::: tip 🤖 AI 工具支持度\\n**选择 AI 最懂的技术**\\n\\n**为什么重要？** AI 工具对主流技术的理解度最高，能提供最准确的代码生成和建议。\\n\\n- **主流框架优先**：React、Vue、Next.js - AI 理解度最高\\n- **远离小众技术**：AI 训练数据少，支持效果差\\n- **标准化模式**：React Hooks、组件 Props、事件处理等标准模式\\n  :::\\n\\n::: info 🌱 生态成熟度\\n**选择最活跃的社区**\\n\\n**为什么重要？** 成熟的生态意味着更多 AI 训练数据、更好的工具支持和更稳定的维护。\\n\\n- **依赖包生态**：npm 包数量多，社区活跃\\n- **工具链支持**：Vite、Webpack、Jest 等主流工具 AI 支持好\\n- **类型安全**：TypeScript 生态完善，AI 理解代码结构更好\\n  :::\\n\\n::: warning 🚀 技术先进性\\n**选择面向未来的技术**\\n\\n**为什么重要？** 先进技术通常有更好的 AI 支持，能提升开发效率和代码质量。\\n\\n- **现代构建工具**：Vite、Turbopack 等 ESM 和 HMR 机制\\n- **性能优化友好**：虚拟滚动、时间分片、懒加载等优化模式\\n- **AI 原生支持**：Next.js App Router、React Server Components 等新特性\\n  :::\\n\\n</div>\\n\\n---\\n\\n## 3️⃣ AI 时代代码组织模式变革\\n\\n![玉伯-即刻](./images/ai-human.jpeg)\\n\\n### 🎯 传统组件封装 vs shadcn 模板式组件\\n\\n#### **传统组件封装模式：过度设计的\\"黑盒\\"**\\n\\n::: details 🔍 点击展开：传统 Button 组件的复杂内部实现（AI 看了想哭）\\n\\n```tsx:line-numbers {1}\\n// 传统Button组件的内部实现 - AI完全看不懂\\nconst Button = forwardRef<HTMLButtonElement, ButtonProps>(\\n  (\\n    {\\n      variant = \'default\',\\n      size = \'default\',\\n      loading = false,\\n      icon,\\n      iconPosition = \'left\',\\n      rounded = \'default\',\\n      shadow = \'default\',\\n      hoverEffect = \'none\',\\n      focusRing = \'default\',\\n      animation = \'none\',\\n      responsive = false,\\n      accessibility = {},\\n      theme = {},\\n      breakpoints = {},\\n      className,\\n      children,\\n      ...props\\n    },\\n    ref\\n  ) => {\\n    // 复杂的variant逻辑 - AI看了就晕\\n    const variantStyles = useMemo(() => {\\n      switch (variant) {\\n        case \'primary\':\\n          return {\\n            light: { bg: theme.light?.bg || \'#007bff\', text: theme.light?.text || \'white\' },\\n            dark: { bg: theme.dark?.bg || \'#0056b3\', text: theme.dark?.text || \'white\' }\\n          };\\n        case \'secondary\':\\n          return {\\n            light: { bg: theme.light?.bg || \'#6c757d\', text: theme.light?.text || \'white\' },\\n            dark: { bg: theme.dark?.bg || \'#545b62\', text: theme.dark?.text || \'white\' }\\n          };\\n        // ... 还有20+个case\\n      }\\n    }, [variant, theme]);\\n\\n    // 复杂的size逻辑 - AI看了想哭\\n    const sizeStyles = useMemo(() => {\\n      const baseSizes = {\\n        small: { px: \'8px\', py: \'4px\', fontSize: \'12px\' },\\n        default: { px: \'12px\', py: \'6px\', fontSize: \'14px\' },\\n        large: { px: \'16px\', py: \'8px\', fontSize: \'16px\' }\\n      };\\n\\n      if (responsive && breakpoints) {\\n        return {\\n          sm: baseSizes[breakpoints.sm || \'default\'],\\n          md: baseSizes[breakpoints.md || \'default\'],\\n          lg: baseSizes[breakpoints.lg || \'default\']\\n        };\\n      }\\n\\n      return baseSizes[size];\\n    }, [size, responsive, breakpoints]);\\n\\n    // 复杂的动画逻辑 - AI看了想跳楼\\n    const animationStyles = useMemo(() => {\\n      switch (animation) {\\n        case \'bounce\':\\n          return \'animate-bounce\';\\n        case \'pulse\':\\n          return \'animate-pulse\';\\n        case \'spin\':\\n          return \'animate-spin\';\\n        // ... 还有10+个case\\n      }\\n    }, [animation]);\\n\\n    // 复杂的hover效果逻辑 - AI看了想撞墙\\n    const hoverStyles = useMemo(() => {\\n      switch (hoverEffect) {\\n        case \'scale\':\\n          return \'hover:scale-105 transition-transform\';\\n        case \'lift\':\\n          return \'hover:-translate-y-1 transition-transform\';\\n        case \'glow\':\\n          return \'hover:shadow-lg transition-shadow\';\\n        // ... 还有8+个case\\n      }\\n    }, [hoverEffect]);\\n\\n    // 复杂的主题逻辑 - AI看了想回家\\n    const currentTheme = useTheme();\\n    const themeStyles = useMemo(() => {\\n      return currentTheme === \'dark\' ? variantStyles.dark : variantStyles.light;\\n    }, [currentTheme, variantStyles]);\\n\\n    // 复杂的响应式逻辑 - AI看了想转行\\n    const responsiveStyles = useMemo(() => {\\n      if (!responsive) return {};\\n\\n      return {\\n        \'@media (max-width: 640px)\': sizeStyles.sm,\\n        \'@media (min-width: 641px) and (max-width: 1024px)\': sizeStyles.md,\\n        \'@media (min-width: 1025px)\': sizeStyles.lg\\n      };\\n    }, [responsive, sizeStyles]);\\n\\n    // 复杂的可访问性逻辑 - AI看了想退休\\n    const accessibilityProps = useMemo(() => {\\n      return {\\n        \'aria-label\': accessibility.ariaLabel,\\n        role: accessibility.role || \'button\',\\n        tabIndex: accessibility.tabIndex || 0,\\n        ...(loading && { \'aria-busy\': true })\\n      };\\n    }, [accessibility, loading]);\\n\\n    return (\\n      <button\\n        ref={ref}\\n        className={cn(\\n          \'inline-flex items-center justify-center border-0 cursor-pointer\',\\n          \'focus:outline-none focus:ring-2 focus:ring-offset-2\',\\n          `focus:ring-${focusRing === \'default\' ? \'blue\' : focusRing}-500`,\\n          `rounded-${rounded === \'default\' ? \'md\' : rounded}`,\\n          `shadow-${shadow === \'default\' ? \'sm\' : shadow}`,\\n          animationStyles,\\n          hoverStyles,\\n          responsiveStyles,\\n          className\\n        )}\\n        style={{\\n          backgroundColor: themeStyles.bg,\\n          color: themeStyles.text,\\n          padding: `${sizeStyles.py} ${sizeStyles.px}`,\\n          fontSize: sizeStyles.fontSize,\\n          ...responsiveStyles\\n        }}\\n        disabled={loading || props.disabled}\\n        {...accessibilityProps}\\n        {...props}\\n      >\\n        {icon && iconPosition === \'left\' && <span className=\\"mr-2\\">{icon}</span>}\\n        {children}\\n        {icon && iconPosition === \'right\' && <span className=\\"ml-2\\">{icon}</span>}\\n        {loading && (\\n          <span className=\\"ml-2\\">\\n            <Spinner size={size} />\\n          </span>\\n        )}\\n      </button>\\n    );\\n  }\\n);\\n\\nButton.displayName = \'Button\';\\n```\\n\\n:::\\n\\n::: details 🔍 点击展开：传统 Button 组件的复杂使用方式（50+个 props）\\n\\n```tsx:line-numbers {1}\\n// 传统方式：过度封装，AI完全看不懂的黑盒\\n<Button\\n  variant=\\"primary\\"\\n  size=\\"large\\"\\n  onClick={handleClick}\\n  disabled={isLoading}\\n  loading={isLoading}\\n  icon={isLoading ? <Spinner /> : <CheckIcon />}\\n  iconPosition=\\"left\\"\\n  rounded=\\"full\\"\\n  shadow=\\"lg\\"\\n  hoverEffect=\\"scale\\"\\n  focusRing=\\"blue\\"\\n  animation=\\"bounce\\"\\n  responsive={true}\\n  accessibility={{\\n    ariaLabel: \'Submit form button\',\\n    role: \'button\',\\n    tabIndex: 0\\n  }}\\n  theme={{\\n    light: { bg: \'blue-500\', text: \'white\' },\\n    dark: { bg: \'blue-600\', text: \'white\' }\\n  }}\\n  breakpoints={{\\n    sm: { size: \'small\' },\\n    md: { size: \'medium\' },\\n    lg: { size: \'large\' }\\n  }}\\n>\\n  {isLoading ? \'Loading...\' : \'Submit\'}\\n</Button>\\n```\\n\\n:::\\n\\n**特点：**\\n\\n- **🚫 过度抽象**：一个按钮组件包含 50+个 props，内部逻辑复杂到爆炸\\n- **🔄 可维护性\\"高\\"**：逻辑集中，但每次修改都要考虑 50+个 props 的兼容性\\n- **🤖 AI 完全懵逼**：内部实现是黑盒，AI 看到这堆 props 就晕了\\n- **🎨 定制化困难**：想改个颜色都要通过 theme 系统，想改个样式要翻遍文档\\n- **🐛 Bug 温床**：50+个 props 的组合爆炸，测试覆盖不过来\\n- **📚 学习成本高**：同事要 3 天才能搞懂这个 Button 怎么用，不敢轻易修改，干脆复制一份\\n\\n---\\n\\n#### **shadcn + Tailwind CSS 模式：AI 时代的\\"透明模板\\"**\\n\\n::: details 🔍 点击展开：shadcn Button 组件的简洁内部实现（AI 看了想点赞）\\n\\n```tsx:line-numbers {1}\\n// shadcn Button组件的内部实现 - AI看了想点赞\\nconst Button = React.forwardRef<\\n  HTMLButtonElement,\\n  React.ButtonHTMLAttributes<HTMLButtonElement> & VariantProps<typeof buttonVariants>\\n>(({ className, variant, size, asChild = false, ...props }, ref) => {\\n  const Comp = asChild ? Slot : \'button\';\\n\\n  return <Comp className={cn(buttonVariants({ variant, size, className }))} ref={ref} {...props} />;\\n});\\n\\n// 样式变体定义 - 简单到AI都能背下来\\nconst buttonVariants = cva(\\n  \'inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\',\\n  {\\n    variants: {\\n      variant: {\\n        default: \'bg-primary text-primary-foreground hover:bg-primary/90\',\\n        destructive: \'bg-destructive text-destructive-foreground hover:bg-destructive/90\',\\n        outline: \'border border-input bg-background hover:bg-accent hover:text-accent-foreground\',\\n        secondary: \'bg-secondary text-secondary-foreground hover:bg-secondary/80\',\\n        ghost: \'hover:bg-accent hover:text-accent-foreground\',\\n        link: \'text-primary underline-offset-4 hover:underline\'\\n      },\\n      size: {\\n        default: \'h-10 px-4 py-2\',\\n        sm: \'h-9 rounded-md px-3\',\\n        lg: \'h-11 rounded-md px-8\',\\n        icon: \'h-10 w-10\'\\n      }\\n    },\\n    defaultVariants: {\\n      variant: \'default\',\\n      size: \'default\'\\n    }\\n  }\\n);\\n```\\n\\n:::\\n\\n::: details 🔍 点击展开：shadcn Button 组件的简洁使用方式\\n\\n```tsx:line-numbers {1}\\n// shadcn方式：简单透明，AI一眼就能看懂\\n<Button\\n  className=\\"bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md\\n             shadow-lg hover:shadow-xl transition-all duration-200\\n             disabled:opacity-50 disabled:cursor-not-allowed\\"\\n  onClick={handleClick}\\n  disabled={isLoading}\\n>\\n  {isLoading ? (\\n    <div className=\\"flex items-center gap-2\\">\\n      <div className=\\"w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin\\" />\\n      Loading...\\n    </div>\\n  ) : (\\n    \'Submit\'\\n  )}\\n</Button>\\n```\\n\\n:::\\n\\n**特点：**\\n\\n- **✨ 透明设计**：组件逻辑简单到 AI 一眼就能看懂\\n- **🎨 高度可定制**：想改什么样式，直接改 className 就行\\n- **🤖 AI 超友好**：Tailwind 类名语义化，AI 理解度爆表\\n- **🔄 可抛弃性**：组件简单，AI 可以轻松重构，重写成本为 0\\n- **📖 学习成本低**：新同事 5 分钟就能上手\\n- **🚀 开发效率高**：AI 能快速生成和修改，开发速度翻倍\\n\\n---\\n\\n### 📏 **上下文长度优化：TailWind 的附赠**\\n\\n#### **为什么 Tailwind CSS 能更好地控制上下文长度？**\\n\\n**传统 CSS 方式 - 上下文长度爆炸：**\\n\\n::: details 🔍 点击展开：传统 CSS 的上下文长度爆炸示例\\n\\n```css:line-numbers {1}\\n/* 传统CSS：一个按钮需要大量上下文 */\\n.button-primary {\\n  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\\n  color: #ffffff;\\n  padding: 12px 24px;\\n  font-size: 16px;\\n  font-weight: 600;\\n  border: 2px solid #667eea;\\n  border-radius: 8px;\\n  box-shadow: 0 4px 15px 0 rgba(116, 75, 162, 0.4);\\n  transition: all 0.3s ease;\\n}\\n\\n.button-primary:hover {\\n  background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%);\\n  transform: translateY(-2px);\\n  box-shadow: 0 6px 20px 0 rgba(116, 75, 162, 0.6);\\n}\\n\\n/* 响应式设计 */\\n@media (max-width: 768px) {\\n  .button-primary {\\n    font-size: 14px;\\n    padding: 10px 20px;\\n  }\\n}\\n```\\n\\n:::\\n\\n**Tailwind CSS 方式 - 上下文长度优化：**\\n\\n::: details 🔍 点击展开：Tailwind CSS 的上下文长度优化示例\\n\\n```tsx:line-numbers {1}\\n// Tailwind CSS：所有样式都在一个地方，上下文集中\\n<button\\n  className=\\"\\n  bg-gradient-to-br from-indigo-500 to-purple-600 text-white\\n  px-6 py-3 text-base font-semibold\\n  border-2 border-indigo-500 rounded-lg\\n  shadow-lg hover:shadow-xl transition-all duration-300\\n  hover:from-indigo-600 hover:to-purple-700 hover:-translate-y-0.5\\n  sm:text-sm sm:px-4 sm:py-2\\n  md:text-base md:px-6 md:py-3\\n  lg:text-lg lg:px-8 lg:py-4\\n\\"\\n>\\n  Click me!\\n</button>\\n```\\n\\n:::\\n\\n#### **AI 时代上下文长度的重要性**\\n\\n**为什么 AI 更喜欢短的上下文？**\\n\\n1. **注意力机制**：AI 的注意力机制在处理长上下文时会分散\\n2. **理解效率**：短上下文让 AI 能更快理解代码意图\\n3. **生成准确性**：上下文越短，AI 生成的代码越准确\\n\\n**实际例子：AI 生成代码的对比**\\n\\n**传统 CSS 方式 - AI 需要长上下文：**\\n\\n::: details 🔍 点击展开：传统 CSS 方式的 AI 生成示例\\n\\n```tsx:line-numbers {1}\\n// AI需要理解：CSS文件 + JSX文件 + 类名映射关系\\n<Button className=\\"button-primary\\" />\\n```\\n\\n:::\\n\\n**Tailwind CSS 方式 - AI 只需要短上下文：**\\n\\n::: details 🔍 点击展开：Tailwind CSS 方式的 AI 生成示例\\n\\n```tsx:line-numbers {1}\\n// AI只需要理解：JSX中的className\\n<Button className=\\"bg-blue-500 hover:bg-blue-600 sm:text-sm md:text-base\\" />\\n```\\n\\n:::\\n\\n### 🎨 Tailwind CSS：恰好顺应 AI 时代的设计潮流\\n\\n#### **为什么 Tailwind CSS 是 AI 友好的？**\\n\\n1. **语义化类名**：AI 理解`bg-blue-500`比理解 CSS 变量更容易\\n2. **原子化设计**：每个类名都有明确含义，AI 能准确组合\\n3. **一致性**：设计系统统一，AI 生成的样式更协调\\n4. **可预测性**：类名行为一致，AI 能准确预测效果\\n\\n#### **传统 CSS：语法标准化，但语义模糊**\\n\\n::: details 🔍 点击展开：传统 CSS 的复杂样式（AI 理解困难）\\n\\n```css:line-numbers {1}\\n/* 传统CSS：语法是标准的，但每个值对AI来说都是\\"魔法数字\\" */\\n.button-primary {\\n  /* 背景渐变 - AI需要理解复杂的CSS函数和角度值 */\\n  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\\n\\n  /* 阴影 - AI需要理解4个数值的含义和组合效果 */\\n  box-shadow: 0 4px 15px 0 rgba(116, 75, 162, 0.4);\\n\\n  /* 过渡 - AI需要理解\\"all\\"的含义和缓动函数 */\\n  transition: all 0.3s ease;\\n\\n  /* 尺寸 - AI不知道这些数值代表什么效果 */\\n  padding: 12px 24px;\\n  font-size: 16px;\\n  line-height: 1.5;\\n\\n  /* 颜色 - AI需要理解十六进制和RGBA的差异 */\\n  color: #ffffff;\\n  border: 2px solid #667eea;\\n\\n  /* 圆角 - AI不知道8px的圆角效果如何 */\\n  border-radius: 8px;\\n}\\n\\n/* 状态变化 - AI需要理解伪类选择器和对应的样式值 */\\n.button-primary:hover {\\n  /* AI不知道-2px的位移效果如何 */\\n  transform: translateY(-2px);\\n  /* AI不知道这些阴影值的变化逻辑 */\\n  box-shadow: 0 6px 20px 0 rgba(116, 75, 162, 0.6);\\n}\\n\\n/* 响应式 - AI需要理解像素断点的含义 */\\n@media (max-width: 768px) {\\n  .button-primary {\\n    /* AI不知道为什么要改成这些值 */\\n    font-size: 14px;\\n    padding: 10px 20px;\\n  }\\n}\\n```\\n\\n:::\\n\\n**AI 理解传统 CSS 的核心困难：**\\n\\n1. **🎯 语义缺失**：\\n\\n   - `16px` = 大字体还是小字体？AI 不知道\\n   - `8px` = 圆角效果如何？AI 不知道\\n   - `135deg` = 渐变角度效果如何？AI 不知道\\n\\n2. **🔢 数值无意义**：\\n\\n   - `12px 24px` = 这个间距合适吗？AI 不知道\\n   - `0.3s` = 过渡时长合适吗？AI 不知道\\n   - `0.4` = 透明度效果如何？AI 不知道\\n\\n3. **🎨 组合效果不可预测**：\\n   - 多个 CSS 属性组合的最终效果，AI 难以预测\\n   - 需要理解 CSS 的层叠和继承规则\\n\\n---\\n\\n#### **Tailwind CSS：语法和语义都标准化**\\n\\n::: details 🔍 点击展开：Tailwind CSS 的语义化样式（AI 理解容易）\\n\\n```tsx:line-numbers {1}\\n// Tailwind CSS：每个类名都有明确的语义\\n<button\\n  className=\\"\\n  /* 背景和颜色 - 语义清晰 */\\n  bg-gradient-to-br from-indigo-500 to-purple-600\\n  text-white\\n\\n  /* 尺寸和间距 - 数字有含义 */\\n  px-6 py-3          /* 6=24px, 3=12px - AI理解数字规律 */\\n  text-base           /* 基础字体大小 - AI知道这是标准大小 */\\n  font-semibold       /* 半粗体 - AI理解字重含义 */\\n  leading-relaxed     /* 宽松行高 - AI理解行高效果 */\\n\\n  /* 边框和圆角 - 语义化命名 */\\n  border-2            /* 2px边框 - AI理解边框粗细 */\\n  border-indigo-500   /* 靛蓝色边框 - AI理解颜色系统 */\\n  rounded-lg          /* 大圆角 - AI知道这是适中的圆角 */\\n\\n  /* 阴影和过渡 - 效果可预测 */\\n  shadow-lg           /* 大阴影 - AI知道阴影效果 */\\n  hover:shadow-xl     /* 悬停时超大阴影 - AI理解状态变化 */\\n  transition-all      /* 所有属性过渡 - AI理解过渡范围 */\\n  duration-300        /* 300ms过渡 - AI理解时长 */\\n\\n  /* 交互状态 - 状态变化语义化 */\\n  hover:from-indigo-600 hover:to-purple-700  /* 悬停时颜色变深 */\\n  hover:-translate-y-0.5                     /* 悬停时向上移动 */\\n  active:translate-y-0                        /* 点击时回到原位 */\\n  active:shadow-md                            /* 点击时中等阴影 */\\n\\n  /* 禁用状态 - 语义化禁用样式 */\\n  disabled:opacity-60         /* 禁用时60%透明度 */\\n  disabled:cursor-not-allowed /* 禁用时禁止光标 */\\n  disabled:bg-gray-400        /* 禁用时灰色背景 */\\n  disabled:text-gray-600      /* 禁用时深灰文字 */\\n\\n  /* 响应式设计 - 断点语义化 */\\n  sm:text-sm sm:px-4 sm:py-2   /* 小屏幕：小字体，小间距 */\\n  md:text-base md:px-6 md:py-3 /* 中屏幕：标准字体，标准间距 */\\n  lg:text-lg lg:px-8 lg:py-4   /* 大屏幕：大字体，大间距 */\\n\\"\\n>\\n  Click me!\\n</button>\\n```\\n\\n:::\\n\\n**AI 理解 Tailwind CSS 的核心优势：**\\n\\n1. **🎯 语义化类名**：\\n\\n   - `bg-blue-500` = \\"蓝色背景，500 是中等深浅\\" - AI 秒懂\\n   - `px-6` = \\"水平内边距 6 个单位（24px）\\" - AI 理解数字含义\\n   - `rounded-lg` = \\"大圆角\\" - AI 知道这是适中的圆角效果\\n\\n2. **🔢 数字系统有规律**：\\n\\n   - `text-sm`、`text-base`、`text-lg` - AI 理解大小关系\\n   - `px-2`、`px-4`、`px-6`、`px-8` - AI 理解间距规律（8px、16px、24px、32px）\\n   - `opacity-50`、`opacity-75`、`opacity-100` - AI 理解透明度（50%、75%、100%）\\n\\n3. **🎨 颜色系统可预测**：\\n\\n   - `from-indigo-500`、`to-purple-600` - AI 理解渐变方向和颜色深浅\\n   - `hover:from-indigo-600` - AI 理解悬停时颜色变深的逻辑\\n   - `disabled:bg-gray-400` - AI 理解禁用状态使用灰色\\n\\n4. **📱 响应式断点清晰**：\\n   - `sm:`、`md:`、`lg:` - AI 理解断点的语义（小、中、大屏幕）\\n   - 每个断点都有明确的含义，AI 容易生成响应式代码\\n\\n---\\n\\n---\\n\\n#### **实际代码生成对比**\\n\\n**传统 CSS - AI 生成困难：**\\n\\n::: details 🔍 点击展开：传统 CSS 的 AI 生成困难示例\\n\\n```css:line-numbers {1}\\n/* AI需要理解复杂的CSS语法，容易出错 */\\n.button-custom {\\n  /* AI可能不知道这些值是否合适 */\\n  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\\n  box-shadow: 0 4px 15px 0 rgba(116, 75, 162, 0.4);\\n\\n  /* AI可能忘记添加transition */\\n  /* AI可能不理解hover状态应该如何变化 */\\n  /* AI可能不知道响应式断点应该设置什么值 */\\n}\\n```\\n\\n:::\\n\\n**Tailwind CSS - AI 生成容易：**\\n\\n::: details 🔍 点击展开：Tailwind CSS 的 AI 生成容易示例\\n\\n```tsx:line-numbers {1}\\n// AI只需要组合语义化的类名，不容易出错\\nclassName=\\"bg-gradient-to-br from-blue-500 to-purple-600\\n           shadow-lg hover:shadow-xl hover:from-blue-600 hover:to-purple-700\\n           transition-all duration-300\\n           sm:text-sm sm:px-4 md:text-base md:px-6 lg:text-lg lg:px-8\\"\\n// 每个类名都有明确含义，AI容易理解和组合\\n```\\n\\n:::\\n\\n#### **核心洞察**\\n\\n**传统 CSS 的问题不在于语法，而在于语义：**\\n\\n1. **CSS 语法确实是标准化的** - 所有浏览器都理解相同的语法\\n2. **但 CSS 值没有语义** - `16px`、`#667eea`、`135deg`对 AI 来说都是无意义的数字\\n3. **属性组合效果不可预测** - 多个 CSS 属性组合的最终效果，AI 难以预测\\n\\n**Tailwind CSS 解决了语义问题：**\\n\\n1. **每个类名都有明确语义** - `bg-blue-500` = \\"蓝色背景，中等深浅\\"\\n2. **数字系统有规律** - `px-6` = \\"24px\\"，`text-lg` = \\"大字体\\"\\n3. **效果可预测** - 每个类名的效果都是预定义的，AI 容易理解\\n\\n**结论：Tailwind CSS 让 AI 从\\"理解 CSS 语法\\"变成了\\"理解样式语义\\"，大大降低了 AI 的认知负担！**\\n\\n---\\n\\n---\\n\\n### 🔄 代码组织模式的未来趋势\\n\\n#### **1. 从\\"可维护\\"到\\"可重构\\"**\\n\\n- **传统思维**：写一次，维护一辈子\\n- **AI 时代思维**：写简单，AI 重构\\n\\n#### **2. 从\\"黑盒组件\\"到\\"透明模板\\"**\\n\\n- **传统组件**：高度封装，难以定制\\n- **shadcn 模式**：模板化设计，高度可定制\\n\\n#### **3. 从\\"复杂逻辑\\"到\\"简单组合\\"**\\n\\n- **传统方式**：一个组件包含复杂逻辑\\n- **AI 时代方式**：简单组件通过组合实现复杂功能\\n\\n#### **4. 从\\"长期维护\\"到\\"快速迭代\\"**\\n\\n- **传统思维**：代码要能长期维护\\n- **AI 时代思维**：代码要能快速重构和替换\\n\\n### 💡 **可维护代码 vs 可抛弃代码：AI 时代的代码哲学**\\n\\n#### **传统代码哲学：\\"可维护性\\"**\\n\\n<div class=\\"grid grid-cols-1 md:grid-cols-2 gap-6 my-8\\">\\n\\n::: info 🔧 **可维护代码的特点**\\n\\n- **高度抽象**：复杂的抽象层，隐藏实现细节\\n- **文档完善**：详细的注释和文档说明\\n- **向后兼容**：新版本必须兼容旧版本\\n- **防御性编程**：大量的边界检查和错误处理\\n- **设计模式**：严格遵循设计模式原则\\n  :::\\n\\n::: warning ⚠️ **可维护代码的问题**\\n\\n1. **过度工程化**：为了\\"可维护性\\"而过度设计\\n2. **开发速度慢**：写一个简单功能需要大量样板代码\\n3. **AI 理解困难**：复杂的抽象层让 AI 难以理解代码意图\\n4. **重构成本高**：修改一个功能需要理解整个抽象体系\\n5. **学习成本高**：新同事需要学习复杂的架构设计\\n   :::\\n\\n</div>\\n\\n#### **AI 时代代码哲学：\\"可抛弃性\\"**\\n\\n<div class=\\"grid grid-cols-1 md:grid-cols-2 gap-6 my-8\\">\\n\\n::: tip ✨ **可抛弃代码的特点**\\n\\n- **简单直接**：代码逻辑清晰，没有过度抽象\\n- **功能聚焦**：每个函数/组件只做一件事\\n- **易于重构**：AI 可以快速理解和重构\\n- **自解释**：代码本身就是最好的文档\\n- **快速迭代**：可以快速重写，不担心破坏现有架构\\n  :::\\n\\n::: info 🚀 **可抛弃代码的优势**\\n\\n1. **开发速度快**：写代码快，改代码更快\\n2. **AI 友好**：AI 容易理解和生成\\n3. **重构成本低**：重写比修改更容易\\n4. **学习成本低**：新同事 5 分钟就能上手\\n5. **创意自由**：不被复杂架构束缚\\n   :::\\n\\n</div>\\n\\n#### **AI 时代的选择：什么时候用哪种？**\\n\\n<div class=\\"grid grid-cols-1 md:grid-cols-2 gap-6 my-8\\">\\n\\n::: tip 🚀 **选择可抛弃代码的场景**\\n\\n1. **快速原型**：需要快速验证想法\\n2. **频繁迭代**：功能还在探索阶段\\n3. **AI 辅助开发**：希望 AI 能快速理解和重构\\n4. **简单功能**：CRUD、表单、列表等基础功能\\n5. **MVP 阶段**：产品还在验证阶段\\n   :::\\n\\n::: warning 🏗️ **选择可维护代码的场景**\\n\\n1. **核心架构**：系统的基础设施和核心服务\\n2. **关键业务**：不能出错的业务逻辑\\n3. **长期稳定**：功能已经稳定，长期不会改变\\n4. **团队协作**：多人维护的公共组件\\n5. **安全敏感**：涉及安全、权限等敏感功能\\n   :::\\n\\n</div>\\n\\n#### **实践建议：如何写可抛弃代码？**\\n\\n**1. 保持简单**\\n\\n::: details 🔍 点击展开：保持简单的代码示例\\n\\n```tsx:line-numbers {1}\\n// ❌ 过度设计\\nconst Button = forwardRef<HTMLButtonElement, ButtonProps>((props, ref) => {\\n  const {\\n    variant,\\n    size,\\n    loading,\\n    icon,\\n    iconPosition,\\n    rounded,\\n    shadow,\\n    hoverEffect,\\n    focusRing,\\n    animation,\\n    responsive,\\n    accessibility,\\n    theme,\\n    breakpoints,\\n    className,\\n    children,\\n    ...restProps\\n  } = props;\\n\\n  // 复杂的逻辑处理...\\n});\\n\\n// ✅ 简单直接\\nconst Button = ({ className, children, ...props }) => (\\n  <button className={cn(\'px-4 py-2 rounded bg-blue-500 text-white\', className)} {...props}>\\n    {children}\\n  </button>\\n);\\n```\\n\\n:::\\n\\n**2. 功能聚焦**\\n\\n::: details 🔍 点击展开：功能聚焦的代码示例\\n\\n```tsx:line-numbers {1}\\n// ❌ 一个组件做太多事\\nconst UserCard = ({\\n  user,\\n  onEdit,\\n  onDelete,\\n  onShare,\\n  onFollow,\\n  showActions,\\n  showStats,\\n  showAvatar\\n}) => {\\n  // 复杂的条件渲染和状态管理...\\n};\\n\\n// ✅ 功能聚焦\\nconst UserCard = ({ user }) => (\\n  <div className=\\"p-4 border rounded\\">\\n    <h3>{user.name}</h3>\\n    <p>{user.email}</p>\\n  </div>\\n);\\n\\nconst UserActions = ({ user, onEdit, onDelete }) => (\\n  <div className=\\"flex gap-2\\">\\n    <button onClick={() => onEdit(user)}>Edit</button>\\n    <button onClick={() => onDelete(user.id)}>Delete</button>\\n  </div>\\n);\\n```\\n\\n:::\\n\\n**3. 避免过度抽象**\\n\\n::: details 🔍 点击展开：避免过度抽象的代码示例\\n\\n```tsx:line-numbers {1}\\n// ❌ 过度抽象\\nconst useUserData = (userId: string) => {\\n  const [user, setUser] = useState<User | null>(null);\\n  const [loading, setLoading] = useState(false);\\n  const [error, setError] = useState<Error | null>(null);\\n\\n  useEffect(() => {\\n    // 复杂的逻辑...\\n  }, [userId]);\\n\\n  return { user, loading, error };\\n};\\n\\n// ✅ 简单直接\\nconst getUser = async (id: string) => {\\n  const response = await fetch(`/api/users/${id}`);\\n  return response.json();\\n};\\n```\\n\\n:::\\n\\n**4. 让代码自解释**\\n\\n::: details 🔍 点击展开：让代码自解释的示例\\n\\n```tsx:line-numbers {1}\\n// ❌ 需要注释才能理解\\nconst processData = data => {\\n  const result = [];\\n  for (let i = 0; i < data.length; i++) {\\n    if (data[i].status === \'active\' && data[i].score > 80) {\\n      result.push({\\n        id: data[i].id,\\n        name: data[i].name,\\n        priority: \'high\'\\n      });\\n    }\\n  }\\n  return result;\\n};\\n\\n// ✅ 自解释的代码\\nconst getHighPriorityActiveUsers = users => {\\n  return users\\n    .filter(user => user.status === \'active\' && user.score > 80)\\n    .map(user => ({\\n      id: user.id,\\n      name: user.name,\\n      priority: \'high\'\\n    }));\\n};\\n```\\n\\n:::\\n\\n#### **AI 时代的代码组织原则**\\n\\n<div class=\\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 my-8\\">\\n\\n::: tip 1️⃣ 简单优于复杂\\n\\n- 能用简单方式实现，就不要用复杂方式\\n- 代码越简单，AI 越容易理解和重构\\n  :::\\n\\n::: info 2️⃣ 可读性优于可维护性\\n\\n- 代码要让人一眼就能看懂\\n- 不要为了\\"可维护性\\"而牺牲可读性\\n  :::\\n\\n::: warning 3️⃣ 组合优于继承\\n\\n- 用简单的组件组合实现复杂功能\\n- 避免复杂的继承和抽象层次\\n  :::\\n\\n::: danger 4️⃣ 快速迭代优于完美设计\\n\\n- 先实现功能，再优化代码\\n- 不要过度设计，代码可以随时重写\\n  :::\\n\\n::: tip 5️⃣ AI 友好优于人工优化\\n\\n- 代码要能让 AI 快速理解\\n- 简单的逻辑比复杂的优化更重要\\n  :::\\n\\n</div>\\n\\n#### **总结：AI 时代的代码哲学**\\n\\n- **可维护代码**：为了长期维护而设计，但开发慢、AI 理解困难\\n- **可抛弃代码**：为了快速迭代而设计，开发快、AI 理解容易\\n\\n---\\n\\n## 4️⃣ 上下文工程（Context Engineering）：让 AI 成为你的专属助手\\n\\n![](./images/more-less.jpg)\\n\\n### **🔍 AI 还是不够懂我**\\n\\n**问题分析**：很多开发者抱怨 AI 生成的代码不符合需求，其实问题不在 AI，而在于：\\n\\n- ❌ **缺乏项目上下文（Project Context）**：AI 不知道你的项目结构、架构设计、依赖关系\\n- ❌ **不了解开发习惯（Development Patterns）**：AI 不知道你喜欢怎么写代码、用什么技术栈\\n- ❌ **没有工作流程（Workflow Context）**：AI 不知道你的开发节奏、代码审查标准\\n- ❌ **缺少工具集成（Tool Integration）**：AI 不知道如何使用外部工具、API 和服务\\n\\n**根本原因**：AI 缺乏足够的上下文信息来理解你的具体需求和约束条件\\n\\n**解决方案**：通过系统性的上下文工程（Context Engineering），让 AI 从\\"通用助手\\"变成\\"你的专属助手\\"\\n\\n::: details 🔍 点击展开：什么是上下文工程（Context Engineering）？\\n\\n### **🧠 什么是上下文工程（Context Engineering）？**\\n\\n**核心洞察**：随着大语言模型（LLM）的广泛应用，开发者发现了一个关键事实：**模型性能的优劣，不仅取决于模型本身的规模和参数量，更取决于它在推理时\\"看见了什么\\"**。\\n\\n**定义**：上下文工程（Context Engineering）是一门围绕大模型输入上下文的设计、管理和动态构建技术体系，目的是让模型在每一次调用中都能获取最合适、最相关的背景信息、任务指令和外部工具接口。\\n\\n**核心价值**：提升 AI 响应的准确性、稳定性和可控性。\\n\\n### **🔑 提示工程 vs 上下文工程**\\n\\n| 提示工程（Prompt Engineering） | 上下文工程（Context Engineering） |\\n| ------------------------------ | --------------------------------- |\\n| 关注\\"怎么问\\"                   | 关注\\"模型看到了什么\\"              |\\n| 优化用户指令                   | 优化模型输入上下文                |\\n| 提升提问技巧                   | 提升上下文质量                    |\\n\\n**关键洞察**：在实际应用中，\\"看到什么\\"对模型表现的影响，往往比\\"怎么问\\"更为关键。\\n\\n:::\\n\\n### **📥 上下文进入 LLM 的三种方式**\\n\\n1. **提示（Prompt）**：用户指令、任务描述\\n2. **检索（Retrieval）**：外部文档、知识库\\n3. **工具调用（Tool Calls）**：API 接口、外部服务\\n\\n**这就是为什么我们需要上下文工程：让 AI\\"看见\\"最相关的信息，而不是仅仅优化提问方式！**\\n\\n### **🎯 我们可以做些什么？4 个工具让你事半功倍**\\n\\n#### **1. 📚 知识库：AI 的\\"项目说明书\\"**\\n\\n**作用**：就像给 AI 一本项目手册，让它了解你的项目\\n\\n**实际效果**：\\n\\n- AI 知道你的项目结构\\n- AI 理解你的代码风格\\n- AI 能给出更准确的建议\\n\\n**简单例子**：\\n\\n```\\nAI：这个按钮应该怎么写？\\n你：参考我们项目中的Button组件\\nAI：好的，我看到了，按照你们的风格来写\\n```\\n\\n**🎯 具体实现：项目文档 + 代码规范**\\n\\n**建立项目知识库的方法**：\\n\\n1. **项目 README**：项目介绍、架构说明、开发指南\\n2. **代码规范文档**：命名规范、组件设计原则、最佳实践\\n3. **组件库文档**：每个组件的使用说明、Props 定义、示例代码\\n4. **架构图**：项目结构、数据流、组件关系\\n\\n**📊 高级方案：RepoMix + 分层策略**\\n\\n**RepoMix 的优势**：能提供完整的项目上下文\\n**RepoMix 的挑战**：可能产生过长的上下文\\n\\n[RepoMix](https://repomix.com/zh-cn/)\\n\\n**分层使用策略**：\\n\\n```\\n第一层：项目文档（README、架构图）\\n第二层：关键模块文档（核心组件、重要逻辑）\\n第三层：RepoMix打包（特定模块，而非整个项目）\\n```\\n\\n**实际应用**：\\n\\n- **日常开发**：使用项目文档和代码规范\\n- **架构分析**：使用 RepoMix 打包关键模块\\n- **深度重构**：按需使用 RepoMix，避免上下文爆炸\\n\\n#### **2. 🔄 工作流：AI 的\\"操作指南\\"**\\n\\n**作用**：告诉 AI 你的工作习惯和流程\\n\\n**实际效果**：\\n\\n- AI 知道你先写什么，后写什么\\n- AI 能按照你的习惯生成代码\\n- AI 不会做无用功\\n\\n**简单例子**：\\n\\n```\\n你：我要写一个登录页面\\nAI：好的，按照你的习惯：\\n1. 先写页面结构\\n2. 再写样式\\n3. 最后写逻辑\\n```\\n\\n#### **3. ⚙️ Cursor Rules：AI 的\\"个人偏好设置\\"**\\n\\n![](./images/cursor-rules.jpeg)\\n\\n[awesome-cursorrules](https://github.com/PatrickJS/awesome-cursorrules)\\n\\n**作用**：就像设置手机主题一样，让 AI 按照你的喜好工作\\n\\n**实际效果**：\\n\\n- AI 生成的代码符合你的风格\\n- AI 知道你喜欢用什么技术\\n- AI 不会推荐你不熟悉的东西\\n\\n**简单例子**：\\n\\n::: details 🔍 点击展开：Cursor Rules\\n\\n```md:line-numbers {1}\\n---\\nalwaysApply: true\\n---\\n\\n# 接口请求规范\\n\\n## 定义规范\\n\\n- 使用 `axios` 进行接口请求\\n- 使用 `@tanstack/react-query` 进行接口请求，具体声明范式参考`/src/lib/api`，具体声明范式参考`/src/lib/api`，/src/lib/api 下区分了不同模块的接口，core 为核心封装模块，其余为业务接口封装，每个模块接口下方都可以有 api.ts（声明接口）、index.ts（useQuery、useMutation 包装接口），type.ts（声明接口参数和返回值类型），接口默认不缓存，获取最新数据\\n- 优化接口请求性能\\n\\n## 接口文档\\n\\n- 接口文档为 swagger 格式，存放在`/src/docs/`目录下\\n- 生成接口要求有完备的类型声明，简单类型直接写在`src/lib/api/**/api.ts`文件里，复杂类型写在`src/lib/api/**/type.ts`文件里导出供业务侧使用，禁止在`src/lib/api/**/api.ts`文件里写复杂类型\\n- 对于枚举值，需要在 type.ts 中使用枚举的方式来声明使用，禁止使用硬编码来做判断\\n- 严格遵照对应的接口文档声明参数\\n```\\n\\n:::\\n\\n```\\n你：对接/api/getUsers接口\\nAI：好的，我会先查看/docs下的接口文档，生成基础请求函数及其类型，再使用react-query包装，最后集成到业务中\\n```\\n\\n#### **4. 🔌 MCP 工具：AI 的\\"能力扩展接口\\"**\\n\\n**作用**：通过标准协议，让 AI 能够访问各种外部能力和服务\\n\\n**MCP vs 知识库的区别**：\\n\\n- **知识库**：静态信息，存储在本地或项目中（如项目文档、代码规范）\\n- **MCP 服务**：协议接口，提供各种能力（如查询、操作、集成等）\\n\\n**实际效果**：\\n\\n- AI 能查询外部知识库（如 Context7、文档库）\\n- AI 能直接操作你的文件\\n- AI 能运行命令\\n- AI 能搜索网络信息\\n- AI 能连接各种服务\\n\\n**🎯 具体实现：常用 MCP 服务示例**\\n\\n**RepoMix MCP**：代码库分析\\n\\n```\\nAI：帮我分析这个项目的Button组件使用情况\\nRepoMix MCP：好的，我扫描代码库，找到所有Button的使用位置和样式\\n```\\n\\n**Context7 MCP**：文档查询\\n\\n```\\nAI：帮我查询React 18的最新特性\\nContext7 MCP：好的，我搜索React官方文档，找到最新特性说明\\n```\\n\\n**文件操作 MCP**：直接操作\\n\\n```\\nAI：帮我创建一个新的Button组件\\n文件操作MCP：好的，我直接在src/components/Button.tsx创建文件\\n```\\n\\n**网络搜索 MCP**：实时信息\\n\\n```\\nAI：帮我搜索最新的Tailwind CSS最佳实践\\n网络搜索MCP：好的，我搜索网络，找到最新的最佳实践文章\\n```\\n\\n### **它们之间的关系：就像搭积木**\\n\\n- **知识库**：告诉 AI\\"是什么\\"\\n- **工作流**：告诉 AI\\"怎么做\\"\\n- **Rules**：告诉 AI\\"你喜欢什么\\"\\n- **MCP 工具**：给 AI\\"超能力\\"\\n\\n### **🎯 总结：我们可以做些什么？**\\n\\n**核心行动指南**：不是让 AI 更聪明，而是让 AI 更懂你\\n\\n**具体行动**：\\n\\n1. **建立知识库**：整理项目文档、代码规范，让 AI 了解你的项目\\n2. **定义工作流**：告诉 AI 你的开发习惯和流程\\n3. **设置 Rules**：配置 AI 的偏好，让它按你的风格工作\\n4. **集成 MCP 工具**：给 AI 扩展能力，让它能查询、操作、集成各种服务\\n\\n**预期效果**：\\n\\n- 🚀 **开发效率提升**：AI 生成的代码更符合需求\\n- 🎯 **沟通成本降低**：不需要反复解释需求\\n- 💡 **创意激发**：AI 能给出更精准的建议\\n- 🔄 **迭代加速**：快速重构和优化代码\\n\\n**记住**：最好的 AI 不是最聪明的，而是最懂你的！\\n\\n---\\n\\n## 🎯 从交付代码到交付价值：AI 时代前端开发的核心转变\\n\\n### 💡 **为什么前端开发者必须从\\"代码工人\\"转向\\"价值创造者\\"？**\\n\\n**传统前端开发的局限性：**\\n\\n在 AI 工具普及之前，前端开发者往往被定位为\\"代码工人\\"，主要职责是：\\n\\n- **📝 代码实现**：将设计稿转换为可运行的代码\\n- **🔧 功能开发**：实现产品经理提出的功能需求\\n- **🐛 Bug 修复**：解决测试过程中发现的问题\\n- **📱 兼容性处理**：确保在不同设备和浏览器上的兼容性\\n\\n**这种定位的问题：**\\n\\n1. **🚫 价值创造能力有限**：只关注代码质量，不关注业务价值\\n2. **📊 难以量化贡献**：无法证明自己的工作对业务的实际影响\\n3. **🔄 容易被替代**：AI 工具可以快速生成基础代码\\n4. **💼 职业发展瓶颈**：缺乏业务理解能力，难以晋升到更高层级\\n\\n### 🚀 **AI 时代前端开发者的新定位：价值创造者**\\n\\n#### **核心能力转变**\\n\\n**从\\"代码实现者\\"到\\"解决方案设计师\\"：**\\n\\n- **🎯 需求理解**：深入理解业务需求和用户痛点，而不仅仅是功能需求\\n- **💡 方案设计**：设计最优的技术解决方案，考虑性能、可维护性、扩展性\\n- **🔄 持续优化**：基于数据和用户反馈，持续优化产品体验\\n\\n**从\\"功能开发者\\"到\\"用户体验专家\\"：**\\n\\n- **🎨 交互设计**：优化用户交互流程，提升操作效率\\n- **📱 响应式设计**：确保在各种设备上的最佳体验\\n- **⚡ 性能优化**：提升页面加载速度和交互响应性\\n- **♿ 可访问性**：确保产品对所有用户都友好\\n\\n**从\\"代码维护者\\"到\\"系统监控专家\\"：**\\n\\n- **📊 前端监控**：建立完善的错误监控、性能监控、用户行为监控\\n- **🔍 问题诊断**：快速定位和解决线上问题\\n- **📈 数据分析**：分析用户行为数据，为产品优化提供依据\\n\\n#### **具体业务价值能力**\\n\\n<div class=\\"grid grid-cols-1 md:grid-cols-2 gap-6 my-8\\">\\n\\n::: tip 🎯 用户体验优化能力\\n**页面性能优化：**\\n\\n- 首屏加载时间优化（目标：< 2 秒）\\n- 交互响应时间优化（目标：< 100ms）\\n- 资源加载优化（图片懒加载、代码分割、缓存策略）\\n\\n**交互体验优化：**\\n\\n- 表单验证和错误提示优化\\n- 加载状态和空状态设计\\n- 微交互和动画效果\\n- 移动端手势操作优化\\n  :::\\n\\n::: info 📊 前端监控体系建设\\n**错误监控：**\\n\\n- JavaScript 运行时错误捕获\\n- 资源加载失败监控\\n- API 请求异常监控\\n- 用户操作异常监控\\n\\n**性能监控：**\\n\\n- 页面加载性能指标（FCP、LCP、CLS）\\n- 交互性能指标（FID、TTI）\\n- 资源加载性能分析\\n- 用户真实性能数据收集\\n\\n**用户行为监控：**\\n\\n- 页面访问路径分析\\n- 功能使用率统计\\n- 用户操作热力图\\n- 转化漏斗分析\\n  :::\\n\\n::: warning 🧪 前端测试体系\\n**单元测试：**\\n\\n- 组件功能测试\\n- 工具函数测试\\n- 状态管理测试\\n- 覆盖率要求（> 80%）\\n\\n**集成测试：**\\n\\n- 组件间交互测试\\n- 页面流程测试\\n- API 集成测试\\n- 端到端测试\\n\\n**性能测试：**\\n\\n- 页面加载性能测试\\n- 内存泄漏检测\\n- 长列表渲染性能测试\\n- 并发用户压力测试\\n  :::\\n\\n::: danger 🔧 工程化能力\\n**构建优化：**\\n\\n- 代码分割和懒加载\\n- Tree Shaking 和 Dead Code Elimination\\n- 资源压缩和优化\\n- 构建时间优化\\n\\n**部署优化：**\\n\\n- 自动化部署流程\\n- 灰度发布策略\\n- 回滚机制\\n- 环境配置管理\\n  :::\\n\\n</div>\\n\\n### 💰 **价值交付的量化指标和 ROI 分析**\\n\\n#### **从代码指标到业务指标**\\n\\n<div class=\\"grid grid-cols-1 md:grid-cols-2 gap-6 my-8\\">\\n\\n::: danger ❌ 传统代码指标（输入导向）\\n\\n- 代码行数、复杂度、覆盖率\\n- 性能分数、加载时间\\n- 错误率、兼容性\\n  :::\\n\\n::: tip ✅ AI 时代业务指标（输出导向）\\n\\n- **用户体验指标**：页面加载速度、交互响应时间、用户满意度\\n- **业务转化指标**：点击率、转化率、用户留存率、订单完成率\\n- **开发效率指标**：功能交付速度、迭代周期、维护成本、Bug 修复时间\\n  :::\\n\\n</div>\\n\\n#### **实际 ROI 案例分析**\\n\\n**案例 1：电商产品页面性能优化**\\n\\n```\\n优化前：\\n- 首屏加载时间：4.2秒\\n- 转化率：2.1%\\n- 用户跳出率：68%\\n\\n优化后：\\n- 首屏加载时间：1.8秒（提升 57%）\\n- 转化率：3.2%（提升 52%）\\n- 用户跳出率：45%（降低 34%）\\n\\n业务价值：\\n- 日活用户 10万，转化率提升 1.1%\\n- 日均订单增加 110单\\n- 客单价 200元，日收入增加 22,000元\\n- 月收入增加 66万元\\n```\\n\\n**案例 2：管理后台用户体验优化**\\n\\n```\\n优化前：\\n- 用户操作完成率：65%\\n- 平均操作时间：3.2分钟\\n- 客服咨询量：日均 50次\\n\\n优化后：\\n- 用户操作完成率：89%（提升 37%）\\n- 平均操作时间：1.8分钟（减少 44%）\\n- 客服咨询量：日均 18次（减少 64%）\\n\\n业务价值：\\n- 减少客服人力成本：32次/天 × 50元/次 × 22天 = 35,200元/月\\n- 提升员工工作效率：节省时间 1.4分钟/次 × 1000次/天 × 22天 = 308小时/月\\n- 按员工时薪 100元计算，月节省成本：30,800元\\n- 总月节省成本：66,000元\\n```\\n\\n**案例 3：前端监控体系建立**\\n\\n```\\n建立前：\\n- 线上问题发现时间：平均 2小时\\n- 问题解决时间：平均 4小时\\n- 用户投诉率：3.2%\\n\\n建立后：\\n- 线上问题发现时间：平均 5分钟（提升 96%）\\n- 问题解决时间：平均 1.5小时（提升 63%）\\n- 用户投诉率：1.1%（降低 66%）\\n\\n业务价值：\\n- 减少问题影响时间：1.75小时/次 × 10次/月 = 17.5小时/月\\n- 按影响用户 1000人/次，用户时薪 50元计算\\n- 月节省成本：17.5小时 × 1000人 × 50元 = 875,000元\\n```\\n\\n### 🎯 **如何建立价值交付能力体系**\\n\\n#### **1. 建立数据驱动的开发文化**\\n\\n**关键指标监控：**\\n\\n- 建立核心业务指标看板\\n- 设置性能指标告警阈值\\n- 定期分析用户行为数据\\n- 建立 A/B 测试机制\\n\\n**数据收集和分析：**\\n\\n- 前端埋点体系建设\\n- 用户行为数据收集\\n- 性能数据实时监控\\n- 错误日志智能分析\\n\\n#### **2. 建立用户体验优化流程**\\n\\n**用户研究：**\\n\\n- 用户访谈和调研\\n- 用户行为数据分析\\n- 竞品分析和对比\\n- 用户反馈收集和分析\\n\\n**优化迭代：**\\n\\n- 基于数据的优化决策\\n- 快速原型和验证\\n- 持续迭代和优化\\n- 效果评估和总结\\n\\n#### **3. 建立前端质量保障体系**\\n\\n**代码质量：**\\n\\n- 代码规范检查\\n- 自动化测试\\n- 代码审查流程\\n- 性能基准测试\\n\\n**发布质量：**\\n\\n- 自动化部署流程\\n- 灰度发布策略\\n- 监控告警机制\\n- 快速回滚能力\\n\\n---\\n\\n## 🎯 **总结**\\n\\n### 💡 **核心转变**\\n\\nAI 时代，前端开发者从\\"代码工人\\"转向\\"价值创造者\\"：\\n\\n- **交付内容**：从代码到价值\\n- **技术选型**：选择 AI 友好的主流技术栈\\n- **代码哲学**：从\\"可维护性\\"到\\"可抛弃性\\"\\n- **成功指标**：从代码质量到业务价值\\n\\n---\\n\\n**让我们一起拥抱 AI 时代，成为真正的价值创造者！** 🚀\\n","frontmatter":{},"url":"/ai/"},{"src":"---\\ntitle: 数据结构与算法\\ndesc: 数据结构与算法笔记\\nkeywords: 设计模式、笔记\\ndate: 2020-02-17 01:01:00\\ncover: https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg\\n---\\n\\n# 数据结构与算法\\n\\n## 时间空间复杂度\\n\\n算法是用来操作数据、解决问题的一组方法。主要是用事后统计法和事前分析估算衡量算法之间的优劣。\\n事后统计是通过统计、监控、利用计时器对不同算法的运行时间进行比较，从而确定算法效率的高低，但是有非常大的局限性。\\n事前分析估算是在计算机程序编写之前，依据统计方法对算法进行估算\\n比如斐波那契数列 0，1，1，2，3，5，7，13，求第 n 个斐波那契数\\n\\n```javascript\\n// 递归实现\\nfunction fun1(n) {\\n  if (n <= 1) return n;\\n  return fun1(n - 1) + fun1(n - 2);\\n}\\n// 循环实现\\nfunction fun2() {\\n  if (n <= 1) return n;\\n  let first = 0;\\n  let second = 1;\\n  for (let i = 0; i < n - 1; i++) {\\n    let sum = first + second;\\n    first = second;\\n    second = sum;\\n  }\\n  return second;\\n}\\n```\\n\\n时间复杂度即运行消耗的时间，空间复杂度即消耗的内存空间\\n我们在计算时间复杂度时，代码每运行一次，记作一个单位时间，for(let i=0;i<n;i++)循环就是 n 个单位时间，以此类推计算出某个函数或者某个循环的时间复杂度\\n**T(n)=O(f(n))**公式\\n\\n- T(n)表示代码执行的时间\\n- n 表示数据规模大小\\n- f(n)表示每行代码执行的次数总和\\n- 因为这时一个公式，所以用 f(n)表示。公式中的 O，表示代码的执行时间 T(n)与 f(n)表达式成正比，代表的是一种增长趋势\\n\\n**大数据规模时可以忽略掉“常数、低阶次、系数”都可省略，主要是找出对趋势起决定性作用的那个部分。**\\n**大 O 时间复杂度实际上并不是具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以也叫做渐进时间复杂度，简称时间复杂度 **\\nn*2 及以上阶的时间复杂度效率很低，递归的时间复杂度约为 2*n，呈指数级，因此效率很低\\n​\\n\\n时间复杂度还可分为最好情况、平均情况和最坏情况。\\n![image.png](./images/complexity.png)\\n还可以考虑概率，但实际应用中，我们一般只看最坏的情况。\\n\\n## 数组\\n\\n数组下标都是从 0 开始，内存空间的地址是连续的\\n\\n### 为什么很多语言中数组都从 0 开始编号\\n\\n### 如何实现随机访问\\n\\n数组是一种线性表数据结构，是一组连续的内存空间，存储具有相同类型的数据\\n\\n#### 关键词解析\\n\\n> 线性表。排成线的结构，每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈也是线性表结构\\n> 非线性表。二叉树、堆、图。因为这些数据类型不是简单的前后关系\\n> 连续的内存空间和相同类型的数据。数组正是因为如此，才得以有了随机访问的特性，但是对于数据的删除和插入，数组就显得有些低效，为了保证连续性需要做大量的搬移工作\\n\\n![image.png](./images/array-address.png)\\n\\n如图，一个长度为 10 的数组，计算机给数组分配了一块连续内存空间 1000-1039\\n\\n首地址 base_address=1000\\n\\n计算机会给每个内存单元分配一个地址，寻址公式`a[i]_address=base_address+i*data_type_size`\\n\\n`data_type_size`表示数组中每个元素大小，通过首地址+下标乘以元素大小取到内存地址\\n\\n**数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)**\\n\\n### 为何数组的插入和删除操作是低效的\\n\\n在中间插入元素，后面的都要移动，仅在末尾插入不需移动，平均时间复杂度为(1+2+...n)/n=O(n)\\n\\n但如果不需要保持数组的有序性，直接插入到最后一个位置就可以了\\n\\n要优化可以将多次的删除、插入操作集中在一起执行，这样元素尽量被少移动，大大减少了数据搬移的消耗\\n\\n### 容器能否代替数组\\n\\n**不能**\\n\\n比如 java 的 ArrayList、C++ STL 中的 vector\\n\\n使用容器的好处在于，将很多数组操作的细节封装了起来，比如数组插入、删除时搬移其他数据时。还有个优势是支持动态扩容。\\n\\n数组需要预先指定大小，因为需要分配连续的内存空胶囊，比如我们只申请了 10，但是要用 11 时，我们需要重新分配一块更大的空间，将原来的数据复制过去，然后将新的数据插入\\n\\n而 ArrayList 会在存储空间不够时，自动将空间扩容为 1.5 倍大小\\n\\n#### 数组的适用场景\\n\\n- java 的 ArrayList 无法存储基本类型，int、long，需要封装为 Integer、Long 类，但是自动装箱、自动拆箱有一定的性能消耗\\n- 数据大小事先已知，操作简单\\n- 定义类型的时候更加容易。多维数组的类型声明可能会需要嵌套的泛型\\n\\n### 解答：数组下标从 0 开始\\n\\n- 数组下标的确切定义是偏移（offset），如果从 1 开始计数，每次还得(k-1)\\\\*type_size，从 1 开始编号，多了一次不必要的操作，数组作为基础数据结构需要高性能，所以从 0 开始\\n- 历史原因。C 是从 0 开始，java 等等都沿用\\n\\n## 链表\\n\\n链表与数组的差别在于，数组需要连续的存储空间，这就会导致如果所需的连续空降过大，会导致内存申请失败，即便总的多余内存时足够的，这时候，链表就更合适，因为链表不需要连续的存储空间，它可以将一组零散的内存块串联起来使用\\n\\n链表常见的有三种\\n\\n- 单链表\\n- 双向链表\\n- 循环链表\\n\\n每个链表的节点除了存储数据之外，还需要记录链表上下一个节点的地址，这个地址叫做后继指针 next\\n\\n只有头节点和尾节点是特殊的，头节点记录链表的基地址，尾节点指向一个空地址 null\\n\\n链表同样支持数据的插入、删除、查找，在链表中进行插入、删除操作是非常快速的，因为不需要大量的数据搬移操作，但是数组由于不连续，没法随机访问，只能一个一个遍历节点，时间复杂度 O(n)\\n\\n### 循环链表\\n\\n循环链表是一种特殊的单链表，尾节点指针指向头节点\\n\\n### 双向链表\\n\\n每个节点有前驱后继两个指针，比单向链表需要更多的内存空间，更加好找前驱节点\\n\\n### 链表的删除\\n\\n链表的删除有两种情况\\n\\n1. 删除节点中某个值等于给定值的节点\\n2. 删除给定指针指向的节点\\n\\n第一种情况，单向链表和双向链表都需要依次遍历每个节点，O(n)\\n\\n第二种情况，明显双向链表更好用，因为删除某个节点需要知道前驱节点，单链表又得遍历查找一遍\\n\\n另外还有对于一个有序链表按值查找，我们可以按值决定往前还是往后查找，每次查找只需要查找一半的数据\\n\\n实际使用中，双向链表也是更加广泛的，当内存空间充足的时候，追求代码的执行速度，双向链表是更好的，这也是空间换时间的思路。但如果内存吃紧，那就得采取时间换空间的思路\\n\\n双向链表和循环链表还可以组合成双向循环链表\\n\\n### 链表 VS 数组\\n\\n数组简单易用，连续内存空间可以借助 CPU 的缓存机制，预读数组中的数据，而链表不是连续存储，CPU 缓存不友好\\n\\n数组的缺点大小固定，连续的存储空间不够会导致内存不足，即便是内存足够，数组的扩容是需要把原数组拷贝一份的，**这个操作相当费时**，而链表本身没有大小限制，天然支持动态扩容，这是它与数组最大的区别\\n\\n当然链表也比数组更加耗费内存，先不说前驱后继指针导致的内存空间翻倍，频繁的插入和删除操作，会导致内存的频繁申请和释放，容易造成内存碎片，高级语言会导致频繁的垃圾回收，所以对于数组和链表的使用，需要自己权衡场景\\n\\n### LRU 缓存淘汰算法\\n\\n思路：维护一个有序单链表，越靠近尾部的节点是越早之前访问的，当有一个新的数据被访问时，我们从链表头开始顺序遍历链表\\n\\n1. 如果此数据已在链表中，我们遍历得到它后，删除，插入到头部\\n2. 如果没在链表中，如果缓存未满，插入头部，如果缓存已满，删除尾节点，将新数据插入头部\\n\\n此时总是需要遍历的，时间复杂度 O(n)\\n\\n优化可以用散列表，可以降到 O(1)\\n\\n### 注意事项\\n\\n1. 理解指针或者引用的含义。C 语言有指针，Java 没有，叫做引用，其实都是一样的意思，存储的是所指内存对象的内存地址。变量赋值给指针，其实是把变量的地址赋值给指针，指针或者引用指向这个变量，通过指针可以找到这个变量\\n2. 警惕指针丢失和内存泄露。不需要的引用要及时断掉，引用也不要指错对象\\n3. 使用哨兵简化实现难度。不管链表是不是空，head 指针一直指向哨兵节点，有哨兵节点的链表叫做**带头链表**。其实就是加了一个头节点，返回时候返回头节点的 next 就可以\\n4. 留意边界条件处理。链表为空？链表只有一个节点？链表只包含两个节点？代码逻辑能否处理头节点和尾节点？\\n5. 画图举例。光想容易不清晰，画出来更容易\\n6. 多练习，没有捷径\\n\\n## 栈\\n\\n栈是一种操作受限的线性表，只允许一端插入和删除数据。从功能上来说，数组和链表都可以代替栈，但是操作的接口太多了。对于某些场景，需要这种约束事情才会变得更加可控\\n\\n使用数组实现叫做顺序栈，使用链表叫做链式栈。入栈和出栈的空间复杂度是 O(1)，时间复杂度也是 O(1)\\n\\n出栈不涉及内存的重新申请和数据搬移，但是入栈的时候，如果空间不够，就需要重新申请内存和数据搬移，时间复杂度为 O(n)\\n\\n### 栈在函数调用中的应用\\n\\n操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成栈这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，函数执行完就弹栈\\n\\n![image.png](./images/function-stack.png)\\n\\n### 栈在表达式求值中的应用\\n\\n求 `34+13\\\\*9+44-12/3` 的值\\n\\n编译器会通过两个栈，从左到右遍历表达式，遇到数字就压入操作数栈，遇到运算符，就与运算符栈的栈顶元素进行比较，优先级高的压入栈，优先级低或者相同的，从栈顶取出操作符和两个操作数进行计算，以此类推\\n\\n### 栈在括号匹配中的应用\\n\\n如何检查表达式中括号使用的合法性？\\n\\n可以用栈保存未匹配的左括号，从左到右依次扫描字符串，左括号压入栈中，遇到右括号，从栈顶取出一个左括号，如果匹配，则扫描剩下的字符串，如果右括号不能配对，或者栈中没有数据，说明格式非法\\n\\n## 队列\\n\\n先进先出，入队出队，不允许其他操作，也是一种操作受限的线性表结构\\n\\n有循环队列、阻塞队列、并发队列\\n\\n实现队列可以用数组也可以用栈，分别叫顺序队列、链式队列\\n\\n底层语言的数组在实现队列时，会导致头、尾下标的持续变化，所以需要在入队时，没有空间的情况下集中进行一次数据搬移的操作，另外，用循环队列可以更好地解决这个问题，循环的入队就可以了\\n\\n### 阻塞队列和并发队列\\n\\n#### 阻塞队列\\n\\n队列为空，从队列头取数据会被阻塞，因为没有数据可取，队列已满，插入数据会被阻塞。\\n\\n这就是生产者——消费者模型的定义\\n\\n#### 并发队列\\n\\n线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。在实战篇讲 Disruptor 的时候，我会再详细讲并发队列的应用。\\n\\n### 线程池没有空闲线程时，新的任务请求如何处理？\\n\\n1. 非阻塞，直接拒绝任务请求\\n2. 阻塞，请求排队，等到有空闲线程时取出排队的请求继续处理\\n\\n### 基于链表和数组的队列对于排队请求有什么区别？\\n\\n链表支持无限排队的无界队列，可能会导致过多请求排队等待，等待时间长\\n\\n数组队列大小有限，当线程池中排队的请求超过队列大小时，接下来的请求会被拒绝，对空间响应时间敏感的系统来说，更加合理\\n\\n对于大部分资源有限的场景，当没有空闲资源时，基本都可以通过队列的数据结构来实现请求排队\\n\\n## 递归\\n\\n递归需要满足三个条件\\n\\n1. 一个问题的解可以分解为几个子问题的解。比如电影院找座位，想知道自己的座位可以分解为前一排的人在哪一排的子问题\\n2. 这个问题与分解之后的子问题，除了数据规模不同，求解的思路完全一样\\n3. 存在递归终止条件\\n\\n需要会写递归公式\\n\\n> 写递归要注意避免堆栈溢出，可以通过限制递归调用的最大深度，超过该深度直接报错。但这种办法没有完全解决问题，仅在最大深度比较小的时候使用，比如 10、50。\\n\\n> 还要警惕重复计算，可以使用散列表来保存已经求解过 f(k)，当递归调用到时，先看下是否已经求解过了，是的话直接从三列表中取值返回，不需要重复计算\\n\\n递归的空间复杂度是 O(n)，因为每调用一次函数都会在内存栈中保存一次数据\\n\\n递归有利有弊。它的表达力很强，写起来很简洁，弊端在于空间复杂度高，有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题，实际开发中，要根据实际情况来选择是否用递归的形式来实现\\n\\n可以将递归改为迭代循环的非递归写法，但其实本质没有变，对于某些问题？还是无法避免\\n\\n递归中还可能出现存在环形链表的问题，可以用快慢指针检测出环形链表的存在\\n\\n## 排序\\n\\n### 为什么插入排序比冒泡排序更受欢迎\\n\\n排序算法的执行效率分析\\n\\n1. 最好、最坏情况、平均情况时间复杂度\\n2. 时间复杂度的系数、常数、低阶。虽然一般情况下都可忽略，但是由于我们平时处理的数据可能规模不大，这个时候需要把这些考虑进去\\n3. 比较次数和交换次数。基于比较的排序算法的执行过程，涉及元素大小的比较、元素的交换或移动，应该把比较次数和交换次数也考虑进去\\n\\n### 排序算法的内存消耗\\n\\n算法有空间复杂度，空间复杂度为 O(1)的排序算法叫做原地排序\\n\\n### 排序算法的稳定性\\n\\n待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变，叫做**稳定的排序算法**，否则叫做**不稳定的排序算法**\\n\\n### 冒泡排序\\n\\n每次对相邻的两个元素进行比较交换。可以优化当某次冒泡没有数据交换时，不再执行后续的冒泡操作\\n\\n#### 分析\\n\\n1. 冒泡排序是原地排序算法\\n2. 是稳定的排序算法\\n3. 最好情况时间复杂度 O(n)，最坏情况，当排序数据都是倒序排列的，需要 n 次冒泡操作，最坏情况时间复杂度 O(n^2)\\n\\n对于包含 n 个数据的数据，排列方式不同，冒泡排序的执行时间也是不同的，可以用有序度、逆序度来分析\\n\\n2，4，3，1，5，6 的有序元素有 11 对，如(2,4),(2,5)，有序度 11，完全有序的数组，有序度是 n\\\\*(n-1)/2，叫做满有序度\\n\\n逆序度以此类推，逆序度=满有序度-有序度\\n\\n### 插入排序\\n\\n将数据分为两个区间，已排序区间和未排序区间，核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入\\n\\n不同的查插入点方法，元素的比较次数是有区别的，但对于一个给定的初始序列，移动操作的次数总是固定的，等于逆序度\\n\\n#### 分析\\n\\n1. 插入排序是一个原地排序算法，因为不需要额外的存储空间，空间复杂度是 O(1)\\n2. 插入排序中，对于值相同的元素，可以选择将后面出现的元素插入到前面出现的元素的后面，所以是稳定的排序算法\\n3. 如果原本已经有序，复杂度为 O(n)，如果是倒叙，最坏情况时间复杂度是 O(n^2)，平均时间复杂度为 O(n^2)\\n\\n### 选择排序\\n\\n从未排序的区间中找最小的元素，与已排序的元素的末尾+1 的元素进行交换\\n\\n基本跟插入排序类似\\n\\n#### 分析\\n\\n1. 是原地排序算法\\n2. 不稳定。因为每次都要交换元素位置\\n\\n冒泡和插入排序在时间复杂度上是一样的，但冒泡排序涉及了 K 次交换操作，每次三个赋值语句，总耗时 3\\\\*K，插入排序数据移动操作只需要 K 个单位时间，性能上插入排序是更好的\\n\\n### 归并排序\\n\\n排序一个数组，先把数组从中间分成前后两部分，再对前后两部分分别排序，递归的形式，最终整个数组就排好序了\\n\\n是**分治思想**的体现\\n\\n#### 分析\\n\\n1. 是稳定的排序算法。合并过程中可以保证值相同的元素，合并前后的顺序不变\\n2. 时间复杂度 O(nlogn)，归并算法的执行效率与要排序的原始数组的有序程度无关，时间复杂度很稳定，都是 O(nlogn)\\n\\n```\\nT(n) = 2*T(n/2) + n\\n     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n\\n     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n\\n     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n\\n     ......\\n     = 2^k * T(n/2^k) + k * n\\n     ......\\n```\\n\\n3. 不是原地排序算法，空间复杂度 O(n)\\n\\n### 快速排序\\n\\n也是利用分治思想。选择一组数据中任意一个数据作为哨兵 pivot，遍历数据，将大于 pivot 的放到右边，小于 pivot 的放到左边，pivot 在中间，我们得到三部分的数据\\n\\n我们可以递归哨兵左右的数据，直至区间缩小为 1，这样数据就有序了\\n\\n```\\n递推公式：\\nquick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)\\n\\n终止条件：\\np >= r\\n```\\n\\n![image.png](./images/merge-quick.png)\\n\\n快速排序与归并排序的差别在于归并的处理过程由下到上，先处理子问题再合并，快排相反，从上到下，先分区，再处理子问题，归并虽然稳定、时间复杂度为 O(nlogn)，但是是非原地算法。而快速排序通过巧妙的原地分区函数，实现原地排序，解决了归并排序**占用太多内存**的问题\\n\\n#### 分析\\n\\n1. 快速排序是一种原地、不稳定的排序算法。如果每次分区都能整好把数组分成大小接近相等的两个小区间，那么快排的时间复杂度递推求解公式跟归并是相同的，时间复杂度 O(nlogn)，但如果不是，比如每次分区都是不均等的，最坏情况时间复杂度就为 O(n^2)\\n\\n```\\nT(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。\\n\\nT(n) = T(n/10) + T(9*n/10) + n； n>1\\n```\\n\\n用快速排序可以以 O(n)的时间复杂度找到数组中第 K 大的元素，因为每次都会选中一个哨兵 pivot，利用好这个哨兵的下标位置，就能很容易找到第 K 大的元素\\n\\n### 桶排序\\n\\n线型排序算法\\n\\n核心思想是将要排序的数据分到几个有序的桶里，每个桶里再单独进行排序，各自排序完后再取出组合，组成的序列就是有序的了\\n\\n桶排序的时间复杂度 O(n)。如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k _ logk)。m 个桶排序的时间复杂度就是 O(m _ k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。\\n\\n看起来很不错，但是桶排序对于数据的要求实际上是非常苛刻的\\n\\n1. 首先，数据要很容易划分成桶，并且桶与桶之间有着天然的大小顺序。这样每个桶排完序才能直接合并\\n2. 数据在各个桶内的分布如果是均匀的，很好，但如果不均匀，极端情况下都分到一个桶里，那就变成 O(nlogn)\\n\\n桶排序适合用在外部排序中\\n\\n> 外部排序。数据都存储在外部磁盘中，很大，但是我们的内存有限，无法全部加载到内存中\\n\\n比如 10G 的订单数据，但是我们只有 100mb 内存，需要加载进来按订单金额排序\\n\\n我们可以获取订单金额的范围，比如是 1 元-10 万元，将其划分到 10 个桶里，第一个桶是 1-10000，第二个 10000-20000...如果理想的话，数据分布均匀，每个桶里就会有 10mb 左右的数据，逐个用快排排序，最后合并起来就是一份从小到大的订单数据\\n\\n但是数据不可能那么均匀，我们可以针对数据量大的区间接着划分小区间，直到能读取到合适的数据量为止\\n\\n### 计数排序\\n\\n是桶排序的一种特殊情况，往桶里塞入相同的数据，这样就不需要桶内排序，直接合并就完事了，只涉及遍历扫描，时间复杂度 O(n)\\n\\n计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合。而且，技术排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数（其实 js 用键值对就不存在这个问题）\\n\\n### 基数排序\\n\\n比如给手机号排序，可以从最后一位开始排序，时间复杂度 O(n)\\n\\n如果是给英文单词排序，长度不一，但是可以通过补 0 来解决，因为 ASCII 码，所有字母都大于 0，补 0 不会影响原有得大小顺序。\\n\\n技术排序对数据有要求，需要可以分割出独立的位来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序\\n\\n### 排序优化\\n\\n![表格](./images/sort-table.png)\\n\\n线性排序算法时间复杂度较低，适用场景特殊，通用的排序函数不能选择线型排序算法\\n\\n快速排序较为适合，但是快速排序的最坏情况时间复杂度是 O(n^2)，主要还是因为分区点选的不够合理，最理想的分区点是被分开的两个分区中，数据的数量差不多\\n\\n有两个比较常用、简单的分区法\\n\\n1. 三数取中法。从区间的首尾中分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点，但是如果排序的数组比较大，那可能就要五数取中或者十数取中\\n2. 随机法。随机选择一个元素作为分区点\\n\\n在实际使用中，排序并不一定仅限于单一场景，通过针对不同情况灵活运用才能让执行效率更高。比如 qsort 函数\\n\\nqsort 会优先使用归并排序，因为数据量小的时候，归并排序更快，空间换时间，但是数据量大的时候，会改用快速排序（三数取中法）。当元素个数小于等于 4 时，qsort 使用插入排序\\n\\n## 查找算法\\n\\n### 二分查找\\n\\n复杂度 O(logn)，效率极高，但是有局限性\\n\\n1. 二分查找依赖顺序表结构数组，其他的数据结构不适用\\n2. 数组必须有序。二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中，针对动态变化的数据集合，二分查找将不再适用\\n3. 如果数据量很小，没有必要用二分查找，顺序遍历即可。但是如果数据项都是长度超过 300 的字符串就要使用二分，因为 300 长度字符串的大小对比很耗时\\n4. 数据量太大也不适合二分。因为二分查找要求数组，而数组是内存空间连续的数据结构，如果数据量太大，对内存空间的要求太苛刻。（JS 的数组由于是对象模拟出来的，不必在意这个）\\n\\n#### 二分查找的变形问题\\n\\n```js\\nconst x = [1, 2, 3, 46, 46, 46, 90];\\nconst bSearch = (array, n, value) => {\\n  let low = 0;\\n  let high = n - 1;\\n  while (low <= high) {\\n    let mid = low + ((high - low) >> 1);\\n    if (array[mid] >= value) {\\n      high = mid - 1;\\n    } else {\\n      low = mid + 1;\\n    }\\n  }\\n  if (low < n && array[low] === value) return low;\\n  else return -1;\\n};\\n```\\n\\n#### 查找第一个值等于给定值的元素\\n\\n分两种情况，算上右侧边界，需要定 right=nums.length-1，否则不用减 1\\n\\n```javascript\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar search = function (nums, target) {\\n  let left = 0;\\n  let right = nums.length - 1;\\n  while (left <= right) {\\n    let middle = left + (right - left) / 2;\\n    if (nums[middle] < target) {\\n      left = middle + 1;\\n    } else if (nums[middle] > target) {\\n      right = middle - 1;\\n    } else {\\n      return middle;\\n    }\\n  }\\n  return -1;\\n};\\n```\\n\\n## 移除元素\\n\\n这种题目的关键在于，数组元素在内存中的地址是连续的，不能单独删除某个元素，，只能覆盖\\n可以采用双层 for 循环，一层遍历数组元素，一层在发现需要移除元素后，将数组集体向前移动一位，但是时间复杂度为 O(n^2)，因此不推荐\\n使用双指针法，只需要一层 for 循环，遇到目标元素时，会区分出快慢指针，从而移动元素位置，时间复杂度为 O(n)\\n\\n```javascript\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function (nums, val) {\\n  let slowIndex = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] !== val) {\\n      nums[slowIndex++] = nums[i];\\n    }\\n  }\\n  return slowIndex;\\n};\\n```\\n\\n## 滑动窗口\\n\\n像一个窗口一样，每当和大于目标值时，就移动左右窗口，这道题有个坑，就是每当和大于目标值时，计算子串长度不需要加 1，因为在这一步里必然会减去左侧的一个值，必然需要减去 1\\n\\n```javascript\\n/**\\n * @param {number} target\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minSubArrayLen = function (target, nums) {\\n  let subLength = 0;\\n  let left = 0,\\n    right = 0;\\n  let sum = 0;\\n  // 给一个不可能的值，没有改变就说明不存在目标子串\\n  let result = nums.length + 1;\\n  for (let i = 0; i < nums.length; i++) {\\n    sum += nums[right++];\\n    while (sum >= target) {\\n      subLength = right - left;\\n      result = result < subLength ? result : subLength;\\n      sum -= nums[left++];\\n    }\\n  }\\n  // 可能存在全部相加也不大于等于目标值的情况\\n  return result <= nums.length ? result : 0;\\n};\\n```\\n\\n## 有序数组的平方排序\\n\\n这类题可以用双指针法，直接将时间复杂度降到了 O(n)\\n\\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortedSquares = function (nums) {\\n  let k = nums.length - 1;\\n  let i = 0,\\n    j = nums.length - 1;\\n  let result = [];\\n  while (i <= j) {\\n    if (nums[i] * nums[i] < nums[j] * nums[j]) {\\n      result[k--] = nums[j] * nums[j];\\n      j--;\\n    } else {\\n      result[k--] = nums[i] * nums[i];\\n      i++;\\n    }\\n  }\\n  return result;\\n};\\n```\\n","frontmatter":{"title":"数据结构与算法","desc":"数据结构与算法笔记","keywords":"设计模式、笔记","date":"2020-02-17T01:01:00.000Z","cover":"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg"},"url":"/computer-basic/arithmetic/"},{"src":"---\\ntitle: 设计模式\\ndesc: 《JavaScript设计模式》、《大话设计模式》笔记\\nkeywords: 设计模式、笔记\\ndate: 2020-02-17 01:01:00\\ncover: https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg\\n---\\n\\n# 设计模式\\n\\n## 设计模式的利与弊\\n\\njs 的设计模式有工厂模式、桥接模式、组合模式、门面模式、适配器模式装饰者模式、享元模式、代理模式、观察者模式、命令模式、职责链模式\\n\\n### 利\\n\\n- 可维护性。降低模块耦合程度，利于重构、合作和维护\\n- 沟通。对程序员来说，是一套通用的术语\\n- 性能。某些起优化作用的设计模式。可以大幅度提高程序的运行速度，减少需要传送到客户端的代码量。如享元模式和代理模式\\n\\n### 弊\\n\\n- 复杂性。这是获得可维护性付出的代价，带啊吗会变得更复杂\\n- 性能。某些模式能提升性能，但多数模式对性能有所拖累，尽管可能是微不足道的，取决于项目的具体需求\\n\\n### 不要盲目使用设计模式\\n\\n要保证所选用的模式是最恰当的那一种，不要过度牺牲性能\\n\\n## 设计模式的原则\\n\\n### 单一职责原则\\n\\n::: warning\\nSRP，就一个类而言，应该仅有一个引起它变化的原因，\\n如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力，这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏\\n:::\\n\\n所以我们在写代码过程中需要有意识地去分离代码，比如样式和逻辑分离\\n\\n### 开放-封闭原则\\n\\n软件实体应该可以扩展，但是不可以修改\\n\\n无论模块是多么的封闭，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最可能发生的变化种类，然后构造抽象来隔离那些变化\\n\\n面对需求，对程序的改动是通过增加信贷吗进行的，而不是更改现有的代码\\n\\n### 依赖倒转原则\\n\\nA. 高层模块不应该依赖低层模块。两个都应该依赖抽象\\nB. 抽象不应该依赖细节。细节应该依赖抽象\\n\\n比如电脑的主板坏了，如果导致 cpu、内存都坏了，就不合理。同样的，cpu 坏了，导致内存、主板坏了也不合理\\n\\n### 里氏代换原则\\n\\n一个软件实体如果使用的是一个父类的话，那么一定适用其子类，而且它察觉不出父类和子类对象的区别。就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化简单说，子类型必须能够替换掉他们的父类型。\\n\\n正是由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展\\n\\n## 常用的设计模式\\n\\n### 接口\\n\\n接口规定某个对象必须有哪些方法，但不规定方法的具体实现\\n利\\n\\n- 自我描述性\\n\\n弊：\\n\\n- js 没有内置接口，这在一定程度上降低了语言的灵活性\\n\\n### 闭包\\n\\n其实就是为了解决曾经 js 没有 let 和 const 时的问题。js 只有函数具有作用域，在函数外部用 var 声明的都是全局变量\\n​\\n\\n有个弊端就是直接在 prototype 原型上声明函数，函数会被原型链重复利用，内存中只有一份。但是如果使用闭包的方式需要每次生成新的函数的副本，会耗费更多的内存\\n并且这种创建模式不利于派生子类，因为派生出的子类不能访问超类的所有私有属性和方法，这被称为继承破坏封装\\n\\n```javascript\\nconst Book = function (newName) {\\n  var name;\\n  this.getName = function () {\\n    return name;\\n  };\\n  this.setName = function (_name) {\\n    name = _name;\\n  };\\n  this.setName(newName);\\n};\\n\\nBook.prototype = {\\n  getProtoName() {\\n    console.log(this);\\n    return this.name;\\n  },\\n};\\nconst book = new Book(\'xxxx\');\\nconsole.log(book.getName());\\n```\\n\\n不需要访问私有属性的方法直接在 prototype 中声明，需要访问私有属性的特权方法才需要挂在 this 上。\\n一般使用直接返回函数就可以了\\n\\n### 继承\\n\\n```javascript\\n// 有这么一个Person类\\nfunction Person(name) {\\n  this.name = name;\\n}\\n\\nPerson.prototype.getName = function () {\\n  return this.name;\\n};\\n```\\n\\n#### 类式继承\\n\\n```javascript\\n// 使用的时候通过new\\nlet reader = new Person(\'xxx\');\\n// reader就可以使用Person的getName方法\\nreader.getName();\\n```\\n\\n#### 原型链继承\\n\\n```javascript\\nfunction Author(name, books) {\\n  Person.call(this, name);\\n  this.books = books;\\n}\\n\\n// 原型挂成Person，但是构造器方法要用自己的\\nAuthor.prototype = new Person();\\nAuthor.prototype.constructor = Author;\\nAuthor.prototype.getBooks = function () {\\n  return this.books;\\n};\\n```\\n\\n### 策略模式\\n\\n定义了算法家族，分别分装起来，让他们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户\\n\\n```ts\\nabstract class Strategy {\\n  abstract AlogorithmInterface(): void;\\n}\\n\\nclass ConcreteStrategyA extends Strategy {\\n  AlogorithmInterface() {\\n    consol.log(\'A算法\');\\n  }\\n}\\n\\nclass ConcreteStrategyB extends Strategy {\\n  AlogorithmInterface() {\\n    console.log(\'B算法\');\\n  }\\n}\\n\\nclass Context {\\n  constructor(strategy) {\\n    this.strategy = strategy;\\n  }\\n  ContextInterface() {\\n    this.strategy.AlogorithmInterface();\\n  }\\n}\\n\\n// 使用\\nconst context = new Context(new ConcreteStrategyA());\\ncontext.ContextInterface();\\n```\\n\\n其实就是封装多个不同功能的函数，用条件语句去匹配对应的策略，为了避免客户端需要写条件，可以结合简单工厂，将条件匹配放到工厂内\\n\\n### 观察者模式\\n\\n又名发布订阅模式\\n最常见的观察者模式的用途是 dom 的事件监听\\n\\n```javascript\\n//使用事件监听器addEventListener\\nlet el = document.querySlector(\'#id\');\\nlet fn1 = function (e) {\\n  //handle click\\n};\\nlet fn2 = function (e) {\\n  //handle click\\n};\\nel.addEventListener(\'click\', fn1);\\nel.addEventListener(\'click\', fn2);\\n//使用事件处理器\\nlet el = document.querySlector(\'#id\');\\nlet fn1 = function (e) {\\n  //handle click\\n};\\nlet fn2 = function (e) {\\n  //handle click\\n};\\nel.onClick = fn1;\\nel.onClick = fn2;\\n```\\n\\n#### 常见实现\\n\\n有很多实现方式，可以根据业务场景做变换，可以是由发布者来决定订阅者的订阅与否，也可以是订阅者自己决定订阅与否，还可以是订阅者直接从发布者那里主动拉取数据，并且网络上很多言论已经将观察者模式和发布订阅分开来，观察者模式加上一个事件调度中心即是发布订阅模式。以下是观察者模式常见实现\\n\\n```javascript\\nclass Publisher {\\n  constructor() {\\n    this.subscribers = [];\\n  }\\n  addSubscriber(subscriber) {\\n    this.observers.push(observer);\\n  }\\n\\n  removeSubscriber(subscriber) {\\n    let index = this.subscribers.indexOf(subscriber);\\n    if (index > -1) {\\n      this.subscribers.splice(index, 1);\\n    }\\n  }\\n\\n  notify() {\\n    this.subscribers.forEach(subscriber => {\\n      subscriber.update();\\n    });\\n  }\\n}\\n\\nclass Subscriber {\\n  update() {}\\n\\n  subscribeTo(publisher) {\\n    publisher.addSubscriber(this);\\n  }\\n}\\n\\nlet publisher = new Publisher();\\nlet subscriber1 = new Subscriber();\\nlet subscriber2 = new Subscriber();\\nlet subscriber3 = new Subscriber();\\nsubscriber1.update = function () {\\n  console.log(\'1 update\');\\n};\\nsubscriber2.update = function () {\\n  console.log(\'2 update\');\\n};\\nsubscriber3.update = function () {\\n  console.log(\'3 update\');\\n};\\n\\n//测试\\nsubscriber1.subscribeTo(publisher);\\nsubscriber2.subscribeTo(publisher);\\nsubscriber3.subscribeTo(publisher);\\n```\\n\\n发布/订阅模式实现，观察者模式是一对多，发布订阅模式是一对一对多（发布者不与观察者直接接触)\\n\\n```javascript\\n//订阅者\\nclass Subscriber {\\n  update() {}\\n  //update(event){}\\n  subscribeTo(channel) {\\n    channel.addSubscriber(this);\\n  }\\n}\\n//中间通道\\nclass Channel {\\n  constructor() {\\n    this.subscribers = [];\\n  }\\n\\n  addSubscriber(subscriber) {\\n    this.subscribers.push(subscriber);\\n  }\\n\\n  removeSubscriber(subscriber) {\\n    let index = this.observers.indexOf(subscriber);\\n    if (index > -1) {\\n      this.subscribers.splice(index, 1);\\n    }\\n  }\\n  publish() {\\n    //publish(event){\\n    this.subscribers.forEach(subscriber => {\\n      subscriber.update();\\n      //subscriber.update(event)\\n    });\\n  }\\n}\\n//发布者\\nclass Publisher {\\n  notify(channel) {\\n    channel.publish();\\n    //channel.publish(event)\\n  }\\n}\\n\\n//测试，new一个中间通道对象、发布者对象和三个订阅者对象\\nlet channel = new Channel();\\nlet publisher = new Publisher();\\n\\nlet subscriber1 = new Subscriber();\\nlet subscriber2 = new Subscriber();\\nlet subscriber3 = new Subscriber();\\n\\nsubscriber1.update = function () {\\n  console.log(\'1 update\');\\n};\\nsubscriber2.update = function () {\\n  console.log(\'2 update\');\\n};\\nsubscriber3.update = function () {\\n  console.log(\'3 update\');\\n};\\n//订阅者向中间通道订阅\\nsubscriber1.subscribeTo(channel);\\nsubscriber2.subscribeTo(channel);\\nsubscriber3.subscribeTo(channel);\\n\\n//发布者只向中间通道发布事件\\npublisher.notify(channel);\\n```\\n\\n##### 利\\n\\n比如注册一个事件监听器。借助一个事件监听器去处理各种行为，将信息由一个订阅中心发布，就不需要反复的同样的元素添加各自的事件监听器。利于减少系统开销并提高程序的可维护性\\n\\n##### 弊\\n\\n创建被观察对象带来的加载时间开销可能会较大。可以通过懒加载，把新的被观察对象的实例化推迟到需要发送事件通知的时候。\\n\\n### 建造者模式\\n\\n讲一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示\\n\\n```ts\\n// 画一个小人，需要有头、身体、手脚\\nabstract class PersonBuilder {\\n  constructor(graph, pen) {\\n    this.graph = graph;\\n    this.pen = pen;\\n  }\\n  abstract buildHead(): void;\\n  abstract buildBody(): void;\\n  abstract buildArmLeft(): void;\\n  abstract buildArmRight(): void;\\n  abstract buildLegLeft(): void;\\n  abstract buildLegRight(): void;\\n}\\n\\n// 瘦人类\\nclass PersonThinBuilder extends PersonBuilder {\\n  constructor(graph, pen) {\\n    super(graph, pen);\\n  }\\n  buildHead() {}\\n  buildBody() {}\\n  buildArmLeft() {}\\n  buildArmRight() {}\\n  buildLegLeft() {}\\n  buildLegRight() {}\\n}\\n\\n// 指挥者\\nclass PersonDirector {\\n  constructor(pb) {\\n    // 用户需要告诉指挥者要什么样的小人\\n    this.pb = pb;\\n  }\\n  CreatePerson() {\\n    pb.buildHead();\\n    pb.buildBody();\\n    pd.buildArmLeft();\\n    pd.buildArmRight();\\n    pd.buildLegLeft();\\n    pd.buildLegRight();\\n  }\\n}\\n```\\n\\n### 工厂模式\\n\\n#### 简单工厂（静态工厂）\\n\\n以自行车商店为例,商店把生产自行车的工作交给一个外部对象\\n\\n```javascript\\n//User类\\nclass User {\\n  //构造器\\n  constructor(opt) {\\n    this.name = opt.name;\\n    this.viewPage = opt.viewPage;\\n  }\\n\\n  //静态方法\\n  static getInstance(role) {\\n    switch (role) {\\n      case \'superAdmin\':\\n        return new User({\\n          name: \'超级管理员\',\\n          viewPage: [\'首页\', \'通讯录\', \'发现页\', \'应用数据\', \'权限管理\'],\\n        });\\n        break;\\n      case \'admin\':\\n        return new User({\\n          name: \'管理员\',\\n          viewPage: [\'首页\', \'通讯录\', \'发现页\', \'应用数据\'],\\n        });\\n        break;\\n      case \'user\':\\n        return new User({\\n          name: \'普通用户\',\\n          viewPage: [\'首页\', \'通讯录\', \'发现页\'],\\n        });\\n        break;\\n      default:\\n        throw new Error(\'参数错误, 可选参数:superAdmin、admin、user\');\\n    }\\n  }\\n}\\n\\nlet superAdmin = User.getInstance(\'superAdmin\');\\nlet admin = User.getInstance(\'admin\');\\nlet normalUser = User.getInstance(\'user\');\\n```\\n\\n##### 利\\n\\n对于构建逻辑简单、相同且都是同种类的对象工厂是合适的\\n\\n##### 弊\\n\\n需要添加新的对象种类时，得去修改源代码。只适用于创建对象数量少、创建逻辑不复杂时使用\\n\\n#### 工厂模式\\n\\n与简单工厂相比，不是用另一个类来生产对象，而是用一个子类，核心类成了抽象类。\\n这样添加新的类时就无需修改基础的工厂方法，只需要将子类注册进工厂方法。\\n\\n```javascript\\nclass FunctionFactoryBase {\\n  // 抽象类\\n  constructor(role) {\\n    if (new.target === FunctionFactoryBase) {\\n      throw new Error(\'抽象类不能实例\');\\n    }\\n    this.role = role;\\n  }\\n}\\n\\nclass FunctionFactory1 extends FunctionFactoryBase {\\n  // 子类\\n  constructor(role) {\\n    super(role);\\n  }\\n\\n  static create(role) {\\n    switch (role) {\\n      case \'admin\':\\n        return new FunctionFactory1({\\n          role: \'管理员\',\\n          permissions: [\\n            \'设置\',\\n            \'删除\',\\n            \'新增\',\\n            \'创建\',\\n            \'开发\',\\n            \'推送\',\\n            \'提问\',\\n            \'评论\',\\n          ],\\n        });\\n        break;\\n      case \'developer\':\\n        return new FunctionFactory1({\\n          role: \'开发者\',\\n          permissions: [\'开发\', \'推送\', \'提问\', \'评论\'],\\n        });\\n        break;\\n      default:\\n        throw new Error(\'参数只能为 admin 或 developer\');\\n    }\\n  }\\n\\n  show() {\\n    const { role, permissions } = this.role;\\n    const str = `是一个${role}, 权限：${permissions.join(\', \')}`;\\n    console.log(str);\\n  }\\n}\\n\\nclass FunctionFactory2 extends FunctionFactoryBase {\\n  // 子类\\n  constructor(role) {\\n    super(role);\\n  }\\n\\n  static create(role) {\\n    switch (role) {\\n      case \'user\':\\n        return new FunctionFactory2({\\n          role: \'用户\',\\n          permissions: [\'提问\', \'评论\'],\\n        });\\n        break;\\n      default:\\n        throw new Error(\'参数只能为 user\');\\n    }\\n  }\\n\\n  show() {\\n    const { role, permissions } = this.role;\\n    const str = `是一个${role}, 权限：${permissions.join(\', \')}`;\\n    console.log(str);\\n  }\\n}\\n// let xl = new FunctionFactoryBase();\\n// 此行会报错，注释后方可正常执行后面\\n\\nlet xm = FunctionFactory1.create(\'admin\');\\nxm.show();\\n\\nlet xh = FunctionFactory1.create(\'developer\');\\nxh.show();\\n\\nlet user1 = FunctionFactory2.create(\'user\');\\nuser1.show();\\n```\\n\\n这样一来，添加新类无需修改抽象类工厂内源代码，只需要创建一个新的子类（工厂）\\n基础工厂里定义的是各子工厂抽象方法，子工厂可具体定义各自的行为\\n\\n缺点在于随着工厂种类越来越多，类会越来越多，增加系统复杂度\\n\\n#### 抽象工厂模式\\n\\n工厂模式针对一个产品等级结构、而抽象工厂针对多个产品等级结构\\n比如，华为手机，可以有 mate、p30 等等子类\\n但是华为不只做手机，还有电脑、电视，电脑、电视、手机位于不同的产品登记结构，但是他们是由一个工厂生产的，称为产品族\\n\\n```javascript\\n//这里汽车厂商作为一个产品族，既可以生产车，也可以生产发动机\\nclass AutomakerFactory {\\n  createCar() {\\n    throw new Error(\'不能调用抽象方法，请自己实现\');\\n  }\\n\\n  createEngine() {\\n    throw new Error(\'不能调用抽象方法，请自己实现\');\\n  }\\n}\\nclass BenzFactory extends AutomakerFactory {\\n  createCar() {\\n    return new BenzCar();\\n  }\\n\\n  createEngine() {\\n    return new BenzEngine();\\n  }\\n}\\n\\nclass AudiFactory extends AutomakerFactory {\\n  createCar() {\\n    return new AudiCar();\\n  }\\n\\n  createEngine() {\\n    return new AudiEngine();\\n  }\\n}\\nclass Car {\\n  drive() {\\n    throw new Error(\'不能调用抽象方法，请自己实现\');\\n  }\\n}\\n\\nclass BenzCar extends Car {\\n  drive() {\\n    console.log(\'Benz drive\');\\n  }\\n}\\n\\nclass AudiCar extends Car {\\n  drive() {\\n    console.log(\'Audi drive\');\\n  }\\n}\\nclass Engine {\\n  start() {\\n    throw new Error(\'不能调用抽象方法，请自己实现\');\\n  }\\n}\\n\\nclass BenzEngine extends Engine {\\n  start() {\\n    console.log(\'Benz engine start\');\\n  }\\n}\\n\\nclass AudiEngine extends Engine {\\n  start() {\\n    console.log(\'Audi engine start\');\\n  }\\n}\\nlet benz = new BenzFactory();\\nlet benzCar = benz.createCar();\\nlet benzEngine = benz.createEngine();\\n\\nlet audi = new AudiFactory();\\nlet audiCar = audi.createCar();\\nlet audiEngine = audi.createEngine();\\n\\nbenzCar.drive(); // Benz drive\\nbenzEngine.start(); // Benz engine start\\n\\naudiCar.drive(); // Audi drive\\naudiEngine.start(); // Audi engine start\\n```\\n\\n缺点也是随着分类越来越多，定义的类会越来越多，系统复杂度变高\\n\\n参考：[工厂模式](https://juejin.cn/post/6844903653774458888)、[工厂模式详解](https://juejin.cn/post/6844903895546724366)、js 设计模式、[抽象工厂模式-字节](https://juejin.cn/post/6844904018393710606)\\n\\n### 装饰者模式\\n\\n为了避免经常要去修改对象自身代码，我们需要用到装饰者模式\\n装饰者模式可以给某个对象添加额外的职责，而不会影响该类的派生对象\\n核心思想是装饰一些东西，但不影响原来的功能，给对象增加一个额外的功能\\n在前端领域，可以看作在某个函数执行前或者执行后运行一些额外的小功能\\n\\n- AOP 面向切面编程\\n\\n```javascript\\nconst AOP = {};\\nAOP.before = function (fn, before) {\\n  return function () {\\n    before.apply(this, arguments);\\n  };\\n};\\n\\nAOP.after = function (fn, after) {\\n  return function () {\\n    fn.apply(this, arguments);\\n    after.apply(this, arguments);\\n  };\\n};\\n```\\n\\n- es7 decorator\\n\\n```javascript\\nconst losgWrapper=targetClass=>{\\n  let originRender = targetClass.prototype.render\\n  targetClass.prototype.render=function(){\\n    xxx()\\n    originRender.apply(this)\\n    yyyy()\\n  }\\n  return targetClass\\n}\\n\\nclass App{\\n  constructor(){\\n    this.title=\\"\\"\\n  }\\n  render(){}\\n}\\n\\nApp=logWrapper(App)\\n\\n// es7提案修饰符，可以直接使用@logWrapper装饰，typescript也支持修饰符\\n@logWrapper\\nclass App{\\n  ...some code\\n}\\n```\\n\\n- 自行车的例子\\n\\n```javascript\\nclass Bicycle {\\n  wash() {\\n    console.log(\'清洗\');\\n  }\\n  ride() {\\n    console.log(\'出发\');\\n  }\\n  getPrice() {\\n    return 100;\\n  }\\n}\\nclass BicycleDecorator {\\n  constructor(bicycle) {\\n    this.bicycle = bicycle;\\n  }\\n  wash() {\\n    return this.bicycle.wash();\\n  }\\n  ride() {\\n    return this.bicycle.ride();\\n  }\\n  getPrice() {\\n    return this.bicycle.getPrice();\\n  }\\n}\\nclass HeadlightDecorator extends BicycleDecorator {\\n  constructor(bicycle) {\\n    super(bicycle);\\n  }\\n  getPrice() {\\n    return this.bicycle.getPrice() + 100;\\n  }\\n}\\n\\nlet bicycle = new Bicycle();\\nconsole.log(bicycle.getPrice());\\nbicycle = new HeadlightDecorator(bicycle);\\nconsole.log(bicycle.getPrice());\\n\\n//100\\n//200\\n```\\n\\n### 单例模式\\n\\n提供一个全局单一的实例，确保所有代码使用同一份全局资源。\\n\\n- 基本的单例模式\\n\\n一句话总结就是单体就是一个只能被实例化一次并且可以通过一个众所周知的访问点访问的类\\n也可以说是一个用来划分命名空间并将一批相关方法和属性组织在一起的对象，如果可以被实例化，智能呗实例化一次\\n\\n```javascript\\nlet singleTon = {\\n  name1: \'xxx\',\\n  name2: \'yyy\',\\n  methods1() {},\\n  method2() {},\\n};\\n```\\n\\n面向对象设计的第一条原则，类可以被拓展，但不能被修改。所以创建完这么一个单体模式，不应该使用 delete 操作符去更改他\\n对象字面量只是用来创建单体的方式之一\\n单体通常有两个部分组成，包括方法和属性成员，以及用于访问它的变量\\n使用单体模式能有效防止方法被不同的人意外改写\\n​\\n\\n使用闭包写的单体模式又称为模块模式\\n​\\n\\n在数据量较大时，还有一种优化方式是使用惰性实例化，通过创建一个 getInstance()方法，它会去检查单体是否已经被实例化，如果没有才会创建并返回其实例，如果已经实例化，它会返回现有实例。调用方式为 x.getInstace().method()\\n\\n### 链式调用\\n\\njQuery 的设计方式，每次操作都会返回原对象\\n\\n### 桥接模式\\n\\n桥接模式能够在不改变调用方式的情况下让 class1 和 class2 独立于 bridgeClass 发生改变\\n\\n```javascript\\nlet Class1 = function (a, b, c) {\\n  this.a = a;\\n  this.b = b;\\n  this.c = c;\\n};\\n\\nlet Class2 = function (d) {\\n  this.d = d;\\n};\\n\\nlet BridgeClass = function (a, b, c, d) {\\n  this.one = new Class1(a, b, c);\\n  this.two = new Class2(d);\\n};\\n```\\n\\n太抽象。其实可以看成是将汽车的车型和引擎分离，用的时候组装一下\\n\\n```javascript\\n// 比如现在有个Car类，有个继承于Car的RefinedCar，构造方法中接受一个Engine对象作为参数，\\n// 这个Engine作为具体引擎的抽象类\\n// 使用的时候只需要\\nconst car = new RefinedCar(new HybirdEngine());\\n\\n//这样一来，可以实现车和引擎的独立开发\\n```\\n\\n![image.png](./images/car-engine.png)\\n\\n### 组合模式\\n\\n组合模式适合层层嵌套的树状结构\\n组合模式的层次体系中分为叶对象和组合对象。\\n​\\n\\n两种情况下适合使用组合模式\\n\\n- 存在一批组织成某种层次体系的对象\\n- 希望对这批对象或其中的一部分对象实施一个操作\\n\\n### 门面模式\\n\\n非常常用的模式，主要有两个作用\\n\\n- 消除类与使用它的客户代码之间的耦合\\n- 简化类的接口\\n\\n```javascript\\nconst util = {\\n  stop() {},\\n  start() {},\\n  fire() {},\\n  drive() {},\\n};\\n```\\n\\n### 适配器模式\\n\\n用来协调不同的接口。与门面模式看起来相似，实则不同。\\n它与门面模式的差别在于如何改变接口。门面元素展现的是一个简化的接口，它并不提供额外的选择，有时为了方便完成常见任务还会做出一些嘉定。而适配器则要把一个 pp{}接口转换为另一个接口，并不会滤除。\\n对函数参数的适配，if else 都是适配器模式的体现\\n\\n### 享元模式\\n\\n最适合于解决因创建大量类似对象而累及性能的问题\\n\\n享元模式用于减少应用程序所需对象的数量。将对象的内部状态划分为内在数据和外在数据\\n\\n- 内在数据。类的内部方法所需要的信息\\n- 外在数据。可以从类身上剥离并存储在外部的信息\\n\\n创建享元对象需要使用工厂。是为了跟踪到已经实例化的各个对象\\n\\n举例：\\n\\n```js\\n// 表示一个城市的所有汽车，需要保存每一辆汽车的详细情况甚至及其所有权的详细情况\\nconst Car = function (year, price) {\\n  this.year = year;\\n  this.price = price;\\n  // 各种详细信息\\n};\\nCar.prototype = {\\n  getYear() {\\n    return this.year;\\n  },\\n  getPrice() {\\n    return this.price;\\n  },\\n};\\n```\\n\\n--\\n\\n数以万计的汽车信息消耗掉了大量资源。为了优化这个问题，需要使用享元模式减少所需对象的数目\\n\\n首先划分内在状态和外在状态。车子的自然属性输入内在数据，所有权属性属于外在数据。这意味着对于车子来说，品牌、型号和出厂日期的每一种组合，只需要一个汽车对象。对于所有权数据来说，同一个类型的各车主都可以共享一个汽车对象\\n\\n```js\\n// 我们需要创建一个工厂来生成汽车\\nconst carFactory = (function () {\\n  const createdCars = {};\\n  return {\\n    createCar(year, price) {\\n      if (createdClass[year + \'-\' + price]) {\\n        //如果汽车实例存在，就直接返回已有的实例\\n        return createdCars[year + \'-\' + price];\\n      } else {\\n        const car = new Car(year, owner);\\n        createdCars[year + \'price\' + price] = car;\\n        return car;\\n      }\\n    },\\n  };\\n})();\\n```\\n\\n还需要管理外在状态\\n\\n```js\\n// 用一个单体模式封装外在状态数据的管理器\\nconst CarRecordManager = (function () {\\n  const carRecordDatabase = {};\\n  return {\\n    addCarRecord: function (year, price, owner, age) {\\n      const car = CarFactory.createCar(year, owner);\\n      carRecordDatabase[owner] = {\\n        car,\\n        age,\\n      };\\n    },\\n    // 其他操作\\n  };\\n})();\\n```\\n\\n从 Car 类剥离的数据都在 CarRecordManage 这个单体的私有属性 carRecordDatabase 中。\\n\\n这种优化是以复杂性为代价的。原先只有一个汽车类，现在却变成了一个类和两个单体对象。并且把一个数据保存在两个不同的地方这种做法令人困惑，但是能够解决性能，这些无伤大雅。享元模式运用得当能够显著提升程序的性能\\n\\n管理外在数据有许多方法。之前用到的单体管理器是一种较常见的做法，也可以使用组合模式\\n\\n示例\\n\\n```js\\n// 日历，顺序显示每月中的各天，还会按顺序显示一年中的各个月\\nconst CalendarYear = function (year, parent) {\\n  this.year = year;\\n  this.element = document.createElement(\'div\');\\n  this.element.style.display = \'none\';\\n  parent.appendChild(this.element);\\n  function isLeapYear(y) {\\n    return y > 0 && !(y % 4) && (y % 100 || !(y % 400));\\n  }\\n  this.months = [];\\n  this.numDays = [31, isLeapYear(this.year) ? 29 : 28, 31, 30];\\n};\\n\\nCalendarYear.prototype = {\\n  display: function () {\\n    for (let i = 0, len = this.months.length; i < len; i++) {\\n      this.months[i].display();\\n    }\\n    this.element.style.display = \'block\';\\n  },\\n};\\nconst CalendarMonth = function (monthNum, numDays, parent) {\\n  this.monthNum = monthNum;\\n  this.element = document.createElement(\'div\');\\n  this.element.style.display = \'none\';\\n  parent.appendChild(this.element);\\n  for (let i = 0, len = numDays; i < len; i++) {\\n    this.days[i] = new CalendarDay(i, this.element);\\n  }\\n  this.months = [];\\n  this.numDays = [31, isLeapYear(this.year) ? 29 : 28, 31, 30];\\n};\\nCalendarMonth.prototype = {\\n  display: function () {\\n    for (let i = 0, len = this.days.length; i < len; i++) {\\n      this.days[i].display();\\n    }\\n    this.element.style.display = \'block\';\\n  },\\n};\\n\\nconst CalendarDay = function (date, parent) {\\n  this.date = date;\\n  this.element = document.createElement(\'div\');\\n  this.element.style.display = \'none\';\\n  parent.appendChild(this.element);\\n};\\nCalendarDay.prototype = {\\n  display: function () {\\n    this.element.style.display = \'block\';\\n    this.element.innerHTML = this.date;\\n  },\\n};\\n```\\n\\n根据这段代码的实现，我们不得不为一年创建 365 个 CalendarDay 对象。\\n\\n更有效的做法是无论日历要显示多少年，都只用一个 CalendarDay 对象来代表所有的日期\\n\\n​ **改造 calendar**\\n\\n- 第一步，把 CalendarDay 对象转化为享元对象，除去其中所有保存的数据\\n\\n```js\\nconst CalendarDay = function () {};\\nCalendarDay.prototype = {\\n  display: function (date, parent) {\\n    const element = document.createElement(\'div\');\\n    parent.appendChild(element);\\n    element.innerHTML = date;\\n  },\\n};\\n```\\n\\n这里直接实例化该对象`const calendarDay=new CalendarDay()`\\n\\n- 第二步，改造 CalendarMonth\\n\\n```js\\n// 复合物\\nconst CalendarMonth = function (monthNum, numDays, parent) {\\n  this.monthNum = monthNum;\\n  this.element = document.createElement(\'div\');\\n  this.element.style.display = \'none\';\\n  parent.appendChild(this.element);\\n\\n  this.days = [];\\n  for (let i = 0, len = numDays; i < len; i++) {\\n    this.days[i] = CalendarDay;\\n  }\\n};\\nCalendarMonth.prototype = {\\n  display: function () {\\n    for (let i = 0, len = this.days.length; i < len; i++) {\\n      this.days[i].display(i, this.element);\\n    }\\n    this.element.style.display = \'block\';\\n  },\\n};\\n```\\n\\n此例子中，没有像之前的管理器一样使用一个中心数据库，其实其他类也没做什么修改。\\n这是因为组合对象的数据结构本身就已经包含了所有的外在数据\\n\\n组合模式和享元模式配合的比较完美的，因为组合对象通常都拥有大量叶对象，它保存着许多可作为外在\\n数据处理的数据，叶对象通常只包含极少的内在数据，所以容易被\\n转化为共享资源\\n\\n> 另外在 js 需要创建大量 html 内容的情况下，享元模式非常有用\\n\\n::: warning\\n\\n享元模式的使用条件\\n\\n- 适合在使用了大量资源密集型对象时使用，如果只是少量对象，那么这样做不划算\\n- 对象中所保存的数据至少有一部分能被转化为外在数据\\n- 将外在数据分离出去后，独一无二的对象的数目相对少，最理想的是只存在一个独一无二的对象\\n\\n:::\\n\\n#### 一般的实现步骤\\n\\n1. 剥离所有外在数据\\n2. 创建一个用来控制该类实例化的工厂。该工厂掌握该类所有已创建出来的独一无二的实例\\n3. 创建一个用来保存外在数据的管理器。它把内在数据提供给工厂对象以创建一个对象。外在数据则被保存在管理器的一个数据结构中，管理器随后会根据需要将这些数据提供给共享对象的方法\\n\\n### 代理模式\\n\\n代理是一个对象，用来控制对另一个对象的访问，具有与另一个对象同样的接口，并会把任何方法调用传递给那个对象\\n\\n#### 代理如何控制对本体的访问\\n\\n不实现任何访问控制的代理最简单，只要把所有方法调用都传递到本体\\n\\n最有用的代理类型是**虚拟代理**。它会讲本体的实例化推迟到有\\n方法被调用的时候，适合控制常见开销很大的本体的访问\\n\\n```js\\nconst publicLibraryVirtualProxy = function (catalog) {\\n  this.library = null;\\n  this.catalog = catalog;\\n};\\npublicLibraryVirtualProxy.prototye = {\\n  _initializeLibrary: function () {\\n    if (this.library === null) {\\n      this.library = new publicLibraryVirtualProxy(this.catalog);\\n    }\\n  },\\n  findBooks: function (searchString) {\\n    this._initializeLibrary();\\n    return this.library.findBooks(searchString);\\n  },\\n};\\n```\\n\\n虚拟代理对于前端程序员来说比较有用，还有其他代理类型\\n\\n- 远程代理。需要远程对象长期存在，任何时候都可以从任何其他环境中访问。js 不适用是因为，其一是因为 js 的运行时环境不会长期存在，大多数 js 环境都在 web 浏览器中，随着用户的网上冲浪活动，通常每几分钟都会加载或者卸载一次，其二，js 无法建立到另一个运行时环境的套接字连接以访问其变量空间，即使它能长期存在，与此最接近的做法只是用 json 对方法调用进行序列化，然后用 ajax 技术将结果发送给某个资源\\n- 保护代理。根据客户的身份控制对特定方法的访问。\\n\\n### 命令模式\\n\\n用来对方法进行参数化处理和传送\\n\\n最简的命令对象的结构形式是一个操作和用以调用这个操作的独享的结合体\\n\\n就是将对象的某个方法再包一层调用，实现调用对象和实现操作对象的分离\\n\\n### 职责链模式\\n\\n由多个不同类型的对象组成。使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。\\n\\n将这个对象连成一条链，直到有一个对象处理它为止\\n\\n运转流程：\\n\\n1. 发送者知道链中的第一个接收者，向这个接收者发送请求\\n2. 每一个接受者都对请求进行分析，要么处理它，要么往下传\\n3. 每一个接受者知道的其他对象只有一个，即它在链中的下家\\n4. 如果没有任何接收者处理请求，那么请求将从链上离开，可以报错或者做其他处理\\n\\n发出请求的客户端并不知道哪一个对象最终处理这个请求，系统的更改可以在不影响客户端的情况下动态地重新组织和分配责任\\n\\n```ts\\n// 一个休假申请的例子，先建一个管理者类\\nabstract class Manager {\\n  constructor(name: string) {\\n    this.name = name;\\n  }\\n  setSuperior(superior: Manager) {\\n    // 设置上级\\n    this.superior = superior;\\n  }\\n  abstract requestApplications(request): void;\\n}\\n\\n// 再来一个经理类\\nclass commonManager extends Manager {\\n  constructor(name) {\\n    super();\\n    this.name = name;\\n  }\\n  requestApplications(request) {\\n    // 经理只能批准两天内的假期\\n    if (request.Request === \'请假\' && request.Number <= 2) {\\n      console.log(\'经理批准\');\\n    } else if (superior !== null) {\\n      superior.RequestApplications(request);\\n    }\\n  }\\n}\\n\\n// 还有总监类\\nclass Majordomo extends Manager {\\n  constructor(name) {\\n    super();\\n    this.name = name;\\n  }\\n  requestApplications(request) {\\n    if (request.RequestType === \'请假\' && request.Number <= 5) {\\n      console.log(\'总监批准\');\\n    } else if (superior !== null) {\\n      superior.RequestApplications(request);\\n    }\\n  }\\n}\\n\\nclass GeneralManager extends Manager {\\n  RequestApplications(request) {\\n    if (request.RequestType === \'请假\') {\\n      console.log(\'总经理批准请假\');\\n    } else if (request.RequestType === \'加薪\') {\\n      console.log(\'总经理批准加薪\');\\n    }\\n  }\\n}\\n\\n// 使用举例\\nconst jinli = new CommonManager(\'经理\');\\nconst zongjian = new Majordomo(\'总监\');\\nconst zongjingli = new GeneralManager(\'总经理\');\\njinli.SetSuperior(zongjian);\\nzongjian.SetSuperior(zongjingli);\\n\\nconst request = new Request();\\nrequest.RequestType = \'请假\';\\nrequest.RequestContent = \'小菜请假\';\\nrequest.Number = 1;\\njinli.RequestApplications(request);\\n// 客户端的申请都是由经理发起，但具体决策者是谁，客户端不知道\\n```\\n","frontmatter":{"title":"设计模式","desc":"《JavaScript设计模式》、《大话设计模式》笔记","keywords":"设计模式、笔记","date":"2020-02-17T01:01:00.000Z","cover":"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg"},"url":"/computer-basic/design-pattern/"},{"src":"---\\ntitle: 计算机网络\\ndesc: 《图解http》阅读笔记\\nkeywords: 计算机网络、笔记\\ndate: 2020-02-17 01:01:00\\ncover: https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg\\n---\\n\\n# 计算机网络\\n\\n## web 及网络基础\\n\\nweb 使用一种名为 HTTP 的协议作为规范，web 是建立在 http 协议上通信的\\n\\n### http 的诞生\\n\\n最初是 Tim·BernersLee 博士提出的借助文档之间相互关联形成的超文本，连成可相互参阅的 WWW 万维网。\\n有三项构建 WWW 的技术，一是把 SGML 标准通用标记语言作为页面的文本标记语言的 HTML；指定文档所在地址的 URL；作为文档传输协议的 HTTP。WWW 这一名称，是 web 浏览器当年用来浏览超文本的客户端应用程序时的名称。现在则用来表示这一系列的集合，也可简称为 web\\n\\n### 网络基础 TCP/IP\\n\\n通常使用的网络包括互联网都是在 TCP/IP 协议族上运作的。协议是能让计算机与网络设备相互通信的规则。\\n可以认为 TCP/IP 指的是 TCP 和 IP 这两种协议，也可以认为 TCP/IP 是在 IP 协议的通信过程中，使用到的协议族的统称。\\n​\\n\\nTCP/IP 协议族里最重要的一点是分成。分为 4 层：应用层、传输层、网络层、数据链路层\\n\\n- 应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。如 FTP 文件传输协议、DNS 域名系统服务。HTTP 协议也正是处于该层\\n- 传输层对上层应用层提供处于网络连接中的两台计算机之间的数据传输，有 TCP 传输控制协议和 UDP 用户数据报协议\\n- 网络层用来处理在网络上流动的数据包。数据包时网络传输的最小数据单位。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线\\n- 链路层又名数据链路层、网络接口层。用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC 网卡及光纤等物理可见部分。所有硬件上的范畴均在链路层的作用范围之内\\n\\n#### TCP/IP 通信传输流\\n\\n发送端从应用层往下走，接收端从下往应用层走。\\n\\n比如\\n\\n1. 首先客户端在应用层发出一个想看某个 web 页面的 http 请求\\n2. 接着。为了传输方便，传层层把应用层获取到的数据（http 请求报文）进行分割，并在各个报文上打上标记序号及端口号转发给网络层\\n3. 在网络层加上通信目的地的 mac 地址后转发给数据链路层\\n4. 接收端的服务器在链路层接受到数据，按序往上层发送，一直到达应用层。当传输到应用层，才算真正接收到客户端发送过来的 HTTP 请求\\n\\n![image.png](./images/work-flow.png)\\n\\n发送端层与层之间传输数据时，每经过一层必定会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部消去\\n\\n![image.png](./images/http-encapsulate.png)\\n\\n### IP、TCP 和 DNS\\n\\n#### IP 协议\\n\\n位于网络层，几乎所有使用网络的系统都会用到 IP 协议，IP 和 IP 地址不要混淆，IP 其实是一种协议的名称\\n\\nIP 协议的作用是把各种数据包传送给对方。为了切实传输，需要满足两个重要的条件 IP 地址和 MAC 地址。\\n\\n- IP 地址。指明节点被分配到的地址\\n- MAC 地址。网卡所属的固定地址\\n\\nIP 地址和 MAC 地址可以进行配对，IP 地址可以更换，但是 MAC 地址基本上不会更改\\n\\nIP 间的通信依赖 MAC 地址。但是在网络上，通信双方在同一局域网（LAN）内的情况是很少的，通常需要多台计算机和网络设备中转才能连接到对方。中转进行时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时需要 ARP 协议来解析地址，根据通信方的 IP 地址就可以反查出对应的 MAC 地址\\n\\n我们无法全面掌握互联网中的传输情况。因为在到达目标前的中转过程中，那些计算机和路由等网络设备智能获悉很粗略的传输路线。这被称为路由选择（routing），每个计算机或者网络设备掌握的都只是这一条网络传输路线中的某一部分\\n\\n#### TCP 协议\\n\\nTCP 位于传输层，提供可靠的字节流服务\\n\\n> 字节流（ByteStreamService）是为了方便传输，TCP 将大块数据分割成以报文段（segment）为单位的数据包进行管理。所谓“可靠”，是 TCP 协议能够确认数据最终是否送达给对方\\n\\n##### 如何确保可靠？\\n\\n送达目标时，**三次握手（three-way handshaking）**\\n\\nTCP 一定会确认数据包是否成功送达。握手过程中使用了 TCP 的标志（flag）\\n\\n- SYN（synchronize）\\n- ACK（acknowledgement）\\n\\n> 具体流程是发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息，最后发送端再回传一个带 ACK 标志的数据包，表示握手结束。如果握手过程中某个阶段莫名中断，tcp 协议会再次以相同的顺序发送相同的数据包。tcp 还有别的手段来保证通信的可靠性\\n\\n#### DNS 服务\\n\\nDNS（domain name system）服务和 http 都是位于应用层的协议，提供域名到 ip 地址之间的解析服务\\n\\n用户通常搜事用主机名或者域名来访问别人的计算机，而不是直接用 IP 地址访问，是因为 IP 地址是一组纯数字，不好记忆\\n\\n但是计算机更擅长处理数字，理解名称是困难的，DNS 正是为了解决这个问题，DNS 协议提供通过域名查找 IP 地址，或者逆向从 IP 地址反查域名的服务\\n\\n#### 各种协议和 HTTP 协议的关系\\n\\n1. 客户端有个域名。先去问应用层 DNS 要 IP 地址\\n2. IP 地址给应用层的 HTTP 协议，生成请求报文\\n3. HTTP 将报文交给 TCP 协议，TCP 分割报文\\n4. IP 协议搜索到对方的地址，配合 TCP，将报文传送给对方\\n5. 服务器的 TCP 协议接收到报文段，按序号重组请求报文\\n6. 报文交给 HTTP 协议，得到对应的请求内容\\n7. 请求的处理结果以 TCP/IP 通信协议再向用户进行回传\\n\\n### URI 和 URL\\n\\nURI（UniformResourceIdentifier），是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称\\n\\n- Uniform。规定统一的格式方便处理多种不同类型的资源\\n- Resource。资源的定义是“可标识的任何东西”\\n- Identifier。表示可标识的对象，也称为标识符\\n\\nURI 还包括 ftp、mailto、telnet、file 等，标准的 URI 方案有 30 种左右。\\n\\nURI 标识某一互联网资源，而 URL 表示资源的地点，即互联网上所处的位置，URL 是 URI 的子集\\n\\n绝对 URI 的格式\\n\\nhttp://user:pass@www.example.jp:80/dir/index.html?uid=1#ch1\\n\\n依次为协议+登录信息+服务器地址+服务器端口号+带层次的文件路径+查询字符串+片段标识符\\n\\n## HTTP 协议\\n\\nHTTP 协议用于客户端和服务器之间的通信\\n\\n请求访问文本或图像等资源的一端称为客户端，提供资源响应的一端称为服务器端。\\n\\n客户端会向服务端发送请求。请求报文包括了请求方法、请求 URI、协议版本、可选的首部字段和内容实体\\n\\n![image.png](./images/request-makeup.png)\\n\\n响应也会有类似的报文\\n\\n### HTTP 是不保存状态的协议\\n\\nHTTP 不对请求和响应之间的通信状态进行保存，协议对于发送过的请求和响应都不做持久化处理。这是为了更快地处理大量事务，确保协议的可伸缩性。\\n\\n但是，随着 web 发展，有了保存状态的需求，比如登陆状态的保存，为了解决这个问题，引入了**Cookie**技术\\n\\n### HTTP 方法\\n\\n- GET。请求资源\\n- POST。传输实体主体，POST 的主要目的并不是获取响应的主体内容\\n- PUT。传输文件，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。但是由于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件，存在安全问题，因此一般不用该方法。如果配合 WEB 应用程序的验证机制，或者采用 REST 架构标准的同类网站，就可能开放该方法\\n- HEAD。获得报文首部，Content-Length、Content-Type 等等\\n- DELETE。删除文件，但是同样的，HTTP/1.1 方法本身不带验证机制，所以一般也不用，当配合应用程序的验证机制或者遵守 REST 标准时是可能开放使用的\\n- OPTIONS。询问支持的方法，查询针对 URI 指定的资源支持的方法。返回 GET、POST、HEAD 等服务器支持的方法\\n- TRACE。追踪路径，壤 web 服务器将之前的请求通信环回给客户端的方法。发送请求时，max-forward 首部字段中填入一个数值，每经过一个服务器就将该数字减 1，当数值为 0 时，停止传输，最后接收到请求的服务器端则返回状态码 200ok。TRACE 方法可以用来确认连接到目标服务器的过程中发生的一系列操作。但是该方法不常用，且容易引发 XST（Cross-site tracing）跨站追踪。只是能看到 max-length 的数值变化\\n- CONNECT。要求在与服务器通信时建立隧道，实现用隧道协议进行 TCP 通信，主要使用 SSL 安全套接层和 TLS 传输层安全协议把通信内容加密后经网络隧道传输\\n\\n![image.png](./images/support-methods.png)\\n\\n### 持久连接\\n\\nHTTP keep-alive 或 HTTP connection reuse\\n\\n只要任一端没有明确提出断开连接，则保持 TCP 连接状态\\n\\n持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻服务器负担，使得 http 请求和响应都更快结束，提高了页面显示速度\\n\\nHTTP/1.1 中，所有的连接默认都是持久连接，但是 HTTP/1.0 中并未标准化，即便有服务器通过非标准手段实现了持久连接，但也未必可靠，客户端和服务器都要支持持久连接才行\\n\\n#### 管线化\\n\\n管线化可以在不等待响应结束的情况下直接发送下一请求，请求数越多，时间差越明显\\n\\n### Cookie 状态管理\\n\\n无状态协议的优点在于不必保存状态，减少了服务器的 CPU 以及内存资源的消耗。\\n\\n但是人们又有状态管理的需求，于是需要使用 Cookie。Cookie 通过在请求和响应的报文中写入 cookie 信息来控制客户端的状态。\\n\\n- cookie 会根据从服务端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去\\n- 服务端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪个客户端发来的请求，然后对比服务器上的记录最后得到之前的状态信息\\n\\n## HTTP 报文\\n\\n用于 HTTP 协议交互的信息被称为 HTTP 报文，分为报文首部和报文主体两块，报文由多行 CR+LF 换行划分\\n\\n请求报文和响应报文的报文首部结构基本是相似的\\n\\n- 请求行|状态行，请求行包含 GET、POST、HTTP 版本，状态行包含响应结果的状态码、原因短语、HTTP 版本\\n- 请求首部字段|响应首部字段\\n- 通用首部字段|通用首部字段\\n- 实体首部字段|实体首部字段\\n- 其他|其他\\n\\nLR+LF\\n\\n报文主体便是 html\\n\\n### HTTP 编码\\n\\nHTTP 可以按照数据原貌进行直接传输，编码是为了提升效率，通过在传输时编码，能有效地处理大量的访问请求，但是编码的操作需要计算机来完成，因此会消耗更多的 CPU 资源\\n\\n#### 报文主体和实体主体的差异\\n\\n- 报文\\n\\nHTTP 通信的基本单位，8 位组字节流组成，通过 HTTP 通信传输\\n\\n- 实体\\n\\n作为请求或响应的有效载荷数据被传输，由实体首部和实体主体组成\\n\\n报文的主体是**用来传输请求或者响应的实体主体**，通常可以说报文主体等于实体主体，**只有当传输过程中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异**\\n\\n#### 压缩\\n\\nHTTP 协议具备内容编码功能，可以指明应用在实体内容上的编码格式，原样压缩实体信息。内容编码后的实体由客户端接收并负责解码\\n\\n有以下几种编码方式\\n\\n- gzip(GNU zip)\\n- compress(UNIX 系统的标准压缩)\\n- deflate(zlib)\\n- identity(不进行编码)\\n\\n传送大容量数据时，通过把数据分割多块，可以让浏览器逐步显示页面，把实体主体分块的功能称为分块传输编码（chunked transfer coding）\\n\\n每一块都用 16 进制标记，最后一块使用(0(CR+LF))标记\\n\\nHTTP/1.1 存在传输编码的机制，可以在通信时按某种编码方式传输，但只定义作用于分块传输编码中\\n\\n还有一种场景。需要发送多种数据的多部分对象集合。比如邮件里可以写入文字并添加多份附件，是因为采用了 MIME 机制。\\n\\n通过使用 multipart/form-data、multipart/byteranges\\n\\n#### 范围请求\\n\\n`Range: bytes=50001-10000`\\n\\n可以用来从中断处恢复下载\\n\\n#### 内容协商\\n\\n浏览器会根据默认语言显示对应相同网站页面的中文版或者英文版。\\n\\n内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源，包含在请求报文中的某些首部字段中，如\\n\\n- Accept\\n- Accept-Charset\\n- Accept-Encoding\\n- Accept-Language\\n- Content-Language\\n\\n内容协商有 3 种类型\\n\\n1. 服务器驱动协商。以请求的首部字段作为参考，在服务端自动处理\\n2. 客户端驱动协商。用户从浏览器的可选项列表中手动选择\\n3. 透明协商。服务端和客户端各自进行内容协商\\n\\n## HTTP 状态码\\n\\n2xx 成功\\n3xx 重定向\\n4xx 客户端错误\\n5xx 服务器错误\\n\\n用到了就记住了\\n\\n## 与 http 协作的 web 服务器\\n\\nhttp1.1 允许一台 http 服务器搭建多个 web 站点\\n\\n也可以以每位客户持有的域名运行各自不同的网站，利用虚拟主机\\n\\n因此不同的域名解析出来的 ip 地址可能是相同的\\n\\n所以在发送 http 请求时，必须在 host 首部内完整指定主机名或域名的 URI\\n\\n### 通信数据转发程序\\n\\n除了客户端和服务器，还有一些用于通信数据转发的应用程序\\n\\n#### 代理\\n\\n接收客户端的请求转发给服务器，同时也返回服务器的响应给客户端\\n\\n就像个传话的，每次转发或者请求响应时，会追加写入 Via 首部信息\\n\\n使用代理服务器，是为了利用缓存技术减少网络带宽的流量，组织内部对特定网站的访问控制，以获取访问日志为主要目的\\n\\n缓存代理会缓存源服务器的资源，相同请求直接返回缓存\\n\\n透明代理不对报文做任何加工\\n\\n#### 网关\\n\\n转发其他服务器通信数据的服务器\\n\\n可以由 http 请求转化为其他协议通信\\n\\n能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全\\n\\n#### 隧道\\n\\n在相隔甚远的客户端和服务器之间进行中转，并保持双方通信连接\\n\\n可以使用 ssl 等加密手段进行通信\\n\\n不解析 http 请求，原样给之后的服务器\\n\\n### 缓存\\n\\n缓存指的是代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可以减少对源服务器的访问\\n\\n缓存会失效也会过期，缓存服务器会向源服务器确认缓存资源的有效性\\n\\n## nginx 的应用\\n\\n- 解决跨域\\n- 请求过滤\\n- 配置 gzip\\n- 负载均衡\\n- 静态资源服务器\\n\\n它是一个高性能的反向代理服务器\\n\\n### 什么是代理\\n\\n#### 正向代理\\n\\n比如翻墙，客户端向代理服务器发送请求并指定目标，代理服务器转交请求，并将内容返回给客户端\\n\\n- 正向代理是为我们服务的\\n- 正向代理对我们是透明的，对服务端是非透明的，服务端不知道请求是来自代理还是真实客户端\\n\\n#### 反向代理\\n\\n反向代理为服务端服务，反向代理帮助服务器接收来自客户端的请求，帮助服务器做请求转发、负载均衡\\n\\n- 反向代理对服务端是透明的，为服务端服务\\n\\n![image.png](./images/forward-everse.png)\\n\\n### 基本配置\\n\\n![image.png](./images/basic-config.png)\\n\\n```javascript\\nevents {\\n\\n}\\n\\nhttp\\n{\\n    server\\n    {\\n        location path\\n        {\\n            ...\\n        }\\n        location path\\n        {\\n            ...\\n        }\\n     }\\n\\n    server\\n    {\\n        ...\\n    }\\n\\n}\\n```\\n\\n- `main`:nginx 的全局配置，对全局生效。\\n- `events`​:配置影响 nginx 服务器或与用户的网络连接。\\n- `http`：可以嵌套多个 server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。\\n- `server`：配置虚拟主机的相关参数，一个 http 中可以有多个 server。\\n- `location`：配置请求的路由，以及各种页面的处理情况。\\n- `upstream`：配置后端服务器具体地址，负载均衡配置不可或缺的部分。\\n\\n#### 内置变量\\n\\n下面是 nginx 一些配置中常用的内置全局变量，你可以在配置的任何位置使用它们。\\n\\n| 变量名           | 功能                                                            |\\n| ---------------- | --------------------------------------------------------------- |\\n| $host            | 请求信息中的 Host，如果请求中没有 Host 行，则等于设置的服务器名 |\\n| $request_method  | 客户端请求类型，如 GET、POST                                    |\\n| $remote_addr     | 客户端的 IP 地址                                                |\\n| $args            | 请求中的参数                                                    |\\n| $content_length  | 请求头中的 Content-length 字段                                  |\\n| $http_user_agent | 客户端 agent 信息                                               |\\n| $http_cookie     | 客户端 cookie 信息                                              |\\n| $remote_addr     | 客户端的 IP 地址                                                |\\n| $remote_port     | 客户端的端口                                                    |\\n| $server_protocol | 请求使用的协议，如 HTTP/1.0、·HTTP/1.1`                         |\\n| $server_addr     | 服务器地址                                                      |\\n| $server_name     | 服务器名称                                                      |\\n| $server_port     | 服务器的端口号                                                  |\\n\\n### 跨域\\n\\n如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。反之则为不同源\\n![image.png](./images/cross-domain.png)\\n\\n#### nginx 解决跨域的原理\\n\\n例如：\\n\\n- 前端 server 的域名为：fe.server.com\\n- 后端服务的域名为：dev.server.com\\n\\n现在我在 fe.server.com 对 dev.server.com 发起请求一定会出现跨域。\\n现在我们只需要启动一个 nginx 服务器，将 server_name 设置为 fe.server.com,然后设置相应的 location 以拦截前端需要跨域的请求，最后将请求代理回 dev.server.com。如下面的配置：\\n\\n```javascript\\nserver {\\n  listen   80;\\n  server_name  fe.server.com;\\n  location / {\\n    proxy_pass dev.server.com;\\n  }\\n}\\n```\\n\\n这样可以完美绕过浏览器的同源策略：fe.server.com 访问 nginx 的 fe.server.com 属于同源访问，而 nginx 对服务端转发的请求不会触发浏览器的同源策略。\\n\\n### 请求过滤\\n\\n- 根据状态码过滤\\n\\n```javascript\\nerror_page 500 501 502 503 504 506 /50x.html;\\n    location = /50x.html {\\n        #将跟路径改编为存放html的路径。\\n        root /root/static/html;\\n    }\\n\\n```\\n\\n- 根据 URL 名称过滤，精准匹配 URL，不匹配的 URL 全部重定向到主页。\\n\\n```javascript\\nlocation / {\\n    rewrite  ^.*$ /index.html  redirect;\\n}\\n```\\n\\n- 根据请求类型过滤。\\n\\n```javascript\\nif ( $request_method !~ ^(GET|POST|HEAD)$ ) {\\n        return 403;\\n    }\\n\\n```\\n\\n### 配置 gzip\\n\\ngzip 是规定的三种标准 http 压缩格式之一。目前绝大多数网站都在使用 gzip 传输 html、css、javascript 等资源文件。\\n对于文本文件，gzip 可以将传输流量降低至四分之一到三分之一\\n并不是每个浏览器都支持 gzip 的，如何知道客户端是否支持 gzip 呢，请求头中的 Accept-Encoding 来标识对压缩的支持。\\n![](./images/request-headers.png)\\n启用 gzip 同时需要客户端和服务端的支持，如果客户端支持 gzip 的解析，那么只要服务端能够返回 gzip 的文件就可以启用 gzip 了,我们可以通过 nginx 的配置来让服务端支持 gzip。下面的 respone 中 content-encoding:gzip，指服务端开启了 gzip 的压缩方式。\\n![](./images/response-headers.png)\\n\\n```javascript\\ngzip                    on;\\n    gzip_http_version       1.1;\\n    gzip_comp_level         5;\\n    gzip_min_length         1000;\\n    gzip_types text/csv text/xml text/css text/plain text/javascript application/javascript application/x-javascript application/json application/xml;\\n```\\n\\n### gzip_http_version\\n\\n- 启用 GZip 所需的 HTTP 最低版本\\n- 默认值为 HTTP/1.1\\n\\n这里为什么默认版本不是 1.0 呢？\\nHTTP 运行在 TCP 连接之上，自然也有着跟 TCP 一样的三次握手、慢启动等特性。\\n启用持久连接情况下，服务器发出响应后让 TCP 连接继续打开着。同一对客户/服务器之间的后续请求和响应可以通过这个连接发送。\\n![](./images/keep-alive.png)\\n为了尽可能的提高 HTTP 性能，使用持久连接就显得尤为重要了。\\nHTTP/1.1 默认支持 TCP 持久连接，HTTP/1.0 也可以通过显式指定 Connection: keep-alive 来启用持久连接。对于 TCP 持久连接上的 HTTP 报文，客户端需要一种机制来准确判断结束位置，而在 HTTP/1.0 中，这种机制只有 Content-Length。而在 HTTP/1.1 中新增的 Transfer-Encoding: chunked 所对应的分块传输机制可以完美解决这类问题。\\nnginx 同样有着配置 chunked 的属性 chunked_transfer_encoding，这个属性是默认开启的。\\nNginx 在启用了 GZip 的情况下，不会等文件 GZip 完成再返回响应，而是边压缩边响应，这样可以显著提高 TTFB(Time To First Byte，首字节时间，WEB 性能优化重要指标)。这样唯一的问题是，Nginx 开始返回响应时，它无法知道将要传输的文件最终有多大，也就是无法给出 Content-Length 这个响应头部。\\n所以，在 HTTP1.0 中如果利用 Nginx 启用了 GZip，是无法获得 Content-Length 的，这导致 HTTP1.0 中开启持久链接和使用 GZip 只能二选一，所以在这里 gzip_http_version 默认设置为 1.1。\\n\\n### gzip_comp_level\\n\\n- 压缩级别，级别越高压缩率越大，当然压缩时间也就越长（传输快但比较消耗 cpu）。\\n- 默认值为 1\\n- 压缩级别取值为 1-9\\n\\n### gzip_min_length\\n\\n- 设置允许压缩的页面最小字节数，Content-Length 小于该值的请求将不会被压缩\\n- 默认值:0\\n- 当设置的值较小时，压缩后的长度可能比原文件大，建议设置 1000 以上\\n\\n### gzip_types\\n\\n- 要采用 gzip 压缩的文件类型(MIME 类型)\\n- 默认值:text/html(默认不压缩 js/css)\\n\\n## 负载均衡\\n\\n负载均衡就是帮助我们将众多的客户端请求合理的分配到各个服务器，以达到服务端资源的充分利用和更少的请求时间\\n\\n### nginx 实现负载均衡\\n\\n- Upstream 指定后端服务器地址列表\\n\\n```javascript\\nupstream balanceServer {\\n    server 10.1.22.33:12345;\\n    server 10.1.22.34:12345;\\n    server 10.1.22.35:12345;\\n}\\n```\\n\\n- 在 server 中拦截响应请求，并将请求转发到 Upstream 中配置的服务器列表。\\n\\n```javascript\\nserver {\\n        server_name  fe.server.com;\\n        listen 80;\\n        location /api {\\n            proxy_pass http://balanceServer;\\n        }\\n    }\\n```\\n\\n下一步要指定分配策略\\n![image.png](./images/allocation-strategy.png)\\n\\n#### 轮询策略\\n\\n默认策略，将所有客户端请求轮询分配给服务端。可以正常工作，但如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户\\n\\n```javascript\\nupstream balanceServer {\\n    server 10.1.22.33:12345;\\n    server 10.1.22.34:12345;\\n    server 10.1.22.35:12345;\\n}\\n```\\n\\n#### 最小连接数策略\\n\\n将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。\\n\\n```javascript\\nupstream balanceServer {\\n    least_conn;\\n    server 10.1.22.33:12345;\\n    server 10.1.22.34:12345;\\n    server 10.1.22.35:12345;\\n}\\n```\\n\\n#### 最快响应时间策略\\n\\n依赖于 nginx plus，优先分配给响应时间最短的服务器\\n\\n```javascript\\nupstream balanceServer {\\n    fair;\\n    server 10.1.22.33:12345;\\n    server 10.1.22.34:12345;\\n    server 10.1.22.35:12345;\\n}\\n```\\n\\n#### 客户端 ip 绑定\\n\\n来自同一个 ip 的请求永远只分配给一台服务器，有效解决了动态网页存在的 session 共享问题\\n\\n```javascript\\nupstream balanceServer {\\n    ip_hash;\\n    server 10.1.22.33:12345;\\n    server 10.1.22.34:12345;\\n    server 10.1.22.35:12345;\\n}\\n```\\n\\n## 静态资源服务器\\n\\n匹配以`png｜gif｜jpg｜jpeg`为结尾的请求，并将请求转发到本地路径，`root`中指定的路径即本地 nginx 的路径，同时可以进行一些缓存设置\\n\\n```javascript\\nlocation ~* \\\\.(png|gif|jpg|jpeg)$ {\\n    root    /root/static/;\\n    autoindex on;\\n    access_log  off;\\n    expires     10h;# 设置过期时间为10小时\\n}\\n```\\n\\n[参考](http://www.conardli.top/blog/article/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E5%BF%85%E5%A4%87%E7%9A%84nginx%E7%9F%A5%E8%AF%86.html#%E9%85%8D%E7%BD%AEgzip)\\n","frontmatter":{"title":"计算机网络","desc":"《图解http》阅读笔记","keywords":"计算机网络、笔记","date":"2020-02-17T01:01:00.000Z","cover":"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg"},"url":"/computer-basic/internet/"},{"src":"---\\ntitle: 浏览器\\ndesc: 浏览器相关知识点\\nkeywords: 设计模式、笔记\\ndate: 2020-02-17 01:01:00\\ncover: https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg\\n---\\n\\n# 浏览器\\n\\n## 浏览器的组成\\n\\n1. 渲染引擎（即内核）\\n\\n用来解析 HTML 和 CSS\\n这是浏览器兼容性问题出现的根本原因\\n常见浏览器的内核\\n\\n| 浏览器         | 内核    |\\n| -------------- | ------- |\\n| chrome         | Blink   |\\n| 欧鹏           | Blink   |\\n| 360 安全浏览器 | Blink   |\\n| 360 极速浏览器 | Blink   |\\n| Safari         | Webkit  |\\n| Firefox 火狐   | Gecko   |\\n| IE             | Trident |\\n\\n2. js 引擎\\n\\n用来解析网页中的 js 代码，处理后再运行\\n\\n| 浏览器        | JS 引擎                                                                         |\\n| ------------- | ------------------------------------------------------------------------------- |\\n| chrome / 欧鹏 | V8                                                                              |\\n| Safari        | Nitro                                                                           |\\n| Firefox 火狐  | SpiderMonkey（1.0-3.0）/ TraceMonkey（3.5-3.6）/ JaegerMonkey（4.0-）           |\\n| Opera         | Linear A（4.0-6.1）/ Linear B（7.0-9.2）/ Futhark（9.5-10.2）/ Carakan（10.5-） |\\n| IE            | Trident                                                                         |\\n\\n## 浏览器的多进程架构\\n\\n### 进程和线程\\n\\n进程是一个程序的运行实例。当我们启动一个程序，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程\\n![image.png](./images/process-thread.png)\\n线程依附于进程，由进程来启动和管理。\\n线程与进程之间的关系有以下特点\\n\\n1. 进程中任一线程执行出错，都会导致整个进程的崩溃，如果程序只有一个进程，那么很容易崩溃掉\\n2. 线程之间可以共享进程中的数据，都能进行读写操作\\n3. 一个进程关闭，操作系统会回收进程所占用的内存，即使某线程存在内存泄漏问题，内存也能被正确回收\\n4. 进程之间的内容相互严格隔离。如果需要通信，需要进程间通信（IPC）的机制 [《进程间的通信方式》](https://imageslr.github.io/2020/02/26/ipc.html)\\n\\n### 单进程浏览器\\n\\n![image.png](./images/single-process.png)\\n\\n#### 存在的问题\\n\\n- 不稳定。早期浏览器依赖各种插件实现 web 游戏、web 视频，但是插件容易出问题，任意一个线程挂掉都会导致整个浏览器的崩溃\\n- 不流畅。一个线程需要处理多个模块，比如页面线程需要同时处理页面渲染、页面展现等等，但是同一时刻只有一个模块能执行，造成长时间的等待、卡顿。同时，对于复杂的页面，如果页面内存泄漏，会存在内存不能完全回收的情况，因此导致使用时间越长，内存占用越高，浏览器越慢\\n- 不安全。恶意插件、恶意脚本\\n  > 进程结束时，内存总会被正确回收。 但线程结束时，可能存在内存泄漏的情况，所以在单进程的浏览器，打开和关闭的页面更多，浏览器就可能变得越来越卡顿。\\n\\n### 多进程浏览器\\n\\n以 Chrome 举例\\n\\n#### 早期多进程浏览器\\n\\n![image.png](./images/early-multi-process.png)\\n\\n- 解决不稳定问题。进程相互隔离，一个页面或者插件崩溃，不影响浏览器和其他进程\\n- 解决不流畅问题。不同站点的页面有自己的渲染进程，所以即便存在比如 js 阻塞渲染进程的情况，也只会影响当前页面\\n- 解决不安全问题。使用安全沙箱，Chrome 把插件和渲染进程锁在沙箱里面，沙箱里的程序无法访问硬盘和敏感位置。\\n\\n### 当前多进程浏览器\\n\\n![image.png](./images/current-multi-process.png)\\n\\n- 浏览器进程。界面显示、用户交互、子进程管理、存储\\n- 渲染进程。解析、渲染、执行 js，排版引擎 Blink 和 js 引擎 V8 都是运行在该进程中。渲染进程都运行在安全沙箱\\n- GPU 进程。GPU 最初是为了实现 3d css，但是后来网页和 Chrome 的 UI 界面都采用 GPU 绘制，GPU 成为普遍需求后，Chrome 的多进程架构引入了 GPU 进程。\\n- 网络进程。网络资源加载，独立了出来\\n- 插件进程。运行插件\\n\\n#### 存在问题：\\n\\n- 更高资源占用。每个进程都包含公共基础结构的副本如 js 运行环境\\n- 更复杂的体系架构。浏览器模块间耦合性高、拓展性差\\n\\n### 未来面向服务的架构\\n\\n“面向服务的架构”（Services Oriented Architecture，简称 SOA）\\n![image.png](./images/server-oriented.png)\\n原来的各种模块重构成独立的服务，每个服务都可以在独立的进程中运行\\n最终把 UI、数据库、文件、设备、网络等模块重构为基础服务\\nChrome 还能根据设备性能调整架构，在性能较差的设备上将服务整合到一个进程中。\\n![image.png](./images/server-oriented-1.png)\\n\\n## 浏览器是怎么工作的\\n\\n### 从一个 URL 到网页\\n\\n1. 浏览器首先使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面；\\n1. 把请求回来的 HTML 代码经过解析，构建成 DOM 树；\\n1. 计算 DOM 树上的 CSS 属性，构建 CSS 树；\\n1. 根据 CSS 属性对元素逐个进行渲染，得到内存中的位图；一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度；\\n1. 合成之后，再绘制到界面上。\\n\\n#### 用户输入\\n\\n在地址栏中输入一个查询关键字，地址栏会判断关键字是搜索内容还是请求的 URL\\n\\n- 搜索内容：使用搜索引擎合成新的带搜索关键字的 URL\\n- URL：加上协议，合成完整的 URL\\n  > 输入完，按下回车后，跳转页面前，还有一次 beforeunload 事件的机会，可以用于数据清理，或者询问用户是否确认离开或者提交表单\\n\\n#### URL 请求\\n\\n浏览器通过进程间通信把 URL 发送给网络进程\\n首先，网络进程会先查找本地缓存是否缓存了该资源，有就直接返回该资源给浏览器，没有就进入网络请求流程。\\n请求前先进行 DNS 解析，以获取请求域名的服务器 IP 地址，如果请求协议是 HTTPS，那么还需要建立 TLS 连接\\n\\n##### DNS 解析\\n\\n      在浏览器输入网址，其实就是像服务器请求我们想要的页面内容\\n\\n客户端收到输入的域名地址后，会先去找本地的 hosts 文件，检查是否有对应的域名\\n如果有就去向其 IP 地址发送请求，没有就去找 DNS 服务器，通过递归查询本地服务器和迭代查询 DNS 服务器获取到 IP 地址的响应报文\\n![截屏2020-11-18 上午11.54.39.png](./images/dns-classify.png)\\n![image.png](./images/dns-search.png)\\n\\n##### TCP 连接\\n\\n拿到 IP 后，下一步要通过三次握手链接到服务器，\\n要进行 TCP 连接，连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。\\n请求连接(SYN 数据包)\\n服务器\\n客户端\\n确认信息(SYNJACK 数据包)\\n握手结束(ACK 数据包)\\n![image.png](./images/three-hands.png)\\n\\n##### HTTP 请求\\n\\nHTTP 是纯粹的文本协议，基于 TCP 协议，是传输文本格式的一个应用层协议。\\n使用 telnet 发送 HTTP 请求\\n\\n```\\ntelnet time.geekbang.org 80\\n```\\n\\n![image.png](./images/telnet.png)\\n请求部分第一行称作 request line，包括请求的方法、路径、协议、协议版本，\\n响应部分第一行称作 response line，包括协议、版本、状态码、状态文本，\\n随后的由一个空行（两个换行符）分割的两部分，是请求/响应头和请求/响应体\\n![](./images/http-structure.jpeg)\\n\\n###### HTTP 头\\n\\n![](./images/http-head-request.png)\\n\\n![](./images/http-head-response.png)\\n\\n###### HTTP 体\\n\\n常见的 body 格式：\\n\\n- application/json\\n- application/x-www-form-urlencoded\\n- multipart/form-data\\n- text/xml\\n\\n这是一种媒体类型标准（MIME），表示文档、文件、字节流的性质和格式\\n结构是 type/subtype，type 表示可以被分为多个子类的独立类别，subtype 表示细分的类型\\n\\n> 浏览器通常使用 MIME 类型（而不是文件扩展名）来确定如何处理 URL，因此 Web 服务器在响应头中添加正确的 MIME 类型非常重要。如果配置不正确，浏览器可能会曲解文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。\\n\\n[MIME 类型](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types)\\n\\n###### HTTPS\\n\\n作用：\\n\\n1. 确定请求的目标服务端身份\\n1. 保证传输的数据不被网络中间节点窃听或者篡改\\n   > HTTPS 首先与服务端简历一条加密通道 TLS，TLS 基于 TCP\\n\\n###### HTTP2\\n\\n是 HTTP1.1 的升级版本\\n\\n1. 支持服务端推送。服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放入缓存当中，这可以避免客户端请求顺序带来的并行度不高，从而导致的性能问题。\\n1. 支持 TCP 连接复用，则使用同一个 TCP 连接来传输多个 HTTP 请求，避免了 TCP 连接建立时的三次握手开销，和初建 TCP 连接时传输窗口小的问题。\\n\\n##### 服务器处理请求\\n\\n服务器端收到请求后由 web 服务器处理请求，\\n如 apache、ngnix 等，解析用户请求后知道了需要调度哪些资源文件\\n再通过这些资源文件处理用户请求和参数，最后将结果通过 web 服务器返回给浏览器\\n![image.png](./images/server-handle-request.png)\\n响应也是报文，响应结果中会有一个 HTTP 状态码，代表对应的错误的信息。如 200 代表请求成功且处理完毕\\n假如返回 301 或者 302，说明服务器需要浏览器重定向到其他 URL，这时网络进程会从响应头的 Location 字段读取重定向地址，然后再发起新的请求\\n跳转之后，浏览器会根据 HTTP 请求头中的 Content-Type 的值来决定显示响应体的内容\\n这时，如果设置错了 mime 类型，浏览器可能会曲解内容\\n\\n##### 关闭 TCP 链接\\n\\n当双方没有请求或响应传递时，任意一方都可以发起关闭请求，需要 4 次挥手\\n![image.png](./images/close-tcp.png)\\n至此，资源获取完毕，开始渲染啦\\n\\n---\\n\\n### 渲染主线程\\n\\n#### 渲染进程准备阶段\\n\\nChrome 为每个页面分配一个渲染进程，但如果是 **根域名（xxx.com）和协议**  相同的同一站点，新页面会复用父页面的渲染进程，官方称这种策略为 process-per-site-instance\\n比如\\n\\n- https://time.xxx.com\\n- https://www.xxx.com\\n- https://www.xxx.com:8080\\n\\n[URL 初探](https://juejin.cn/post/6855129007424602120)\\n此时还不能进入文档解析状态，数据还在网络进程中\\n\\n#### 提交文档阶段\\n\\n- 浏览器进程接收到网络进程的响应数据，向渲染进程发起“提交文档“的消息\\n- 渲染进程与网络进程建立传输数据的管道\\n- 数据传输完成，渲染进程返回“确认提交”信息给浏览器进程\\n- 浏览器进程收到“确认提交”消息，更新浏览器洁面状态，包括安全状态、地址栏 URL、前进后退的历史状态，然后更新 web 页面，此时进入渲染阶段\\n  > 因此我们输入一个地址并回车后，页面并没有马上消息，要等一会儿才更新页面\\n\\n#### 解析 HTML\\n\\n##### 词法分析\\n\\n```html\\n<p class=\\"a\\">text text text</p>\\n```\\n\\n以上 HTML 片段会被拆分成词（token）\\n\\n- `<p`“标签”的开始；\\n- `class=“a”` 属性；\\n- `>` “标签”的结束；\\n- text text text 文本；\\n- `</p>` 标签结束。\\n\\n![](./images/html-token.png)\\n把字符流解析成词的最常见方案是使用 **状态机**\\n\\n##### 状态机\\n\\n初始状态，区分“<”“非<”\\n出现“<”可以认为进入一个标签状态，“非<”可以认为进入一个文本节点\\n进入标签状态还需要区分：\\n\\n| 下一个字符 | 分析                    |\\n| ---------- | ----------------------- |\\n| !          | 注释节点或者 CDATA 节点 |\\n| /          | 结束标签                |\\n| 字母       | 开始标签                |\\n\\n##### 构建 DOM 树\\n\\n![image.png](./images/build-dom-tree.png)\\n用 js 模拟 HTML 的语法分析器\\n\\n```javascript\\n/*receiveInput负责接收词法部分产生的词\\n接收的同时，构建DOM树，栈顶就是最后的根节点\\ndom树的产出就是这个stack的第一项*/\\nfunction HTMLSyntaticalParser() {\\n  let stack = [new HTMLDocument()];\\n  this.receiveInput = function (token) {\\n    /*\\n        1. 栈顶元素就是当前节点；\\n        2. 遇到属性，就添加到当前节点；\\n        3. 遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点；\\n        4. 遇到注释节点，作为当前节点的子节点；\\n        5. 遇到 tag start 就入栈一个节点，当前节点就是这个节点的父节点；\\n        6. 遇到 tag end 就出栈一个节点（还可以检查是否匹配）。\\n        */\\n  };\\n  this.getOutput = function () {\\n    return stack[0];\\n  };\\n}\\n```\\n\\n> 可通过在浏览器控制台输入“document”后回车查看 dom 树结构\\n\\n#### 解析 CSS\\n\\n![image.png](./images/analysis-css-tree.png)\\nCSS 规则不是 DOM 结构建好了以后才添加样式的，而是依次拿到上一步构造好的元素，去检查匹配哪些规则再根据规则优先级进行覆盖和调整。不存在父选择器，选择器的出现顺序必定跟构建 DOM 树的顺序一致。\\n\\n- 空格: 后代，选中它的子节点和所有子节点的后代节点。\\n- > : 子代，选中它的子节点。\\n- +：直接后继选择器，选中它的下一个相邻节点。\\n- ~：后继，选中它之后所有的相邻节点。\\n- ||：列，选中表格中的一列。\\n\\n规则匹配的时候，也是要根据节点信息处理\\n\\n> 可通过在浏览器控制台输入 document.styleSheets 查看 css 代码生成的结构\\n\\ncss 在被处理成 styleSheets 后，还要进行标准化，处理一些不被浏览器渲染引擎理解的属性值，例如：\\n![image.png](./images/css-standardization.png)\\n\\n#### 布局\\n\\n有了 DOM 树和样式，还不足以显示页面，还需要给可见元素计算几何位置\\n\\n1.  创建布局树 LayoutTree\\n\\n    构建一棵只包含可见元素的布局树。\\n\\n2.  布局计算\\n\\n         计算布局树节点的坐标位置，重新写回布局树中。\\n\\n    浏览器的基本布局方案是正常流排版，在此基础上支持绝对定位元素和浮动元素\\n\\n3.  正常流布局：顺次排布、折行，支持元素和文字的混排\\n4.  绝对定位元素：把自身抽离正常流，依靠 top、left 等确定位置，不参加布局计算，不影响其他元素\\n5.  浮动元素：使自身处于正常流的左或者右的边界，占据一块空间\\n\\n除此之外，还有 flex、grid 等布局方式\\n\\n#### 分层\\n\\n针对复杂的 3d 变换、页面滚动、z 轴排序，渲染引擎需要为特定的节点生成专用的涂层，生成一棵 LayerTree\\n并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，就从属于父节点的图层\\n\\n> 拥有层叠上下文属性的元素会被提升为单独的一层，裁剪的元素也会成为单独一层\\n\\n![image.png](./images/layer-tree.png)\\n\\n#### 图层绘制\\n\\n渲染引擎将一个图层的绘制拆分成很多小的绘制指令，按顺序组成一个待绘制列表，在这个阶段我们获得一个待绘制列表\\n![image.png](./images/coverage.png)\\n\\n### 合成线程\\n\\n#### 栅格化操作\\n\\n一个页面可能会很大，但是用户只能基于视口看到一部分，因此没有必要用巨大的开销去渲染整个页面。\\n于是乎，当绘制列表产出后，主线程把绘制列表提交给合成线程，合成线程会将图层划分为 **图块（tile）** ，通常是 256x256 或者 512x512，合成线程会按照视口附近的图块优先生成位图， **实际生成位图的操作是由栅格化执行，将图块转换为位图** 。\\n渲染进程维护一个栅格化的线程池，图块的栅格化都在线程池里执行\\n![](./images/composite-1.png)\\n栅格化会使用 gpu 来加速，称为快速栅格化，或 gpu 栅格化，生成的位图被保存在 gpu 内存中\\n![](./images/composite-2.png)\\n\\n#### 合成 compositing\\n\\n合成线程收集图块信息（也叫绘制四边形 DrawQuad），然后进行合成帧操作，并将合成帧递交给主进程，最后浏览器主进程将合成帧发送给 GPU 进程，将页面内容绘制到内存中，最后将内存中的内容显示在屏幕上，变成肉眼可见的图像\\n浏览器有一个叫 viz 的组件，用来接收合成线程发来的 DrawQuad 命令，根据 DrawQuad 命令，将页面内容绘制到内存中，最后将内存显示在屏幕上，变成肉眼可见的图像\\n\\n### 绘制的抽象理解\\n\\n把每一个元素对应的盒变成位图，在内存中。把模型变为位图\\n可分为两类：图形和文字\\n\\n- 图形：背景、边框、SVG 元素、阴影，需要底层库支持，Android 有 Skia，Windows 有 GDI\\n- 文字：分像素字形和矢量字形两种，小尺寸如 6px、8px 提供像素字形，大尺寸提供矢量字形。需要字体库支持，比如 C++编写的 Freetype，提供读取字体文件的基本能力，能够根据字符的码点抽取出字形\\n  > 渲染时，最普遍的情况是生成的位图尺寸跟它在上一步排版时占据的尺寸相同。\\n  > 但是很多属性会影响位图的大小，比如阴影，因此阴影会作为一个独立的盒来处理\\n\\n渲染过程中，子元素是不会被绘制到渲染的位图上的，这样能够在父子元素的相对位置发生变化时，保证渲染的结果能够最大程度被缓存，减少重新渲染。\\n绘制过程，不会把子元素渲染到位图，合成正是为了创建合成的位图，把部分子元素渲染到合成的位图上\\n\\n##### 合成策略\\n\\n```html\\n<div id=\\"a\\">\\n  <div id=\\"b\\">...</div>\\n  <div id=\\"c\\" style=\\"transform:translate(0,0)\\"></div>\\n</div>\\n```\\n\\n猜测可能变化的元素，排除到合成之外，从而提高性能\\n假设以上代码要对 c 元素进行改变，此时如果合成 a 和 b，不合成 c，就能减少绘制次数，产生极大的性能收益\\n目前，合成策略根据 position、transform 等属性来决定，但是新的 css 标准给出了 will-change 属性，可以结合业务代码提示浏览器的合成策略。\\n[will-change mdn](https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change)\\n\\n##### 显示\\n\\n浏览器会把最终要显示的位图交给操作系统处理\\n借助脏矩形算法，当鼠标移、元素移动或者其他需要导致重绘的场景发生时，只重新绘制它所影响到的几个矩形区域，重绘脏矩形区域时，把所有与矩形区域有交集的合成层（位图）的交集部分绘制即可。\\n\\n参考：\\n\\n- [输入一个 url 后会发生什么](https://www.xuecaijie.com/it/157.html#1Q64p5DeC8dKFF)\\n- [渲染页面-mdn](https://developer.mozilla.org/zh-CN/docs/Web/Performance/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86)\\n- [浏览器渲染](https://juejin.im/post/6844903565610188807)\\n- 重学前端-模块三：浏览器实现原理与 API\\n- 浏览器工作原理与实践-李兵\\n\\n### 关于浏览器工作流程的思维导图、ppt\\n\\n![WechatIMG3.jpeg](./images/browser-work-flow.jpeg)\\n\\n- [浏览器架构.pdf](https://www.yuque.com/attachments/yuque/0/2021/pdf/2165937/1615090982321-6b025e49-2013-4598-88be-128b5c64b02f.pdf?_lake_card=%7B%22uid%22%3A%221615090980076-0%22%2C%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2021%2Fpdf%2F2165937%2F1615090982321-6b025e49-2013-4598-88be-128b5c64b02f.pdf%22%2C%22name%22%3A%22%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84.pdf%22%2C%22size%22%3A1251962%2C%22type%22%3A%22application%2Fpdf%22%2C%22ext%22%3A%22pdf%22%2C%22progress%22%3A%7B%22percent%22%3A99%7D%2C%22status%22%3A%22done%22%2C%22percent%22%3A0%2C%22id%22%3A%22T0io8%22%2C%22card%22%3A%22file%22%7D)\\n- [浅析浏览器渲染原理.ppt](https://www.yuque.com/attachments/yuque/0/2021/ppt/2165937/1615091175679-2de9ca82-8e8e-49a6-b0f7-9b01133007de.ppt?_lake_card=%7B%22uid%22%3A%221615091087164-0%22%2C%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2021%2Fppt%2F2165937%2F1615091175679-2de9ca82-8e8e-49a6-b0f7-9b01133007de.ppt%22%2C%22name%22%3A%22%E6%B5%85%E6%9E%90%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86.ppt%22%2C%22size%22%3A2186240%2C%22type%22%3A%22application%2Fvnd.ms-powerpoint%22%2C%22ext%22%3A%22ppt%22%2C%22progress%22%3A%7B%22percent%22%3A99%7D%2C%22status%22%3A%22done%22%2C%22percent%22%3A0%2C%22id%22%3A%2296aUu%22%2C%22card%22%3A%22file%22%7D)\\n\\n## 浏览器 window 对象\\n\\n所谓的 **BOM（Browser Object Model）浏览器对象模型** ，是为了控制浏览器的行为而出现的接口。\\n![image.png](./images/window.png)\\n属于 BOM 区域的有浏览器标签页、地址栏、滚动条、右键菜单等等\\nBOM 的 **核心对象** 是 **Window** ，包含了 DOM 的核心对象 document\\nwindow 不仅是全局作用域，还表示浏览器窗口\\n常用的 BOM API：\\n\\n- `innerWidth` `innerHeight`  可以获取浏览器窗口内部去除掉菜单栏、工具栏、边框等后的宽高，\\n- `outerWidth` `outerHeight`  获取浏览器窗口的整个宽高\\n- `navigator`  表示浏览器的信息\\n\\n`navigator.appName`：浏览器名称；\\n`navigator.appVersion`：浏览器版本；\\n`navigator.language`：浏览器设置的语言；\\n`navigator.platform`：操作系统类型；\\n`navigator.userAgent`：浏览器设定的`User-Agent`字符串。\\n但是 navigator 的信息很容易可以修改，所以不一定是正确的，不要用这个去判断浏览器版本\\n正确做法是直接用||短路运算符\\n\\n- `screen`表示屏幕信息，常用属性有\\n\\n`screen.width`：屏幕宽度，以像素为单位；\\n`screen.height`：屏幕高度，以像素为单位；\\n`screen.colorDepth`：返回颜色位数，如 8、16、24。\\n\\n- `location`  对象表示当前页面的 url 信息\\n\\n```text\\nhttp://www.example.com:8080/path/index.html?a=1&b=2#TOP\\n```\\n\\n可以用`location.href`获取完整的 url。要获得 URL 各个部分的值，可以这么写：\\n\\n```javascript\\nlocation.protocol; // \'http\'\\nlocation.host; // \'www.example.com\'\\nlocation.port; // \'8080\'\\nlocation.Javapathname; // \'/path/index.html\'\\nlocation.search; // \'?a=1&b=2\'\\nlocation.hash; // \'TOP\'\\n```\\n\\n`location.assign()`加载一个新页面，`location.reload()`重新加载当前页面\\n**参考**\\n\\n- [DOM 和 BOM](https://juejin.cn/post/6844903939008102413)\\n\\n## document 文档对象\\n\\n表示当前页面，`document`对象是整个 dom 树的根节点\\n常用方法：\\n`document.title`获取 title 标签属性\\n`getElementById()`\\n`getElementsByTagName()`\\n`document.querySelector()`\\n`document.addEventListener()`\\n`document.cookie`获取当前页面的 Cookie，cookie 由服务器发送的 key-value 标识符，可用于区分不同用户的请求，服务器发送一个 cookie 给浏览器，浏览器访问该网站就会在请求头上附上这个 cookie。但是有安全隐患，因为 html 可以直接引用第三方的 js 代码，解决这个问题需要服务器设置 cookie 时使用 httponly\\n\\n## DOM 事件和事件委托\\n\\n### DOM 事件模型\\n\\n![](./images/event-delegation.png)\\nDOM 模型用一个逻辑树来表示一个文档，树的每个分支的终点都是一个节点(node)，每个节点都包含着对象(objects)。DOM 的方法(methods)让你可以用特定方式操作这个树，用这些方法你可以改变文档的结构、样式或者内容。节点可以关联上事件处理器，一旦某一事件被触发了，那些事件处理器就会被执行。\\n\\n### 捕获和冒泡：\\n\\nNetscape 认为 outer 上的处理函数应该先被执行. 这被称作 event capturing，即从外到内\\n\\nIE 则认为 inner 上的处理函数具有执行优先权. 这被叫做 event bubbling，即从内到外\\n\\n于是 W3C 标准则取其折中方案. W3C 事件模型中发生的任何事件, 先(从其祖先元素 document)开始一路向下捕获, 直到达到目标元素, 其后再次从目标元素开始冒泡.(先捕获再冒泡，搞清楚这一点很重要）\\n\\n开发者可以决定事件处理器是注册在捕获或者是冒泡阶段. 如果 addEventListener 的最后一个参数是 true, 那么处理函数将在捕获阶段被触发; 否则(false), 会在冒泡阶段被触发.\\n\\n**也就是每点击一个元素，以点击的元素为中心，先捕获，再冒泡，false 或者不加参数表示注册在冒泡阶段执行，true 表示注册在捕获阶段执行**\\n\\n示例：\\n\\n```html\\n<!DOCTYPE html>\\n<html>\\n  <head>\\n    <meta charset=\\"utf-8\\" />\\n    <title>JS Bin</title>\\n  </head>\\n  <body>\\n    <div id=\\"grand1\\">\\n      爷爷\\n      <div id=\\"parent1\\">\\n        爸爸\\n        <div id=\\"child1\\">儿子</div>\\n      </div>\\n    </div>\\n  </body>\\n</html>\\n```\\n\\n```javascript\\ngrand1.addEventListener(\\n  \'click\',\\n  function f1() {\\n    console.log(\'爷爷\');\\n  },\\n  false\\n); //冒泡\\n\\nparent1.addEventListener(\\n  \'click\',\\n  function f1() {\\n    console.log(\'爸爸\');\\n  },\\n  true\\n); //捕获\\n\\nchild1.addEventListener(\\n  \'click\',\\n  function f3() {\\n    console.log(\'儿子冒泡\');\\n  },\\n  false\\n); //冒泡\\n\\nchild1.addEventListener(\\n  \'click\',\\n  function f3() {\\n    console.log(\'儿子捕获\');\\n  },\\n  true\\n); //捕获\\n```\\n\\n结果依次为：\\n\\n1. 点击儿子\\n   ![](./images/click-son.png)\\n1. 点击爸爸\\n   ![](./images/click-dad.png)\\n1. 点击爷爷\\n   ![](./images/click-grandpa.png)\\n\\n### 事件委托\\n\\n事件委托，通俗地来讲，就是把一个元素响应事件（click、keydown......）的函数委托到另一个元素,好处是节省了内存还能够动态监听元素\\n\\n一般来讲，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。\\n\\n示例：\\n\\n```html\\n<div id=\\"test\\">\\n  <div class=\\"red\\">hi</div>\\n  <div class=\\"red\\">hi</div>\\n  <div class=\\"red\\">hi</div>\\n  <div class=\\"red\\">hi</div>\\n  <div class=\\"red\\">hi</div>\\n</div>\\n```\\n\\n```javascript\\n\\n delegateEvent(parentSelector, targetSelector, events, fn) {\\n        // 事件处理逻辑,\\n        parentSelector.addEventListener(parentSelector, events, function (e) {\\n\\n            let targetEl = e.target\\n            const currentTarget = e.currentTarget;\\n\\n            // 遍历并判断是否为目标元素，如果不是，则往元素的 parentNode 继续查找\\n            while (!targetEl.matches(targetSelector)) {\\n                // 如果是目标元素则跳出循环\\n                if (targetEl === currentTarget) {\\n                    targetEl = null;\\n                    break;\\n                }\\n                targetEl = targetEl.parentNode;\\n            }\\n\\n            if (targetEl) {\\n                // 将回调函数的 this 指向目标元素\\n                fn.call(targetEl, Array.prototype.slice.call(arguments));\\n            }\\n        });\\n\\n    }\\n```\\n\\n```javascript\\nconst test = document.querySelector(\'#test\');\\ndom.delegateEvent(test, \'#test .red\', \'click\', () => {\\n  console.log(\'我被点击了\');\\n});\\n```\\n\\n---\\n\\n## history 对象\\n\\n`window.history` ，保存了浏览器的历史记录，js 可以调用 history 对象的 back() or forward()，相当于点击浏览器的后退和前进，这个在现代 web 复杂的页面交互中是不适用的\\n\\n## 浏览器兼容性问题\\n\\n### 样式兼容性\\n\\n![image.png](./images/style-compatibility.png)\\n\\n1. 使用 Normalize.css 或是自己撰写 reset 重置样式\\n1. 不同浏览器厂商对于 css3 的样式提供了针对浏览器的前缀\\n   | 内核 | 浏览器代表 | 前缀 |\\n   | --- | --- | --- |\\n   | Trident | IE | -ms |\\n   | Gecko | Firefox | -moz |\\n   | Presto 已废弃 | Opera 前内核 | -o |\\n   | Webkit | Chrome、Safari | -webkit |\\n\\n1. opacity\\n\\n```javascript\\nopacity: 0.5;\\nfilter: alpha((opacity = 50)); //IE6-IE8我们习惯使用filter滤镜属性来进行实现\\nfilter: progid: DXImageTransform.Microsoft.Alpha((style = 0), (opacity = 50)); //IE4-IE9都支持滤镜写法progid:DXImageTransform.Microsoft.Alpha(Opacity=xx)\\n```\\n\\n### 交互兼容性\\n\\n![image.png](./images/ninteraction-compatibility.png)\\n事件兼容：\\n适配器写法\\n\\n```javascript\\nvar helper = {};\\n\\n//绑定事件\\nhelper.on = function (target, type, handler) {\\n  if (target.addEventListener) {\\n    target.addEventListener(type, handler, false);\\n  } else {\\n    target.attachEvent(\\n      \'on\' + type,\\n      function (event) {\\n        return handler.call(target, event);\\n      },\\n      false\\n    );\\n  }\\n};\\n\\n//取消事件监听\\nhelper.remove = function (target, type, handler) {\\n  if (target.removeEventListener) {\\n    target.removeEventListener(type, handler);\\n  } else {\\n    target.detachEvent(\\n      \'on\' + type,\\n      function (event) {\\n        return handler.call(target, event);\\n      },\\n      true\\n    );\\n  }\\n};\\n```\\n\\n### 浏览器 hack\\n\\n![image.png](./images/browser-hack.png)\\n不同厂商的浏览器或者同一浏览器的不同版本都可能存在对 css、js 的支持、解析不一样，为了获得统一的效果，就要针对不同的浏览器或不同版本写特定的 css 或 js\\n有 css hack 和 js hack\\n发现一个便于查询的网站[https://www.html.cn/tool/hack/](https://www.html.cn/tool/hack/)\\n但是需要注意 hack 并不总是完美的解决方案，大多数情况下应该修复 css/js\\n可以使用[modernizr](https://modernizr.com/)库进行功能检测，还有中文网[modernizr](http://modernizr.cn)\\n","frontmatter":{"title":"浏览器","desc":"浏览器相关知识点","keywords":"设计模式、笔记","date":"2020-02-17T01:01:00.000Z","cover":"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg"},"url":"/front-end/browser/"},{"src":"---\\ntitle: canvas\\ndesc: canvas\\nkeywords: 设计模式、笔记\\ndate: 2020-02-17 01:01:00\\ncover: https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg\\n---\\n\\n# canvas\\n\\n## 是什么？\\n\\ncanvas 是一个可以使用 js 脚本绘制图形的 HTML 元素\\n\\n## 什么用处？\\n\\n可绘制图标、图形、制作图片\\n\\n## 怎么用？\\n\\n### 基本用法\\n\\n1. 准备一个`<canvas id=\\"xxx\\"></canvas>`标签\\n1. 获取 dom 对象，`let canvas=document.getElementById(\'xxx\')`\\n1. 获取 canvas 的渲染上下文，`let ctx=canvas.getContext(\'2d\')`\\n\\n> canvas 标签没有 src 和 alt，只有 width 和 height 属性\\n> 可以插入后备内容，支持 canvas 的显示 canvas，不支持的浏览器忽略 canvas，显示插入的后备内容，因此必须闭合\\n\\n### 绘制形状\\n\\n1. 栅格\\n   canvas 元素默认具有网格，一个单元格相当于一个 canvas 像素\\n\\n![](https://cdn.nlark.com/yuque/0/2020/png/2165937/1608701881543-31456ccf-d71f-49a4-9bc6-6c6738828405.png#align=left&display=inline&height=220&margin=%5Bobject%20Object%5D&originHeight=220&originWidth=220&size=0&status=done&style=none&width=220)\\n\\n2. 矩形\\n   canvas 只支持两种形式的图形绘制：矩形和路径（即线段）\\n   绘制矩形的三种方法：\\n\\n- `fillRect(x, y, width, height)`\\n  绘制一个填充的矩形\\n- `strokeRect(x, y, width, height)`\\n  绘制一个矩形的边框\\n- `clearRect(x, y, width, height)`\\n  清除指定矩形区域，让清除部分完全透明。 3.路径（线段）\\n- `beginPath()`\\n  新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。\\n- `closePath()`\\n  绘制完后调用，闭合路径之后图形绘制命令又重新指向到上下文中。\\n- `stroke()`\\n  通过线条来绘制图形轮廓。\\n- `fill()`\\n  通过填充路径的内容区域生成实心的图形。\\n  调用了 fill 不需要再调用 closePath，会自动闭合\\n\\n### 绘制命令\\n\\n1. `moveTo(x,y)`\\n   移动笔触,放置相对于左上角起始点的点位\\n1. `lineTo(x,y)`\\n   绘制一条从当前位置到指定坐标点的直线\\n1. `arc(x, y, radius, startAngle, endAngle, anticlockwise)`\\n   画一个以（x,y）为圆心的以 radius 为半径的圆弧（圆），从 startAngle 开始到 endAngle 结束，按照 anticlockwise 给定的方向（默认为顺时针）来生成。\\n\\n> 还可以用`arcTo(x1, y1, x2, y2, radius)`，给定点和半径画一个圆弧，再以直线连接两个控制点\\n\\n4. 二次贝塞尔曲线及三次贝塞尔曲线\\n\\n- `quadraticCurveTo(cp1x, cp1y, x, y)`\\n  绘制二次贝塞尔曲线，cp1x,cp1y 为一个控制点，x,y 为结束点。\\n- `bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)`\\n  绘制三次贝塞尔曲线，cp1x,cp1y 为控制点一，cp2x,cp2y 为控制点二，x,y 为结束点。\\n\\n  5.Path2D\\n  一个对象，用来缓存或记录绘画命令\\n\\n```javascript\\nvar ctx = canvas.getContext(\'2d\');\\nvar rectangle = new Path2D();\\nrectangle.rect(10, 10, 50, 50);\\n\\nvar circle = new Path2D();\\ncircle.moveTo(125, 35);\\ncircle.arc(100, 35, 25, 0, 2 * Math.PI);\\n\\nctx.stroke(rectangle);\\nctx.fill(circle);\\n```\\n\\n6. SVG paths\\n   新的 Path2D API，使用 SVG path data 来初始化 canvas 路径\\n   `var p = new Path2D(\\"M10 10 h 80 v 80 h -80 Z\\");`\\n   表示先移动到点 (M10 10) 然后再水平移动 80 个单位(h 80)，然后下移 80 个单位 (v 80)，接着左移 80 个单位 (h -80)，再回到起点处 (z)\\n\\n### 添加样式和颜色\\n\\n#### 设置颜色\\n\\n1. fillStyle=color\\n   设置图形填充颜色\\n1. strokeStyle=color\\n   设置图形轮廓颜色\\n1. Transparency\\n\\n- 全局透明度：globalAlpha = transparencyValue\\n- 也可以直接用 rgba 设置透明度\\n\\n#### 设置线型\\n\\n1. lineWidth = value\\n   设置线条宽度。\\n1. lineCap = type\\n   设置线条末端样式。\\n1. lineJoin = type\\n   设定线条与线条间接合处的样式。\\n1. miterLimit = value\\n   限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。\\n1. getLineDash()\\n   返回一个包含当前虚线样式，长度为非负偶数的数组。\\n1. setLineDash(segments)\\n   设置当前虚线样式。\\n1. lineDashOffset = value\\n   设置虚线样式的起始偏移量。\\n\\n#### 设置渐变\\n\\n1. `createLinearGradient(x1, y1, x2, y2)`\\n   `createLinearGradient` 方法接受 4 个参数，表示渐变的起点 `(x1,y1)` 与终点 `(x2,y2)`。\\n\\n`var lineargradient = ctx.createLinearGradient(0,0,150,150);`\\n\\n2. `createRadialGradient(x1, y1, r1, x2, y2, r2)`\\n\\n`createRadialGradient` 方法接受 6 个参数，前三个定义一个以 `(x1,y1)` 为原点，半径为 r1 的圆，后三个参数则定义另一个以 `(x2,y2)`为原点，半径为 r2 的圆。\\n\\n`var radialgradient = ctx.createRadialGradient(75,75,0,75,75,100);`\\n\\n> 创建出 `canvasGradient` 对象后，可以用 `gradient.addColorStop(position, color)` 上色。\\n\\n> `addColorStop` 方法接受 2 个参数，`position` 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置。例如，0.5 表示颜色会出现在正中间。`color` 参数必须是一个有效的 CSS 颜色值（如 #FFF， rgba(0,0,0,1)，等等）。\\n\\n#### 设置图案样式 Patterns\\n\\n- createPattern(image, type)\\n  该方法接受两个参数。Image 可以是一个 Image 对象的引用，或者另一个 canvas 对象。Type 必须是下面的字符串值之一：repeat，repeat-x，repeat-y 和 no-repeat。\\n\\n```javascript\\n  var ctx = document.getElementById(\'canvas\').getContext(\'2d\');\\n\\n  // 创建新 image 对象，用作图案\\n  var img = new Image();\\n  img.src = \'https://mdn.mozillademos.org/files/222/Canvas_createpattern.png\';\\n  img.onload = function() {\\n\\n    // 创建图案\\n    var ptrn = ctx.createPattern(img, \'repeat\');\\n    ctx.fillStyle = ptrn;\\n    ctx.fillRect(0, 0, 150, 150);\\n```\\n\\n#### 设置阴影 Shadows\\n\\n1. `shadowOffsetX = float`\\n   shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。\\n1. `shadowOffsetY = float`\\n   shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。\\n1. `shadowBlur = float`\\n   shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。\\n1. `hadowColor = color`\\n   shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。\\n\\n#### 设置填充规则\\n\\n用到 fill（或者 clip 和 isPointinPath ）可以选择一个填充规则，该填充规则根据某处在路径的外面或者里面来决定该处是否被填充\\n\\n1. \\"nonzero\\"\\n1. \\"evenodd\\"\\n\\n### 绘制文本\\n\\n1. fillText(text, x, y [, maxWidth])\\n   在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的.\\n1. strokeText(text, x, y [, maxWidth])\\n   在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的.\\n\\n还有一系列的样式属性：\\n\\n1. `font = value`\\n   当前我们用来绘制文本的样式. 这个字符串使用和 CSS font 属性相同的语法. 默认的字体是 10px sans-serif。\\n1. `textAlign = value`\\n   文本对齐选项. 可选的值包括：start, end, left, right or center. 默认值是 start。\\n1. `textBaseline = value`\\n   基线对齐选项. 可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。\\n1. `direction = value`\\n   文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。\\n\\n以及`measureText()`获取文本宽度，返回一个 TextMetrics 对象的宽度、所在像素，这些体现文本特性的属性。\\n\\n### 操作图片\\n\\n有多种类型元素可以作为图片的源\\n\\n1. `HTMLImageElement`\\n   这些图片是由 Image()函数构造出来的，或者任何的元素\\n1. `HTMLVideoElement`\\n   用一个 HTML 的\\n1. `HTMLCanvasElement`\\n   可以使用另一个   元素作为你的图片源。\\n1. `ImageBitmap`\\n   这是一个高性能的位图，可以低延迟地绘制，它可以从上述的所有源以及其它几种源中生成。\\n\\n#### 基本使用：\\n\\n1. `drawImage(image, x, y, width, height)`\\n\\n其中 image 是 image 或者 canvas 对象，x 和 y 是其在目标 canvas 里的起始坐标。width,height 用来控制缩放\\n\\n2. drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)\\n   第一个参数和其它的是相同的，都是一个图像或者另一个 canvas 的引用。其它 8 个参数，前 4 个是定义图像源的切片位置和大小，后 4 个则是定义切片的目标显示位置和大小。\\n\\n> 过度缩放图像会导致图像模糊或像素化，可以通过使用绘图环境的 imageSmoothingEnabled 属性来控制是否在缩放图像时使用平滑算法。默认值为 true，即启用平滑缩放。也可以通过 imageSmoothingEnabled=false 禁用\\n\\n### 变形\\n\\n#### 状态的保存和恢复\\n\\n1. `save()`\\n   保存画布的所有状态\\n1. `restore()`\\n   restore 用来恢复 canvas 状态\\n\\n#### 变形相关 API\\n\\n1. 移动`translate(x,y)`\\n1. `rotate(angle)`\\n1. `scale(x,y)`\\n1. `transform(a,b,c,d,e,f)`\\n   - `a (m11)`\\n     水平方向的缩放\\n   - `b(m12)`\\n     竖直方向的倾斜偏移\\n   - `c(m21)`\\n     水平方向的倾斜偏移\\n   - `d(m22)`\\n     竖直方向的缩放\\n   - `e(dx)`\\n     水平方向的移动\\n   - `f(dy)`\\n     竖直方向的移动\\n1. `setTransform(a,b,c,d,e,f)`\\n   - 取消了当前变形,然后设置为指定的变形\\n1. `resetTransform()`，字面意思，重置\\n\\n### 合成与裁剪\\n\\n直接看 mdn 效果：[合成与裁剪 mdn](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Compositing)\\n\\n### 基本动画\\n\\n步骤：\\n\\n1. 清空 canvas\\n   除非接下来要画的内容会完全充满 canvas （例如背景图），否则你需要清空所有。最简单的做法就是用 clearRect 方法。\\n1. 保存 canvas 状态\\n   如果你要改变一些会改变 canvas 状态的设置（样式，变形之类的），又要在每画一帧之时都是原始状态的话，你需要先保存一下。\\n1. 绘制动画图形（animated shapes）\\n   这一步才是重绘动画帧。\\n1. 恢复 canvas 状态\\n   如果已经保存了 canvas 的状态，可以先恢复它，然后重绘下一帧。\\n\\n> 使用 setInterval()、setTimeout()、requestAnimationFrame()操控动画\\n\\n> requestAnimationFrame()一般每秒钟执行回调 60 次\\n\\n**具体实践**：[mdn 高级动画](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Advanced_animations)\\n\\n### 像素操作\\n\\n- ImageData 对象存储着 canvas 对象真实的像素数据，包含 width、height、data\\n- 保存图片 toDataURL(imageType,quality)，会创建一个图片分辨率为 96dpi 的数据链接。quality0 到 1\\n\\n---\\n\\n#### 参考\\n\\n- [canvas 教程 MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial)\\n","frontmatter":{"title":"canvas","desc":"canvas","keywords":"设计模式、笔记","date":"2020-02-17T01:01:00.000Z","cover":"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg"},"url":"/front-end/canvas/"},{"src":"---\\ntitle: css\\ndesc: css\\nkeywords: 设计模式、笔记\\ndate: 2020-02-17 01:01:00\\ncover: https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg\\n---\\n\\n# css\\n\\n## BFC 是什么\\n\\n块级格式化上下文，比如浮动元素、绝对定位元素、inline-block 元素、overflow 不为 visible 的元素、flex 元素\\n\\n每个块级上下文都是一个独立的容器\\n\\n解决了什么问题？\\n\\n- 清除浮动\\n- 防止 margin 合并\\n\\n## 清除浮动\\n\\n[清除浮动](https://www.jianshu.com/p/9d6a6fc3e398)\\n\\n- 父元素加上.clearfix\\n\\n```css\\n.clearfix::after {\\n  content: \'\';\\n  display: block;\\n  clear: both;\\n}\\n```\\n\\n- 父元素加上 overflow:hidden 或者 auto，或者设置高度\\n- 添加一个额外的标签并添加 clear:both\\n\\n## 水平居中\\n\\n行内元素：\\n\\n- text-align: center\\n\\n确定宽度的元素：\\n\\n- margin:0 auto 左右居中\\n- 绝对定位加 margin-left:-width/2\\n\\n不确定宽度的元素：\\n\\n- 绝对定位加 translate:-50%\\n- inline-block 元素加 text-align: center\\n- flex 布局\\n\\n## 垂直居中\\n\\n- 纯文本 line-height 等于 height 实现垂直居中\\n- 绝对定位加 margin:auto，子元素设置上下左右为 0\\n- flex 加 margin:auto\\n\\n## 选择器优先级\\n\\ncss3 中\\n\\n1. 选择器越具体，优先级越高\\n2. 相同优先级，出现在后面的覆盖前面的\\n3. 属性后面加!important 优先级最高\\n\\n## 两个 inline-block 元素产生空隙\\n\\n是因为元素排版的时候，元素之间的空白符（空格、回车），字体不为 0 的情况下，空白符占据一定宽度\\n\\n解决方式：\\n\\n1. 将子元素标签的结束符和下一个标签的开始符号写在同一行或把所有子标签写在同一行\\n2. 父元素中设置 font-size:0，在子元素上重置正确的 font-size\\n3. 为子元素设置 float:left\\n\\n## 两种盒模型的区别\\n\\n- content-box，width=width+padding+border\\n- border-box，width=width\\n\\n## css 模块化\\n\\n### 为什么要模块化\\n\\n为了解决 class 命名问题、层级结构不清晰问题、代码难以复用问题、单个 css 庞大的问题\\n\\n### css 模块化的实现方式\\n\\n#### BEM 命名规范\\n\\nBEM: block、element、modifier\\n是一种前端命名方法论，通过规范命名方式实现模块化\\n**规则** ：\\n\\n> - 中划线 ：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号。\\n>   \\\\__ 双下划线：双下划线用来连接块和块的子元素\\n>   _ 单下划线：单下划线用来描述一个块或者块的子元素的一种状态\\n\\n示例\\n\\n```html\\n.form { } .form--theme-xmas { } .form--simple { } .form__input { } .form__submit { }\\n.form__submit--disabled { } //对应的HTML结构如下：\\n<form class=\\"form form--theme-xmas form--simple\\">\\n  <input class=\\"form__input\\" type=\\"text\\" />\\n  <input class=\\"form__submit form__submit--disabled\\" type=\\"submit\\" />\\n</form>\\n```\\n\\n#### css Modules\\n\\n像引入 js 一样去引入 css\\n\\n```css\\n@import \'style.css\' => require(\'./style.css\')\\n@import url(style.css) => require(\'./style.css\')\\n@import url(\'style.css\') => require(\'./style.css\'\\nurl(image.png) => require(\'./image.png\')\\nurl(\'image.png\') => require(\'./image.png\')\\nurl(./image.png) => require(\'./image.png\');\\n```\\n\\n需要配合 css-loader\\n会在打包的时候自动将类名转换成 hash 值，避免了命名冲突\\n使用方法\\n\\n```css\\n.className {\\n  color: green;\\n}\\n/* 编写全局样式 */\\n:global(.className) {\\n  color: red;\\n}\\n\\n/* 样式复用 */\\n.otherClassName {\\n  composes: className;\\n  color: yellow;\\n}\\n\\n.otherClassName {\\n  composes: className from \'./style.css\';\\n}\\n```\\n\\n参考：[css-loader](https://github.com/webpack-contrib/css-loader#url)、[css-modules](https://github.com/css-modules/css-modules)\\n\\n#### css in JS\\n\\n用 js 写 css，是一种编写思想，已经有很多种实现，最具代表性的是 styled-components\\n缺点是不支持预处理器\\n\\n```javascript\\nimport React from \'react\';\\nimport styled from \'styled-components\';\\n\\n// 创建一个带样式的 h1 标签\\nconst Title = styled.h1`\\n  font-size: 1.5em;\\n  text-align: center;\\n  color: palevioletred;\\n`;\\n\\n// 创建一个带样式的 section 标签\\nconst Wrapper = styled.section`\\n  padding: 4em;\\n  background: papayawhip;\\n`;\\n\\n// 通过属性动态定义样式\\nconst Button = styled.button`\\n  background: ${props => (props.primary ? \'palevioletred\' : \'white\')};\\n  color: ${props => (props.primary ? \'white\' : \'palevioletred\')};\\n\\n  font-size: 1em;\\n  margin: 1em;\\n  padding: 0.25em 1em;\\n  border: 2px solid palevioletred;\\n  border-radius: 3px;\\n`;\\n\\n// 样式复用\\nconst TomatoButton = styled(Button)`\\n  color: tomato;\\n  border-color: tomato;\\n`;\\n\\n<Wrapper>\\n  <Title>Hello World, this is my first styled component!</Title>\\n  <Button primary>Primary</Button>\\n</Wrapper>;\\n```\\n\\n![css-module.png](./images/css-module.png)\\n参考：[css 模块化](https://juejin.im/post/6844904034281734151#heading-5)\\n\\n## css 布局方案\\n\\n### 正常流布局\\n\\n浏览器默认的布局方式，按照 HTML 的书写排列\\n\\n### display\\n\\n`display:inline/block/inline-block`，改变元素的行为方式\\n\\n### flex 弹性盒\\n\\n用于一维布局     \\n基本使用方法：\\n\\n```css\\ndisplay:flex｜inline-flex;定义容器\\nflex-direction:row｜row-reverse｜column｜column-reverse;定义主轴方向\\njustify-content:stretch｜flex-start｜flex-end｜center｜space-around｜space-between;主轴对齐方式\\nalign-items:strech｜flex-start｜flex-end｜center;交叉轴方向的对齐方式\\nflex-wrap:nowrap｜wrap;多行flex\\nflex-grow:n;控制元素放大\\nflex-shrink:n;控制元素收缩\\nflex-basis:;定义元素的空间大小\\nflex:1 1 0%;是上面三个属性的缩写\\n```\\n\\n### grid 网格\\n\\n基于网格的二维布局\\n基本使用方法\\n\\n```css\\n父元素{\\n  display:grid｜inline-grid;创建容器\\n  grid-template-columns:80px auto 100px;几个值就表示几列，可依次设置从左至右的每列的尺寸\\n  grid-template-rows:25% 100px auto 60px;几个值就表示几行，依次设置高度\\n  grid-template-columns: repeat(24, 40px [col-start]);可以用repeat简化\\n  还可以用fr表示分数\\n  grid-template-columns: 1fr 1fr 1fr;\\n  grid-gap:10px 10px;设置横竖间隙\\n  justify-items: stretch | start | end | center;水平呈现方式\\n  align-items: stretch | start | end | center;垂直呈现方式\\n  justify-content: stretch | start | end | center | space-between | space-around | space-evenly;\\n  网格元素的水平分布方式\\n  align-content: stretch | start | end | center | space-between | space-around | space-evenly;\\n  网格元素的垂直分布方式\\n}\\n子元素{\\n  grid-column-start, grid-column-end, grid-row-start和grid-row-end设置水平、垂直方向起止位置\\n  grid-area是grid-row-start, grid-column-start, grid-row-end 以及 grid-column-end属性的缩写，以及额外支持grid-template-areas设置的网格名称\\n\\tjustify-self: stretch | start | end | center;单个网格元素的水平对齐方式\\n  align-self: stretch | start | end | center;单个网格元素的垂直对齐方式\\n\\n}\\n```\\n\\n还可以用 grid-template-areas 划分区域\\n\\n```html\\n<div class=\\"container\\">\\n  <div class=\\"putao\\"></div>\\n  <div class=\\"longxia\\"></div>\\n  <div class=\\"yangyu\\"></div>\\n  <div class=\\"xigua\\"></div>\\n</div>\\n```\\n\\n```css\\n.container {\\n  grid-template-columns: 1fr 1fr 1fr;\\n  grid-template-rows: 1fr 1fr 1fr 1fr;\\n  grid-template-areas:\\n    \'葡萄 葡萄 葡萄\'\\n    \'龙虾 养鱼 养鱼\'\\n    \'龙虾 养鱼 养鱼\'\\n    \'西瓜 西瓜 西瓜\';\\n}\\n.putao {\\n  grid-area: 葡萄;\\n}\\n.longxia {\\n  grid-area: 龙虾;\\n}\\n.yangyu {\\n  grid-area: 养鱼;\\n}\\n.xigua {\\n  grid-area: 西瓜;\\n}\\n```\\n\\n**注意**  在 Grid 布局中，`float`，`display:inline-block`，`display:table-cell`，`vertical-align`以及`column-*`这些属性和声明对 grid 子项是没有任何作用的。\\n\\n参考：[张鑫旭-grid](https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/)\\n\\n### float 浮动\\n\\n设置元素浮动，移出正常文档流，周围元素会环绕这个元素\\n\\n```css\\n/* Keyword values */\\nfloat: left;\\nfloat: right;\\nfloat: none;\\nfloat: inline-start;\\nfloat: inline-end;\\n/* Global values */\\nfloat: inherit;\\nfloat: initial;\\nfloat: unset;\\n```\\n\\n但当包含元素的高度小于 float 元素的高度时，会出现高度塌陷的问题\\n清除浮动：\\n原理就是 clear 可以 left ｜ right ｜ both 方向上不允许存在浮动元素\\n但是如果浮动元素在最下面，依然会高度塌陷，为了解决这个问题，就在浮动元素下面加上一个空的 div，父元素就会一起包裹进去\\n\\n```css\\n.clearfix:after {\\n  display: block;\\n  content: \'\';\\n  clear: both;\\n}\\n```\\n\\n参考：[清除浮动的原理](https://juejin.cn/post/6844903504545316877)\\n\\n### position 定位\\n\\n不是主要用来做布局的，主要是微调\\n\\n- static。默认文档流\\n- relative。相对定位，相对原本的位置移动，保留原本位置\\n- absolute。绝对定位，相对于最近的设置了定位的祖先元素\\n- fixed，固定定位。类似 absolute，但是是相对于浏览器视口\\n- sticky。粘性定位，在没有到设置位置的时候表现在正常文档流中，到了设置位置后就停止和 fixed 表现一样\\n\\n### 表格布局\\n\\n老方法，过时了\\n\\n```html\\n<form>\\n  <p>First of all, tell us your name and age.</p>\\n  <div>\\n    <label for=\\"fname\\">First name:</label>\\n    <input type=\\"text\\" id=\\"fname\\" />\\n  </div>\\n  <div>\\n    <label for=\\"lname\\">Last name:</label>\\n    <input type=\\"text\\" id=\\"lname\\" />\\n  </div>\\n  <div>\\n    <label for=\\"age\\">Age:</label>\\n    <input type=\\"text\\" id=\\"age\\" />\\n  </div>\\n</form>\\n```\\n\\n```css\\nhtml {\\n  font-family: sans-serif;\\n}\\n\\nform {\\n  display: table;\\n  margin: 0 auto;\\n}\\n\\nform div {\\n  display: table-row;\\n}\\n\\nform label,\\nform input {\\n  display: table-cell;\\n  margin-bottom: 10px;\\n}\\n\\nform label {\\n  width: 200px;\\n  padding-right: 5%;\\n  text-align: right;\\n}\\n\\nform input {\\n  width: 300px;\\n}\\n\\nform p {\\n  display: table-caption;\\n  caption-side: bottom;\\n  width: 300px;\\n  color: #999;\\n  font-style: italic;\\n}\\n```\\n\\n### 多列布局\\n\\n多列显示\\n\\n```css\\ncolumn-count:;设置多少列\\ncolumn-width:;设置列的宽度\\n```\\n\\n## css3.0 常用属性\\n\\n参考：[css3 属性罗列](https://juejin.cn/post/6844903925234024462)\\n[box-shadow 调试](https://www.cssmatic.com/box-shadow)\\n[gradient 调试](https://cssgradient.io/)\\n\\n## sass 和 less\\n\\n都是 css 预处理器，都可以通过编译转为普通 css 文件\\n\\nsass 是缩排语法，像这样\\n\\n```css\\n$font-stack:    Helvetica, sans-serif\\n$primary-color: #333\\n\\nbody\\n  font: 100% $font-stack\\n  color: $primary-color\\n```\\n\\n由于相较于 css，不太直观，并且不能直接写 css，于是 sass3 变成了 scss，兼容原本的 css 写法\\nscss 像这样\\n\\n```css\\n$font-stack: Helvetica, sans-serif;\\n$primary-color: #333;\\nbody {\\n  font: 100% $font-stack;\\n  color: $primary-color;\\n}\\n```\\n\\n基本用法\\n\\n|      | sass/scss                  | less    |\\n| ---- | -------------------------- | ------- |\\n| 变量 | $h:5px;                    | @h:5px; |\\n| 混合 | @mixin xxx\\\\{some code...\\\\} |         |\\n\\na{\\n  @include xxx;\\n} | .bordered {\\nborder-top: dotted 1px black; border-bottom: solid 2px black; }\\na {\\ncolor: red;\\n.bordered();\\n} |\\n| 嵌套 | #main p {\\ncolor: #00ff00;\\nwidth: 97%;\\n.redbox {\\ncolor: #000000;\\n}\\n}基本相似 | #header {\\n  color: black;\\n  .navigation {\\n    font- size: 12px;\\n  }\\n  .logo {\\n    width: 300px;\\n  }\\n  $:after{}\\n}\\n还有@media 等的嵌套 |\\n| 运算 | +、-、_、/、% | 支持+、-、_、/\\n@conversion-1: 5cm + 10mm; |\\n| 函数 | 也有 lighten、darken 等函数 | percentage 小数转为分数 saturate 增加颜色饱和度\\nlighten 亮度降低 |\\n| 导入 | 能导入 sass 或者 scss，但是以下情况，不导入\\n\\n- 文件拓展名是 `.css`；\\n- 文件名以 `http://` 开头；\\n- 文件名是 `url()`；\\n- `@import` 包含 media queries。\\n\\n  比如`@import \\"library\\";` // `library.less`\\n\\n  `@import \\"typo.css\\";`\\n  导入 less 文件可以省略后缀\\n\\n## flex 子元素宽度超出的问题\\n\\nflex:1 的子元素，存在内容超出的现象\\n\\n原因是 flex:1 并不决定子元素的宽度，它只是规定了如果父元素有多余空间，以怎样的比例去分配剩余空间，并不会对子元素原本的就占据的空间做处理\\n\\n解决办法：\\n\\n1. 对于内容超出的 `flex` 子元素设置 `width:0` 或者 `min-width:0`,让 flex 元素的宽度完全由 `flex:1` 来分配。推荐使用 `min-width:0`，`width:0` 在子元素设置了宽度时，内容仍可超出\\n2. 设置 `overflow` 属性不为 `visible`，最推荐的方法\\n\\n**min-width 的原理：** 浏览器默认为 `flex` 容器的子元素设置了 `min-width: auto;min-height: auto`, 即 `flex` 子元素的最小宽度高度不能小于其内容的宽高, 在规范里的表述是:`A flex item cannot be smaller than the size of its content along the main axis.` 所以通过设置 `min-width: 0`, 覆盖这个默认设置, `flex-shrink` 属性就能生效了\\n\\n- html - Why don\'t flex items shrink past content size? - Stack Overflow\\n- [min-width:0 原理](https://www.w3.org/TR/css-flexbox-1/#min-size-auto)\\n\\n<script setup>\\nimport FlexDemo from \'./flex-demo.vue\'\\n<\/script>\\n\\n<FlexDemo/>\\n","frontmatter":{"title":"css","desc":"css","keywords":"设计模式、笔记","date":"2020-02-17T01:01:00.000Z","cover":"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg"},"url":"/front-end/css/"},{"src":"---\\ntitle: git\\ndesc: 《JavaScript设计模式》、《大话设计模式》笔记\\nkeywords: 设计模式、笔记\\ndate: 2020-02-17 01:01:00\\ncover: https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg\\n---\\n\\n# git\\n\\n## 本地操作\\n\\n1. 配置\\n\\n```\\ngit config --global user.name 你的英文名\\ngit config --global user.email 你的邮箱\\ngit config --global push.default simple\\ngit config --global core.quotepath false\\ngit config --global core.editor \\"code --wait\\"\\ngit config --global core.autocrlf input\\n```\\n\\n2. 常用操作\\n\\n```javascript\\ngit init //初始化git本地仓库\\ngit add xxx.xxx  //指定将要提交的文件\\ngit add .  //提交全部文件，可以创建一个.gitIgnore写入不想提交的文件和文件夹\\ngit commit -m \'提交理由\'  // 没有空格不加引号也可，参数-v可以用vscode提交，可以顺便查看修改的具体代码\\ngit status //查看文件变动\\ngit log //查看历史提交，需要倒着看\\ngit reset --hard 提交号前六位  //跳版本！！\\ngit reset --hard HEAD^ //跳到上一个版本，HEAD^^跳到上上个版本\\ngit reflog //查看包括跳版本的所有历史记录\\ngit checkout -- xxx.xxx //恢复到最近的一次commit或者git add的状态\\ngit cherry-pick 提交号1 提交号2 ... // 复制选中的提交号到当前分支\\n```\\n\\n3. 分支操作\\n\\n```javascript\\ngit branch x  //创建分支，是基于本地仓库的最新一次commit，创建一个新提交\\ngit checkout x  //切换分支\\ngit checkout -b x //创建分支并切换\\ngit checkout master  //切换到主分支\\ngit branch //查看当前分支\\ngit merge x //合并分支，需要先到达主分支\\ngit branch -d x  //删除分支\\n```\\n\\n## 远程仓库\\n\\n1. 提交到 github\\n   1. 创建 github 仓库，复制 ssh 地址\\n   1. 在本地添加远程仓库地址`git remote add orign git@xxx`\\n   1. 推送本地 master 分支到远程 origin 的 master 分支`git push -u origin master`(提交过一次后，之后可以直接 git push , origin 是可以自己命名的)\\n2. 下载代码到本地\\n   `git clone git@xxx`\\n\\n## 其他\\n\\n```javascript\\ngit rebase  // 合并提交历史\\ngit stash //代码写了一半不想提交，可以将add过的文件先暂存起来，得到一个干净的工作区\\ngit stash pop //显示暂存的文件\\n```\\n","frontmatter":{"title":"git","desc":"《JavaScript设计模式》、《大话设计模式》笔记","keywords":"设计模式、笔记","date":"2020-02-17T01:01:00.000Z","cover":"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg"},"url":"/front-end/git/"},{"src":"---\\ntitle: html\\ndesc: 《JavaScript设计模式》、《大话设计模式》笔记\\nkeywords: 设计模式、笔记\\ndate: 2020-02-17 01:01:00\\ncover: https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg\\n---\\n\\n# html\\n\\n## 语义化\\n\\n- 是什么？是一种写 HTML 标签的方法论\\n- 怎么做？根据内容结构选择合适的标签，内容语义化+代码语义化\\n- 解决了什么问题？明确了书写规范，便于开发者阅读和写出更优雅的代码结构的同时，方便搜索引擎检索\\n\\n注意点：\\n\\n- 尽可能少用无意义的 div 和 span\\n- 语义不明显时，div 和 p 选 p，p 在默认情况下有上下间距，对兼容特殊终端有利\\n- 不使用纯样式标签，如：b、font，改用 css 设置\\n- 表格，标题用 caption、表头用 thead、主体用 tbody、尾部用 tfoot，表头用 th、单元格用 td\\n- 表单域用 fieldset 标签包起来，用 legend 标签说明表单用途\\n- input 标签的说明文本需要使用 label 标签，并通过为 input 设置 id 属性，在 label 标签中设置 for=xxx 来让说明文本和相对应的 input 关联起来\\n\\n## HTML5 新标签和新特性\\n\\n新标签：\\n\\n- 文章相关的：header、main、footer、nav、section、article、figure、mark\\n- 多媒体相关的：video、audio、svg、canvas\\n- 表单相关的：type=email、type=tel\\n\\n新特性：\\n\\n主要是关于图像、位置、存储、多任务等功能的增加\\n\\n- 拖拽释放的 api\\n- 语义化的标签\\n- 地理 api、音频、视频 api、画布 api\\n- localStorage、sessionStorage\\n- 表单控件，calendar、date、time、email、url、search\\n\\n## title 和 alt 属性\\n\\n- 两个属性都是当鼠标滑动到元素上的时候显示\\n- alt 是 img 的特有属性，是图片内容的等价描述，图片无法显示的时候显示文字\\n- title 可以用在除了 base、baseFont、head、html、meta、param、script、title 之外的所有标签，是对 dom 元素的一种类似注释说明\\n\\n## HTML 全局属性\\n\\n- class\\n- data-\\\\*增加自定义属性\\n- draggable 元素可拖拽\\n- id\\n- lang\\n- style\\n- title 元素相关建议信息\\n\\n## Canvas 和 Svg 的区别\\n\\n- canvas 用笔刷来绘制 2d 图形\\n- svg 用标签来绘制不规则矢量图\\n- 相同点：都是主要用来画 2d 图形的\\n- 不同点：canvas 是位图，放大会失真，svg 是矢量图\\n- 不同点：svg 节点过多，渲染性能不如 canvas，但是 canvas 写起来复杂\\n- 不同点：svg 支持分层和事件，与普通 html 标签相似，canvas 不支持，但是可以模拟实现\\n- canvas 无法对已经绘制的图像进行修改，每次更改都是重新绘制，svg 可以获取到标签进行操作\\n\\n## 头部元素\\n\\n```html\\n<title>可以添加文档标题\\n<meta>\\n```\\n\\n- charset 指定字符集\\n- name 制定 meta 元素的类型，说明了包含的信息\\n- content 指定了实际的元数据内容\\n\\n## a 标签\\n\\n利用`<a/>`标签进行下载时，建议写明文件的后缀，浏览器会将 download 中的最后一个`.`符号识别为文件后缀，如果文件名中含有`.`会导致下载的文件后缀不正确。\\n\\n需要注意的是，`/`、`\\\\`会被浏览器自动转换成`_`，`.`则不会转换\\n","frontmatter":{"title":"html","desc":"《JavaScript设计模式》、《大话设计模式》笔记","keywords":"设计模式、笔记","date":"2020-02-17T01:01:00.000Z","cover":"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg"},"url":"/front-end/html/"},{"src":"<script setup lang=\\"ts\\">\\nimport XmlAbort from \'./demos/XmlAbort.vue\'\\n<\/script>\\n\\n### 数据类型\\n\\n- 写出下面运行的结果,解释原因\\n\\n  ```javascript\\n  1 + \'1\';\\n  // 结果为11，数字与字符串相加，会把数字转为字符串，再相加\\n  \'a\' + +\'b\';\\n  // 结果为aNaN,+\'b\'结果为NaN，NaN与字符串相加，转为字符串，所以是aNaN\\n  ```\\n\\n- 如何让 (a == 1 && a == 2 && a == 3) 的值为 true?\\n\\n```js\\nlet i = 1;\\nNumber.prototype.valueOf = function () {\\n  return i++;\\n};\\nconst a = new Number(1);\\n```\\n\\n- 写出下面运行的结果,解释原因\\n\\n  ```javascript\\n  function test(person) {\\n    person.age = 26;\\n    person = {\\n      name: \'张三\',\\n      age: 12\\n    };\\n    return person;\\n  }\\n  const p1 = {\\n    name: \'李四\',\\n    age: 19\\n  };\\n  const p2 = test(p1);\\n  console.log(p1);\\n  // -> {name:\'张三\',age:26}\\n  // 函数内复制了p1的副本到局部变量person，与p1指向同一个保存引用的堆内存地址，因此age被改为26\\n  console.log(p2);\\n  // -> {name:\'李四\',age:12}\\n  // 函数内部对person变量重新赋值，指向了新的堆内存地址，最后return出来的person是新赋值的person\\n  ```\\n\\n- 实现两个大数相加\\n\\n  ```javascript\\n  let a = \'123456789012345678\';\\n  let b = \'876543210987654321\';\\n\\n  function add(a, b) {\\n    const maxLength = Math.max(a.length, b.length);\\n    a !== maxLength && (a = a.padStart(maxLength, 0));\\n    b !== maxLength && (b = b.padStart(maxLength, 0));\\n    let carryFlag = false,\\n      result = \'\';\\n    for (let i = maxLength - 1; i >= 0; i--) {\\n      let sum = parseInt(a[i]) + parseInt(b[i]);\\n      carryFlag && sum++ && (carryFlag = false);\\n      if (sum / 10 >= 1) {\\n        carryFlag = true;\\n        result = (sum % 10) + result;\\n      } else result = sum + result;\\n    }\\n    return carryFlag ? 1 + result : result;\\n  }\\n  add(a, b); // \'999999999999999999\'\\n  ```\\n\\n- 手写类型判断函数\\n\\n```javascript\\nfunction myTypeOf(params) {\\n  const res = Object.prototype.toString.call(params);\\n  return res.slice(1, -1).split(\' \')[1].toLowerCase();\\n}\\n```\\n\\n- 手写深拷贝函数\\n\\n```js\\nfunction myTypeOf(params) {\\n  const res = Object.prototype.toString.call(params);\\n  return res.slice(1, -1).split(\' \')[1].toLowerCase();\\n}\\nfunction forEach(ary, fn) {\\n  let index = 0;\\n  const length = ary.length;\\n  while (index < length) {\\n    fn(ary[index], index);\\n    index++;\\n  }\\n}\\n\\nfunction deepClone(target, map = new WeakMap()) {\\n  if ([\'object\', \'array\'].includes(myTypeOf(target))) {\\n    const isObj = myTypeOf(target) === \'object\';\\n    let result = isObj ? {} : [];\\n    if (map.get(target)) return map.get(target);\\n    map.set(target, result);\\n    const keys = isObj ? Object.keys(target) : target;\\n    forEach(keys, (value, key) => {\\n      if (isObj) key = value;\\n      result[key] = deepClone(target[key], map);\\n    });\\n    return result;\\n  } else return target;\\n}\\n```\\n\\n### 作用域与闭包\\n\\n1. 下面代码的输出结果\\n\\n```js\\nvar a = 20;\\n\\nfunction foo() {\\n  if (!a) {\\n    a = 100;\\n  }\\n\\n  var a = 10;\\n\\n  return a;\\n}\\n\\nconsole.log(foo());\\n```\\n\\n解：输出为 10，因为 js 采用词法作用域，函数内部的作用域在函数定义时就确定了，优先查找并使用函数内部新创建的 a 变量\\n\\n1. 以下代码在执行过程中是否存在闭包\\n\\n```js\\nfunction outer() {\\n  var a = 1;\\n\\n  function inner() {\\n    var b = 2;\\n    console.log(b);\\n  }\\n\\n  return inner;\\n}\\n\\nouter()();\\n```\\n\\n解：不存在，虽然 inner 函数在 outer 函数的作用域链里，但是没有引用外部变量，未形成闭包\\n\\n1. 以下变种代码是否存在闭包，并且说出 inner 函数执行时的作用域链\\n\\n```diff\\nfunction outer() {\\n  var a = 1;\\n\\n  function inner() {\\n    var b = 2;\\n-    console.log(b);\\n+    console.log(a);\\n  }\\n\\n  return inner;\\n}\\n\\nouter()();\\n```\\n\\n解：存在，inner 函数的 scopeChain:[inner,outer,global]\\n\\n1. 以下代码是否存在闭包\\n\\n```js\\nfunction outer() {\\n  var a = 1;\\n\\n  function inner() {\\n    console.log(a);\\n  }\\n\\n  inner();\\n}\\n\\nouter();\\n```\\n\\n解：存在，内部 inner 函数引用了其外部作用域链上的变量，形成闭包，但由于没有 return 出来，在执行完毕后，闭包会被回收\\n\\n### 原型链\\n\\n- 手动实现 new 函数\\n\\n```js\\nfunction New(func) {\\n  // 创建一个中间对象实例\\n  const res = {};\\n  // 将实例的原型指向构造函数的原型\\n  if (func.prototype !== null) {\\n    res.__proto__ = func.prototype;\\n  }\\n  // 将构造函数的this指向新创建的中间对象\\n  const ret = func.apply(res, Array.prototype.slice.call(arguments, 1));\\n\\n  // 如果构造函数有明确指定返回对象，当返回结果类型是object或者function时，返回对象，否则返回指定的结果\\n  if ((typeof ret === \'object\' || typeof ret === \'function\') && ret !== null) {\\n    return ret;\\n  }\\n  return res;\\n}\\n```\\n\\n- 手动实现 `instanceof` 的功能\\n\\n```js\\nfunction myInstanceof(instance, target) {\\n  const instanceProto = instance.__proto__,\\n    targetProto = target.prototype;\\n  if (!instanceProto) return false;\\n  if (instanceProto === targetProto) return true;\\n  else return myInstanceof(instanceProto, target);\\n}\\n```\\n\\n### this、闭包\\n\\n- 写出下面运行的结果\\n\\n  ```javascript\\n  var name = \'window\';\\n  var person1 = {\\n    name: \'person1\',\\n    foo1: function () {\\n      console.log(this.name);\\n    },\\n    foo2: () => console.log(this.name),\\n    foo3: function () {\\n      return function () {\\n        console.log(this.name);\\n      };\\n    },\\n    foo4: function () {\\n      return () => {\\n        console.log(this.name);\\n      };\\n    }\\n  };\\n  var person2 = { name: \'person2\' };\\n\\n  person1.foo1(); // \'person1\'，this指向调用foo1的person1\\n  person1.foo1.call(person2); // \'person2\'，通过call指定foo1的this为person2\\n\\n  person1.foo2(); // \'window\'，箭头函数的this由所在的作用域决定，var person不会创建作用域，因此指向全局作用域window\\n  person1.foo2.call(person2); // \'window\'，箭头函数的this在声明时就已经确定，无法被call、apply改变\\n\\n  person1.foo3()(); // \'window\'，person1.foo3()返回了内部函数，调用时是在全局作用域\\n  person1.foo3.call(person2)(); // \'window\'，内部函数的调用依然是在全局作用域\\n  person1.foo3().call(person2); // \'person2\'，改变了内部函数的this\\n\\n  person1.foo4()(); // \'person1\'，内部箭头函数的this即foo4的作用域的this\\n  person1.foo4.call(person2)(); // \'person2\'，改变了foo4的this\\n  person1.foo4().call(person2); // \'person1\'，箭头函数不会被改变this\\n  ```\\n\\n- 写出下面运行的结果\\n\\n  ```javascript\\n  var name = \'window\';\\n  function Person(name) {\\n    this.name = name;\\n    this.foo1 = function () {\\n      console.log(this.name);\\n    };\\n    this.foo2 = () => console.log(this.name);\\n    this.foo3 = function () {\\n      return function () {\\n        console.log(this.name);\\n      };\\n    };\\n    this.foo4 = function () {\\n      return () => {\\n        console.log(this.name);\\n      };\\n    };\\n  }\\n  var person1 = new Person(\'person1\');\\n  var person2 = new Person(\'person2\');\\n\\n  person1.foo1(); // \'person1\'，构造函数的this指向实例对象\\n  person1.foo1.call(person2); // \'person2\'，改变this指向\\n\\n  person1.foo2(); // \'person1\'，箭头函数的this声明时已确定，指向实例\\n  person1.foo2.call(person2); // \'person1\'，箭头函数不会被call改变this\\n\\n  person1.foo3()(); // \'window\'，内部函数先返回再执行，this指向window\\n  person1.foo3.call(person2)(); // \'window\'，函数的this在被调用时确定，先返回了函数，再执行，指向window\\n  person1.foo3().call(person2); // \'person2\'，指定了内部函数的this\\n\\n  person1.foo4()(); // \'person1\'，内部箭头函数的this即foo4的this，指向实例\\n  person1.foo4.call(person2)(); // \'person2\'，指定的foo4的this即内部箭头函数的this\\n  person1.foo4().call(person2); // \'person1\'，无法指定箭头函数的this\\n  ```\\n\\n- 写出下面运行的结果\\n\\n  ```javascript\\n  function foo() {\\n    var myName = \'章三\';\\n    let test1 = 1;\\n    const test2 = 2;\\n    var innerBar = {\\n      getName: function () {\\n        console.log(test1);\\n        return myName;\\n      },\\n      setName: function (newName) {\\n        myName = newName;\\n      }\\n    };\\n    return innerBar;\\n  }\\n  var bar = foo();\\n  bar.setName(\'李四\');\\n  bar.getName(); // 1\\n  console.log(bar.getName()); // 1 \'李四\'，存在闭包\\n  ```\\n\\n### 事件循环\\n\\n注意点：\\n1、`promise.then` 会将状态持续传递下去，除非抛出错误或者 `return` 了 `Promise.reject`\\n2、没有显示返回值的函数默认返回 `undefined`，这同样会将`.then` 返回的 `promise` 状态置为 `fulfilled`,同样能将`.then`中的回调放入微任务队列\\n3、同步任务优先、异步任务挂起，处理顺序根据任务队列情况而定，宏任务优先级低，只有微任务队列清空才会去拿一个宏任务出来执行\\n4、PromiseA+规定当 then 中参数不为函数时，必须忽略，表现在.then 中，会原样返回 promise 结果\\n\\n- 写出下面运行的结果\\n\\n  ```javascript\\n  Promise.resolve(console.log(0))\\n    .then(() => {\\n      console.log(1);\\n      Promise.resolve(console.log(5))\\n        .then(() => console.log(3))\\n        .then(() => console.log(4))\\n        .then(() => console.log(6));\\n    })\\n    .then(() => console.log(2))\\n    .then(() => console.log(7));\\n\\n  // 0、1、5、3、2、4、7、6\\n  /* \\n  script开始\\n  第一行的resolve同步执行 log 0，然后主线程直接执行到后续的第一个then，其中的回调直接放入微任务队列\\n  此时script中同步任务执行完毕，主线程空闲，开始处理微任务，log 1\\n  同步执行Promise.resolve,log 5，.then，当前上下文中同步任务执行完毕，将log 3 放入微任务队列，任务挂起\\n  此时当前上下文中同步任务执行完毕，没有显式返回，相当于resolve，执行外层第二个.then，把log 2 放入微任务队列，任务挂起，此时没有同步任务，主线程去执行微任务队列，log 3\\n  执行完后，return undefined，将后面log 4放入微任务队列，任务挂起\\n  没有同步任务，主线程去处理微任务，log 2，执行完成后return undefined，将后面log 7放入微任务\\n  没有同步任务，主线程去处理微任务，log 4，完成后返回undefined，将后面log 6放入微任务队列，任务挂起\\n  没有同步任务，主线程去处理微任务，log 7\\n  现在只剩下微任务队列里还剩一个log 6，执行log 6\\n  */\\n  ```\\n\\n- 写出下面运行的结果\\n\\n  ```javascript\\n  const first = () =>\\n    new Promise((resolve, reject) => {\\n      console.log(3);\\n      let p = new Promise((resolve, reject) => {\\n        console.log(7);\\n        setTimeout(() => {\\n          console.log(5);\\n          resolve(6);\\n          console.log(p);\\n        }, 0);\\n        resolve(1);\\n      });\\n      resolve(2);\\n      p.then(arg => {\\n        console.log(arg);\\n      });\\n    });\\n  first().then(arg => {\\n    console.log(arg);\\n  });\\n  console.log(4);\\n\\n  // 3、7、4、1、2、5、promise<fulfilled，1>\\n  /*\\n   script开始\\n   执行first函数，同步执行log 3\\n   同步执行new Promise，log 7，setTimeout将回调分发至宏任务队列，任务挂起，主线程往下执行resolve(1)\\n   log 1进入微任务队列\\n   执行resolve(2)，log 2 放入微任务队列\\n   同步执行p.then挂起，执行first后面的.then 挂起\\n   主线程同步执行log 4，同步任务执行完毕\\n   执行微任务队列，依次log 1、log 2\\n   微任务全部执行完毕，拿一个宏任务出来执行，log 5\\n   下一步resolve 6 没用，Promise A+ 中说明不可改变已经处理完毕的promise状态\\n   最后一步log p，是一个已经被置为fulfilled的promise\\n  */\\n  ```\\n\\n- 写出下面运行的结果\\n\\n  ```javascript\\n  const async1 = async () => {\\n    console.log(\'async1\');\\n    setTimeout(() => {\\n      console.log(\'timer1\');\\n    }, 2000);\\n    await new Promise(resolve => {\\n      console.log(\'promise1\');\\n    });\\n    console.log(\'async1 end\');\\n    return \'async1 success\';\\n  };\\n  console.log(\'script start\');\\n  async1().then(res => console.log(res));\\n  console.log(\'script end\');\\n  Promise.resolve(1)\\n    .then(2)\\n    .then(Promise.resolve(3))\\n    .catch(4)\\n    .then(res => console.log(res));\\n  setTimeout(() => {\\n    console.log(\'timer2\');\\n  }, 1000);\\n  // script start、async1、promise1、script end、1、timer2、timer1\\n  /* \\n  同步执行script start\\n  执行 async1，log async1\\n  setTimeout 放入宏任务队列，异步任务挂起，执行下一个 new Promise，log promise1,没有resolve，挂起\\n  后续的log async1 success和script end其实是在.then中，但是这个promise没有被resolve，不会放入微任务队列，不会执行后续代码\\n  执行async1后的.then，放入微任务队列，挂起，执行log script end\\n  执行Promise.resolve(1).then ，不是函数，忽略，下一步.then执行，参数不是函数，忽略,catch(4)不是函数，忽略\\n  下一步执行.then，放入log res 放入微任务队列（即log 1）\\n  执行setTimeout，放入宏任务队列，挂起，主线程处理微任务，log 1\\n  最后依次执行宏任务队列，根据等待时间的快慢，log timer2、timer 1 \\n  */\\n  ```\\n\\n- 写出下面运行的结果\\n\\n  ```javascript\\n  const p1 = new Promise(resolve => {\\n    setTimeout(() => {\\n      resolve(\'resolve3\');\\n      console.log(\'timer1\');\\n    }, 0);\\n    resolve(\'resolve1\');\\n    resolve(\'resolve2\');\\n  })\\n    .then(res => {\\n      console.log(res);\\n      setTimeout(() => {\\n        console.log(p1);\\n      }, 1000);\\n    })\\n    .finally(res => {\\n      console.log(\'finally\', res);\\n    });\\n  // resolve1、finally,undefined、timer1、promise<fulfilled,undefined>\\n  /*\\n    执行new Promise，setTimeout放入宏任务队列\\n    resolve1放入微任务队列\\n    resolve2放入微任务队列\\n    任务挂起，执行.then,挂起\\n    无同步任务，执行微任务队列，log resolve1，resolve2没用\\n    setTimeout放入宏任务队列\\n    无同步任务，执行.finally，放入微任务队列，挂起\\n    无同步任务，执行微任务队列，log finally，undefined，因为上一个.then没有return，函数默认return undefined\\n    微任务执行完毕，执行宏任务队列，log timer1、promise<fulfilled,undefined>\\n  */\\n  ```\\n\\n### 异步编程\\n\\n1. 实现 sleep 函数，在 n 毫秒之后执行函数，并以函数结果作为返回值(可用 ts 来写)\\n\\n```js\\nfunction sleep(fn, time) {\\n  return new Promise((resolve, reject) => {\\n    setTimeout(() => {\\n      resolve(fn());\\n    }, time);\\n  });\\n}\\n\\nsleep(() => {\\n  return \'执行\';\\n}, 3000).then(res => console.log(res));\\n```\\n\\n2. 实现 Promise.retry\\n\\n   ```js\\n   /**\\n    * 实现 Promise.retry，重试异步函数\\n    * 异步函数执行成功后 resolve 结果，\\n    * 失败后重试，尝试超过一定次数才真正的 reject\\n    */\\n   Promise.retry = function (fn, chance = 1) {\\n     return new Promise(async (resolve, reject) => {\\n       while (chance--) {\\n         try {\\n           resolve(await fn());\\n         } catch (err) {\\n           !chance && reject(err);\\n         }\\n       }\\n     });\\n   };\\n\\n   function doSomething() {\\n     return new Promise((res, reje) => {\\n       setTimeout(() => {\\n         reje(1);\\n       }, 1000);\\n     });\\n   }\\n\\n   Promise.retry(doSomething, 3)\\n     .then(res => console.log(\'success,res\'))\\n     .catch(err => console.log(\'error\', err));\\n   ```\\n\\n3. 手写 promise，使用[promises-aplus-tests](https://github.com/promises-aplus/promises-tests) 进行测试\\n\\n```\\n\\n```\\n\\n1. 信号灯控制器\\n   用异步编程的方式实现一个信号灯（交通灯）控制器，要求：\\n\\n   - 红灯亮 50 秒\\n   - 绿灯亮 60 秒\\n   - 黄灯亮 10 秒\\n   - 次序为 红-绿-黄-红-绿-黄\\n\\n   ```javascript\\n   function red() {\\n     console.log(\'red\');\\n   }\\n   function green() {\\n     console.log(\'green\');\\n   }\\n   function yellow() {\\n     console.log(\'yellow\');\\n   }\\n   // TODO\\n\\n   function red() {\\n     console.log(\'red shining\');\\n   }\\n   function green() {\\n     console.log(\'green shining\');\\n   }\\n   function yellow() {\\n     console.log(\'yellow shining\');\\n   }\\n   ```\\n\\n```js\\nclass TrafficLight {\\n  promisedLights = [];\\n  stopSignal = false;\\n  constructor(lights) {\\n    this.promisedLights = lights.map(({ lighting, duration, color }) => {\\n      return () =>\\n        new Promise((resolve, reject) => {\\n          console.log(`${color} start!`);\\n          lighting();\\n          setTimeout(() => {\\n            if (!this.stopSignal) {\\n              console.log(`${color} end!`);\\n              resolve();\\n            }\\n          }, duration);\\n        });\\n    });\\n  }\\n\\n  async start() {\\n    while (this.promisedLights.length) {\\n      if (this.stopSignal) {\\n        this.promisedLights = [];\\n        break;\\n      }\\n      const light = this.promisedLights.shift();\\n      light && (await light());\\n      this.promisedLights.push(light);\\n      continue;\\n    }\\n  }\\n\\n  stop() {\\n    this.stopSignal = true;\\n  }\\n}\\n\\nconst lights = [\\n  { duration: 5000, lighting: red, color: \'red\' },\\n  { duration: 6000, lighting: green, color: \'green\' },\\n  { duration: 1000, lighting: yellow, color: \'yellow\' }\\n];\\n\\nconst trafficLight = new TrafficLight(lights);\\n\\ntrafficLight.start();\\n\\nsetTimeout(() => trafficLight.stop(), 100000);\\n```\\n\\n2. 实现一个带并发限制的异步调度器 Scheduler，保证同时运行的任务最多有两个\\n\\n```javascript\\nconst scheduler = new Scheduler(2);\\nscheduler.addTask(1, \'1\'); // 1s后输出’1\'\\nscheduler.addTask(2, \'2\'); // 2s后输出’2\'\\nscheduler.addTask(1, \'3\'); // 2s后输出’3\'\\nscheduler.addTask(1, \'4\'); // 3s后输出’4\'\\nscheduler.start();\\n```\\n\\n```js\\nclass Scheduler {\\n  limit = 2;\\n  taskQueue = [];\\n  count = 0;\\n  constructor(limit) {\\n    this.limit = limit;\\n    this.taskQueue = [];\\n  }\\n\\n  addTask(time, value) {\\n    this.taskQueue.push(\\n      () =>\\n        new Promise((resolve, reject) => {\\n          setTimeout(() => {\\n            console.log(value, new Date().getSeconds());\\n            resolve();\\n          }, time * 1000);\\n        })\\n    );\\n  }\\n\\n  start() {\\n    if (this.count < this.limit && this.taskQueue.length) {\\n      const promiseTask = this.taskQueue.shift();\\n      this.count++;\\n      promiseTask().then(() => {\\n        this.count--;\\n        this.start();\\n      });\\n      if (this.count < this.limit) this.start();\\n    }\\n  }\\n}\\n\\nconst scheduler = new Scheduler(2);\\nscheduler.addTask(1, \'1\'); // 1s后输出’1\'\\nscheduler.addTask(2, \'2\'); // 2s后输出’2\'\\nscheduler.addTask(1, \'3\'); // 2s后输出’3\'\\nscheduler.addTask(1, \'4\'); // 3s后输出’4\'\\nconsole.log(\'start\', new Date().getSeconds());\\n\\nscheduler.start();\\n```\\n\\n### axios cancelToken 原理\\n\\ncancelToken 是 abortController 的自行实现\\n\\nXMLHttpRequest 提供了 abort 方法可以中止请求（后端是否接收到请求，取决于中止的阶段）\\n\\naxios 中 onCanceled 是真正中止请求的方法，会调用 xhr.abort()且抛出 abort 错误\\n\\ncancelToken 和 abortController 实现思路都是发布订阅机制，请求发起时订阅，抛出的 abort 方法调用时，触发订阅过的请求实例内部的 reject\\n\\n<XmlAbort />\\n\\n```js\\nlet xhr = new XMLHttpRequest();\\nxhr.method = \'GET\';\\nxhr.url = \'https://slowmo.glitch.me/5000\';\\nxhr.open(method, url, true);\\nxhr.send();\\n\\n// Abort the request at a later stage\\nabortButton.addEventListener(\'click\', function () {\\n  xhr.abort();\\n});\\n```\\n\\n```js\\nrequest (configOrUrl, config) {\\n\\n    // 合并配置\\n    config = mergeConfig(this.defaults, config);\\n\\n    // 合并请求头信息\\n    config.headers = AxiosHeaders.concat(contextHeaders, headers);\\n\\n    // 请求拦截器链\\n    const requestInterceptorChain = [];\\n    this.interceptors.request.forEach(function unshiftRequestInterceptors (interceptor) {\\n      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\\n    });\\n\\n    // 响应拦截器链\\n    const responseInterceptorChain = [];\\n    this.interceptors.response.forEach(function pushResponseInterceptors (interceptor) {\\n      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\\n    });\\n\\n    // 执行请求拦截器方法\\n    doRequestInterceptorChain()\\n\\n    // 判断config.cancelToken.reason，也就是是否被取消\\n    throwIfCancellationRequested(config);\\n\\n    // 请求体\\n    let requestData = config.data;\\n\\n    // 创建一个xhr实例\\n    let request = new XMLHttpRequest();\\n\\n    // open xhr\\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\\n\\n    // 请求状态变更处理函数\\n    request.onreadystatechange = function handleLoad () {\\n        //.....\\n    };\\n\\n    // 订阅取消事件\\n    if (config.cancelToken || config.signal) {\\n\\n      // 当token取消了，会执行该函数，也就是abort\\n      onCanceled = cancel => {\\n        if (!request) {\\n          return;\\n        }\\n        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);\\n        request.abort();\\n        request = null;\\n      };\\n\\n      // 此处是用cancelToken的订阅取消事件\\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\\n      // 此处是用signal，也就是AbortConrtroller订阅取消事件\\n      if (config.signal) {\\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener(\'abort\', onCanceled);\\n      }\\n    }\\n\\n    // 真正发送请求\\n    request.send(requestData || null);\\n\\n    // 再次判断config.cancelToken.reason，也就是是否被取消\\n    throwIfCancellationRequested(config);\\n\\n    // 执行返回拦截器\\n    doResponseInterceptorChain()\\n\\n}\\n\\n```\\n\\n[cancelToken 原理](https://juejin.cn/post/7284417436752265277)\\n[abortController 原理](https://cloud.tencent.com/developer/article/2030277)\\n","frontmatter":{},"url":"/front-end/js/FAQ.html"},{"src":"---\\ntitle: js\\ndesc: 《JavaScript设计模式》、《大话设计模式》笔记\\nkeywords: 设计模式、笔记\\ndate: 2020-02-17 01:01:00\\ncover: https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg\\n---\\n\\n# JavaScript\\n\\n## JS 数据类型\\n\\njs 数据类型包括四基两空一对象\\n\\n1. Undefined；\\n2. Null；\\n3. Boolean；\\n4. String；\\n5. Number；\\n6. Symbol；\\n7. bigInt\\n8. Object。\\n\\n引用类型 object 包括\\n\\n- 普通对象 Object\\n- 数组对象 Array\\n- 正则对象 RegExp\\n- 日期对象 Date\\n- 数学函数 Math\\n- 函数对象 Function\\n\\n### 两个空类型\\n\\n#### Undefined\\n\\nUndefined 类型表示未定义，只有一个值 undefined，任何变量在赋值前都是 Undefined 类型，值为 undefined。\\n一般可以用全局变量 undefined 直接使用，但是 js 设计上有个失误，undefined 是个变量而不是关键字\\n即便是 es5 后被改为 read-only，它仍然能被修改\\n\\n```javascript\\nconst test = () => {\\n  var undefined = 5;\\n  console.log(typeof undefined); //輸出number\\n};\\n```\\n\\n使用 void(0)获取 undefined 是更好的做法\\n\\n#### Null\\n\\nNull 表示定义了但是为空，也只有一个值 null，但是 null 是 JS 关键字，所以可以放心使用 null 关键字来获取 null 值\\nnull 更准确的说是一个空对象指针，用 typeof 检测返回的是 object\\nnull 可以用来做对象的初始化\\n\\nnull 不是对象，使用 typeof 会输出 object 是 js 的历史 bug。JS 最初版本使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全 0，导致被误判成 object\\n\\n### Symbol\\n\\nES6 中引入的新原始数据类型，一切非字符串的对象 key 的集合。\\nSymbol 值通过 Symbol 构造函数生成，生成一个 **全局独一无二的值** ，即便使用相同的字符串作为参数，它们也不相等。这个参数相当于一种描述\\n\\n```js\\nlet a1 = Symbol(\'a\');\\nlet a2 = Symbol(\'a\');\\na1 === a2; //false\\n```\\n\\nSymbol 类型可以显式的转换为字符串\\n\\n```javascript\\nconst sym = Symbol(\'xxx\');\\nString(sym);\\nsym.toString();\\n//ES2019提供了一个实例属性description，可以直接返回描述\\nsym.description;\\n```\\n\\n## 作用域和闭包\\n\\n### 闭包的概念\\n\\n- MDN:\\n  - 函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起构成闭包（closure）。也就是说，闭包可以让你**从内部函数访问外部函数作用域**。在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。\\n  - 闭包是**由函数以及声明该函数的词法环境组合而成的**。\\n- 阮一峰老师：\\n  - 闭包就是能够读取其他函数内部变量的函数。可以把闭包简单理解成**定义在一个函数内部的函数**\\n\\n总结下来就是闭包是定义在一个函数内部的函数，可以从内部函数访问外部函数作用域，它是由函数以及声明该函数的词法环境组合而成的，包含被引用变量 or 函数的对象\\n\\n### 变量的作用域\\n\\n首先明确 JavaScript 中变量的作用域。\\n\\n分为局部变量和全局变量\\n\\n```javascript\\n//Javascript的函数，在内部可以直接读取全局变量。\\n\\nvar n = 999;\\nfunction f1() {\\n  alert(n);\\n}\\nf1(); // 999\\n\\n//另一方面，在函数外部自然无法读取函数内的局部变量。\\n\\nfunction f1() {\\n  var n = 999;\\n}\\nalert(n); // error\\n\\n//这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！\\n\\nfunction f1() {\\n  n = 999;\\n}\\nf1();\\nalert(n); // 999\\n\\n/*\\n  于是，为了在外部读取局部变量，我们在函数中再返回一个函数\\n  result 是执行 f1 时创建的 f2 函数实例的引用。f2 的实例维持了一个对它的词法环境（变量 n 存在于其中）的引用。\\n  通过调用这个实例，实现了对函数内部变量的访问\\n  */\\nfunction f1() {\\n  var n = 999;\\n  function f2() {\\n    alert(n);\\n  }\\n  return f2;\\n}\\nvar result = f1();\\nresult(); // 999\\n```\\n\\n#### 作用域链\\n\\n作用域链：内部函数访问外部函数的变量，采用的是链式查找的方式来决定取哪个值，这种结构称之为作用域链。查找时，采用的是**就近原则**。\\n\\n```javascript\\nvar num = 10;\\n\\nfunction fn() {\\n  // 外部函数\\n  var num = 20;\\n\\n  function fun() {\\n    // 内部函数\\n    console.log(num);\\n  }\\n  fun();\\n}\\nfn();\\n//结果为20\\n```\\n\\n## this\\n\\nthis 指的是，调用函数的那个对象。this 永远指向函数运行时所在的对象。\\n\\n1. 以函数的形式调用时，this 永远都是 window。比如 fun();相当于 window.fun();\\n1. 以方法的形式调用时，this 是调用方法的那个对象\\n1. 以构造函数的形式调用时，this 是新创建的那个对象\\n1. 使用 call 和 apply 调用时，this 是指定的那个对象\\n\\n一般的定义函数是运行的时候决定 this 的指向。箭头函数中的 this 是在定义函数的时候绑定，而不是在执行函数的时候绑定。箭头函数没有自己的 this，箭头函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。当对箭头函数使用 call()和 apply()方法时对函数内的 this 没有影响。箭头函数会从自己的作用域链的上一层继承 this\\n\\n## 闭包的用法\\n\\n闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来。这显然类似于面向对象编程。在面向对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。\\n\\n因此，通常你使用只有一个方法的对象的地方，都可以使用闭包。\\n\\n```javascript\\n/*\\n可以利用闭包，将具有不同参数的同一功能分别用一个全局变量引用\\nadd5和add10其实就是闭包function(y)\\n原因就在于makeAdder是function(y)的父函数，而function(y)被赋给了一个全局变量，这导致function(y)始终在内存中，而function(y)的存在依赖于makeAdder，因此makeAdder也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。\\n*/\\nfunction makeAdder(x) {\\n  return function (y) {\\n    return x + y;\\n  };\\n}\\n\\nvar add5 = makeAdder(5);\\nvar add10 = makeAdder(10);\\n\\nconsole.log(add5(2)); // 7\\nconsole.log(add10(2)); // 12\\n\\n/*\\n编程语言中，比如 Java，是支持将方法声明为共有或者私有（public、private）的，即它们只能被同一个类中的其它方法所调用。\\n而 JavaScript 没有这种原生支持，但我们可以使用闭包来模拟私有方法。这种方式可称为模块模式\\n*/\\nvar Counter = (function () {\\n  var privateCounter = 0;\\n  function changeBy(val) {\\n    privateCounter += val;\\n  }\\n  return {\\n    increment: function () {\\n      changeBy(1);\\n    },\\n    decrement: function () {\\n      changeBy(-1);\\n    },\\n    value: function () {\\n      return privateCounter;\\n    }\\n  };\\n})();\\n\\nconsole.log(Counter.value()); /* logs 0 */\\nCounter.increment();\\nCounter.increment();\\nconsole.log(Counter.value()); /* logs 2 */\\nCounter.decrement();\\nconsole.log(Counter.value()); /* logs 1 */\\n//或者不声明为自调用函数\\nvar makeCounter = function () {\\n  var privateCounter = 0;\\n  function changeBy(val) {\\n    privateCounter += val;\\n  }\\n  return {\\n    increment: function () {\\n      changeBy(1);\\n    },\\n    decrement: function () {\\n      changeBy(-1);\\n    },\\n    value: function () {\\n      return privateCounter;\\n    }\\n  };\\n};\\n\\nvar Counter1 = makeCounter();\\nvar Counter2 = makeCounter();\\nconsole.log(Counter1.value()); /* logs 0 */\\nCounter1.increment();\\nCounter1.increment();\\nconsole.log(Counter1.value()); /* logs 2 */\\nCounter1.decrement();\\nconsole.log(Counter1.value()); /* logs 1 */\\nconsole.log(Counter2.value()); /* logs 0 */\\n```\\n\\n#### 应用举例\\n\\n（1）myModule.js：（定义一个模块，向外暴露多个函数，供外界调用）\\n\\n```\\nfunction myModule() {\\n    //私有数据\\n    var msg = \'Smyhvae Haha\'\\n\\n    //操作私有数据的函数\\n    function doSomething() {\\n        console.log(\'doSomething() \' + msg.toUpperCase()); //字符串大写\\n    }\\n\\n    function doOtherthing() {\\n        console.log(\'doOtherthing() \' + msg.toLowerCase()) //字符串小写\\n    }\\n\\n    //通过【对象字面量】的形式进行包裹，向外暴露多个函数\\n    return {\\n        doSomething1: doSomething,\\n        doOtherthing2: doOtherthing\\n    }\\n}\\n```\\n\\n上方代码中，外界可以通过 doSomething1 和 doOtherthing2 来操作里面的数据，但不让外界看到。\\n\\n```\\n（2）index.html:\\n\\n<!DOCTYPE html>\\n<html lang=\\"en\\">\\n<head>\\n    <meta charset=\\"UTF-8\\">\\n    <title>05_闭包的应用_自定义JS模块</title>\\n</head>\\n<body>\\n<!--\\n闭包的应用 : 定义JS模块\\n  * 具有特定功能的js文件\\n  * 将所有的数据和功能都封装在一个函数内部(私有的)\\n  * 【重要】只向外暴露一个包含n个方法的对象或函数\\n  * 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能\\n-->\\n<script type=\\"text/javascript\\" src=\\"myModule.js\\"><\/script>\\n<script type=\\"text/javascript\\">\\n    var module = myModule();\\n    module.doSomething1();\\n    module.doOtherthing2();\\n<\/script>\\n</body>\\n</html>\\n```\\n\\n方式二\\n\\n同样是实现方式一种的功能，这里我们采取另外一种方式。\\n\\n```\\n（1）myModule2.js：（是一个立即执行的匿名函数）\\n\\n(function () {\\n    //私有数据\\n    var msg = \'Smyhvae Haha\'\\n\\n    //操作私有数据的函数\\n    function doSomething() {\\n        console.log(\'doSomething() \' + msg.toUpperCase())\\n    }\\n\\n    function doOtherthing() {\\n        console.log(\'doOtherthing() \' + msg.toLowerCase())\\n    }\\n\\n    //外部函数是即使运行的匿名函数，我们可以把两个方法直接传给window对象\\n    window.myModule = {\\n        doSomething1: doSomething,\\n        doOtherthing2: doOtherthing\\n    }\\n})()\\n```\\n\\n```\\n（2）index.html：\\n\\n<!DOCTYPE html>\\n<html lang=\\"en\\">\\n<head>\\n    <meta charset=\\"UTF-8\\">\\n    <title>05_闭包的应用_自定义JS模块2</title>\\n</head>\\n<body>\\n<!--\\n闭包的应用2 : 定义JS模块\\n  * 具有特定功能的js文件\\n  * 将所有的数据和功能都封装在一个函数内部(私有的)\\n  * 只向外暴露一个包信n个方法的对象或函数\\n  * 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能\\n-->\\n\\n<!--引入myModule文件-->\\n<script type=\\"text/javascript\\" src=\\"myModule2.js\\"><\/script>\\n<script type=\\"text/javascript\\">\\n    myModule.doSomething1()\\n    myModule.doOtherthing2()\\n<\/script>\\n</body>\\n</html>\\n```\\n\\n## 闭包的作用\\n\\n由上可见，闭包的作用主要有两个：\\n\\n- 作用 1. 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)\\n- 作用 2. 让函数外部可以操作(读写)到函数内部的数据(变量/函数)\\n\\n隐藏局部变量，暴露操作函数\\n\\n```javascript\\nfunction fn1() {\\n  var a = 2;\\n\\n  function fn2() {\\n    a++;\\n    console.log(a);\\n  }\\n  return fn2;\\n}\\n\\nvar f = fn1(); //执行外部函数fn1，返回的是内部函数fn2\\nf(); // 3       //执行fn2\\nf(); // 4       //再次执行fn2\\n\\nconst createAdd = () => {\\n  let n = 0;\\n  return () => {\\n    n += 1;\\n    console.log(n);\\n  };\\n};\\n\\nconst add = createAdd();\\nadd(); // 1\\nadd(); // 2\\n```\\n\\n## 闭包的注意点\\n\\n1. 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。\\n1. 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。\\n\\n---\\n\\n参考自[阮一峰 JavaScript 闭包](http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)、[mdn 闭包](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)、[qianguyihao  github](https://github.com/qianguyihao/Web)\\n\\n# 原型和原型链\\n\\n### 明确一些概念：\\n\\n#### 什么是堆？什么是栈？\\n\\n- 堆（heap）是不连续的内存区域，即数据可以任意存放， 主要存放的是对象等。\\n- 栈（stack）是一块连续的内存区域，每个区块按照一定次序存放（后进先出），栈中主要存放的是基本类型的变量的值以及指向堆中的数组或者对象的地址\\n\\n#### JS 数据类型\\n\\n数字 number、字符串 string、boolean 布尔、符号 Symbol、null、undefined、对象 object。\\n\\n- “类型”是 JS 数据的分类，分 7 种，“类”是针对于对象的分类，有无数种\\n- 其中又可以分为两类：基本数据类型（非对象）和引用数据类型（对象）。\\n  - 基本数据类型：数字 number、字符串 string、boolean 布尔、符号 Symbol、null、undefined\\n  - 引用数据类型：对象 object\\n\\n基本数据类型存储在栈 stack，引用数据类型存储在堆 heap\\n\\n## 原型\\n\\n所有的引用类型（数组、对象、函数）都有`__proto__`这个属性。构造函数拥有`prototype`属性\\n\\n`prototype`显式原型，`__proto__`隐式原型。\\n构造函数对象才有 prototype 属性， 实例具有`__proto__`属性,他们指向的都是堆区中的原型对象（`prototype`和`__proto__`保存都是堆区中原型对象的地址，并且是一样的地址，所以`构造函数.prototype===实例对象.__proto__`）\\n\\n原型对象是所有实例共享的，并且每个实例都可以调用原型上的函数方法\\n\\nObject.prototype 是所有对象的（直接或者间接）原型，对于数组、函数来说，是间接原型，但是对于对象，是直接原型\\n\\n所有函数对象都是由 Function 构造的\\n`函数对象.__proto__===Function.prototype`\\n\\n构造函数有 Object/Array/Function\\n\\n## 原型链\\n\\n实例可以直接调用原型上的属性和方法，如果没有，就去原型的原型里找，再没有，就去原型的原型的原型里找，于是形成了原型链\\n\\n原型链的终点是 null\\n\\nJS 世界：\\nxxx 的原型指的是 xxx 的`__proto__`\\n\\n首先有一个根对象、一个函数原型、一个数组原型。函数原型和数组原型的原型（`__proto__`）为根对象。\\n\\n然后创建 Function 构造函数，`__proto__`为函数原型，Function.prototype 也为函数原型（Function 的`prototype`和`__proto__`指向同一对象即函数原型）。\\n\\n接着开始用 Function 构造 Object 和 Array，分别让他们的 prototype 为根对象和数组原型。至此 JS 世界创建完毕，最后用 window 对象里的三个属性 Object、Array、Function 分别保存指向前面创建的 Object、Array、Function 函数对象\\n\\nObject.prototype 是由 Function 构造的，但是并不是说 Object 是 Function 构造的，Object.prototype 只是个 Function 构造出来的地址，Function 添加了这个指向 prototype 对象的地址，prototype 指向的对象才是根对象\\n\\n# 异步和 ajax\\n\\n## 什么是同步？什么是异步？\\n\\n能直接拿到结果的是同步，不能直接拿到结果的就是异步\\n\\nJS 是单线程语言，会优先把同步任务执行完再去执行异步任务。\\n\\n举例：\\n\\n```javascript\\nconsole.log(1);\\n\\nsetTimeout(function () {\\n  console.log(2);\\n}, 1000);\\n\\nsetTimeout(function () {\\n  console.log(3);\\n}, 0);\\n\\nconsole.log(4);\\n//依次是1 4 3 2，因为1和4都是同步任务，js碰到异步任务会先挂起，等同步任务执行完再执行异步任务\\n```\\n\\n异步的应用场景有：\\n\\n1. 定时任务：setTimeout（定时执行）、setInterval（循环执行）\\n1. 网络请求：ajax 请求、动态加载\\n1. 事件绑定（addEventListener）\\n\\n## 什么是回调？\\n\\n提前定义好的一个函数，等着被作为实参传入另一函数，并在该函数内被调用，用以来完成某些任务，一般只要作为参数被调用的函数都称为回调函数。\\n\\n回调分同步回调和异步回调。在同步函数中作为参数被调用就是同步回调，如果传给异步函数，就是异步回调，当异步函数执行完毕时调用 fn，就能通过回调拿到了异步处理的结果。\\n\\n```javascript\\nfunction employee(telNumber) {\\n  console.log(`给${telNumber}致电中。。。`);\\n}\\nfunction employer(telNumber, callback) {\\n  console.log(\'一会把号码发给你，替我打个电话\');\\n  setTimeout(function () {\\n    callback(telNumber);\\n  }, 2000);\\n}\\nemployer(\'12345678\', employee);\\n```\\n\\n## ajax\\n\\n**Ajax**：Asynchronous Javascript And XML（异步 JavaScript 和 XML）\\n\\n我们在访问一个普通的网站时，当浏览器加载完 HTML、CSS、JS 以后，网站的内容就固定了。如果想让网站内容发生更改，就必须刷新页面才能够看到更新的内容。\\n\\n可如果用到异步更新，情况就大为改观了。比如，我们在访问新浪微博时，看到一大半了，点击底部的加载更多，会自动帮我们加载更多的微博，同时页面并没有刷新。\\n\\n试想一下，如果没有异步刷新的话，每次点击“加载更多”，网页都要刷新，体验就太不好了。\\n\\nweb 前端里的异步更新，就要用到 Ajax。\\n\\n#### 使用方法\\n\\n第一步：获取 XMLHttpRequest 对象\\n`let request=new XMLHttpRequest()`\\n第二步：设置请求参数\\n`request.open(\'GET\',xxx)`\\n第三步：监听对象的状态\\n\\n```javascript\\nrequest.onreadystatechange = function () {\\n  if (this.readyState == 4 && this.status == 200) {\\n    console.log(request.response);\\n  }\\n};\\n```\\n\\n第四步：发送请求\\n`request.send()`\\n\\n#### readyState 状态码\\n\\n| 值  | 状态             | 描述                                              |\\n| --- | ---------------- | ------------------------------------------------- |\\n| 0   | UNSENT           | 代理被创建，但尚未调用 open() 方法。              |\\n| 1   | OPENED           | open() 方法已经被调用。                           |\\n| 2   | HEADERS_RECEIVED | send() 方法已经被调用，并且头部和状态已经可获得。 |\\n| 3   | LOADING          | 下载中； responseText 属性已经包含部分数据。      |\\n| 4   | DONE             | 下载操作已完成。                                  |\\n\\najax 加载示例：\\n\\n```javascript\\ngetJson.onclick = () => {\\n  const request = new XMLHttpRequest();\\n  request.open(\'GET\', \'/5.json\');\\n  request.onreadystatechange = () => {\\n    if (request.readyState === 4 && request.status === 200) {\\n      const obj = JSON.parse(request.response);\\n      console.log(obj);\\n      myName.textContent = obj.name;\\n    }\\n  };\\n  request.send();\\n};\\ngetXML.onclick = () => {\\n  const request = new XMLHttpRequest();\\n  request.open(\'GET\', \'/4.xml\');\\n  request.onreadystatechange = () => {\\n    if (request.readyState === 4 && request.status === 200) {\\n      const dom = request.responseXML;\\n      const text = dom.getElementsByTagName(\'warning\')[0].textContent;\\n      console.log(text.trim());\\n    }\\n  };\\n  request.send();\\n};\\ngetCSS.onclick = () => {\\n  const request = new XMLHttpRequest();\\n  request.open(\'GET\', \'/style.css\');\\n  request.onreadystatechange = () => {\\n    if (request.readyState === 4) {\\n      if (request.status >= 200 && request.status < 300) {\\n        const style = document.createElement(\'style\');\\n        style.innerHTML = request.response;\\n        document.head.appendChild(style);\\n      } else {\\n        console.log(\'失败\');\\n      }\\n    }\\n  };\\n\\n  request.send();\\n};\\ngetJS.onclick = () => {\\n  const request = new XMLHttpRequest();\\n  request.open(\'GET\', \'/2.js\');\\n  request.onload = () => {\\n    const script = document.createElement(\'script\');\\n    script.innerHTML = request.response;\\n    document.body.appendChild(script);\\n    console.log(request.response);\\n  };\\n  request.onerror = () => {};\\n  request.send();\\n};\\ngetHTML.onclick = () => {\\n  const request = new XMLHttpRequest();\\n  request.open(\'GET\', \'/3.html\');\\n  request.onload = () => {\\n    const div = request.createElement(\'div\');\\n    div.innerHTML = request.response;\\n    document.body.appendChild(div);\\n  };\\n  request.onerror = () => {};\\n  request.send();\\n};\\n```\\n\\n# JS 模块化\\n\\nes6 之前，社区的模块加载方案有 CommonJS（服务器）和 AMD（浏览器）两种。\\nes6 在语言标准层面上实现了模块功能，取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案\\n\\nCommonJS 需要在运行时才能确定模块的依赖关系\\n\\n```javascript\\n// CommonJS模块\\nlet { stat, exists, readfile } = require(\'fs\');\\n// 等同于\\nlet _fs = require(\'fs\');\\nlet stat = _fs.stat;\\nlet exists = _fs.exists;\\nlet readfile = _fs.readfile;\\n```\\n\\n模块被当成对象使用。\\n而 es6 模块是静态化的设计思想，模块不是对象，而是通过 `export`  显式导出，再通过 `import`  导入\\nes6 的模块可以在编译时就完成加载，一个文件就是一个模块\\n\\n```javascript\\nimport { stat, exists, readFile } from \'fs\';\\n```\\n\\n## 基本用法\\n\\n1. export 命令\\n\\n**导出变量** ：\\n`export var name=\'Michael\'` \\nor\\n\\n```javascript\\nlet name = \'Michael\';\\nexport { name };\\n```\\n\\n**导出函数** ：\\n\\n```javascript\\nexport function multiply(x, y) {\\n  return x * y;\\n}\\n```\\n\\n     或者也可以使用别名\\n\\n```javascript\\nfunction v1() { ... }\\nfunction v2() { ... }\\nexport {\\n  v1 as streamV1,\\n  v2 as streamV2,\\n  v2 as streamLatestVersion\\n};\\n```\\n\\n2. `import`  命令\\n\\n用法和 `export`  一样，但是需要 **注意** ：\\n`import`  的输入变量都是只读的，但是如果是对象，是可以修改属性的（不要轻易改变）\\n\\n`import \'xxx\'`\\n会执行所加载的模块，但是不输入任何值\\n\\n还可以整体加载\\n`import * as xxx from \'xxx\'` \\n用 xxx.xxx 进行调用\\n\\n3. export default 命令\\n\\n可以不用知道模块的属性和方法，直接重命名导入使用，且不用加花括号，用法基本同上\\n\\n```javascript\\n// export-default.js\\nexport default function () {\\n  console.log(\'foo\');\\n}\\n```\\n\\n```javascript\\n// import-default.js\\nimport customName from \'./export-default\';\\ncustomName(); // \'foo\'\\n```\\n\\nexport default 就是输出一个叫做 default 的变量或方法，然后允许任意命名。\\n\\n但是要注意，一个模块只能有一个默认输出\\n\\n## 进阶用法\\n\\n4. import 和 export 复合写法\\n\\n`export {foo,bar} from \'module\';` \\n也可改名和整体输出\\n\\n```javascript\\n// 接口改名\\nexport { foo as myFoo } from \'my_module\';\\n// 整体输出\\nexport * from \'my_module\';\\n```\\n\\n还可以具名接口改默认，默认接口改具名\\n\\n```javascript\\nexport { es6 as default } from \'./someModule\';\\n// 等同于\\nimport { es6 } from \'./someModule\';\\nexport default es6;\\n\\nexport { default as es6 } from \'./someModule\';\\n```\\n\\n5. 模块继承\\n\\n利用复合写法，实现在一个模块中导出另一个模块的属性和方法\\n\\n6.  跨模块常量\\n\\n         建如下目录\\n         -constants\\n         --db.js\\n         --user.js\\n         --index.js\\n\\n    分别在 db 和 user 中导出各种 const 变量，然后利用复合写法，在 index 中直接导入导出\\n    这样一来，外部使用时，直接从 index 导入就可以\\n    `import {xxx} from \'./constants/index\'`\\n\\n7.  动态加载\\n\\n前面提到的都是静态加载，只能在模块顶层，不支持条件判断，但是 import 在 es2020 中已经支持了动态加载模块，可以在任何地方使用，是在运行时执行\\nimport(specifier)返回一个 Promise 对象\\n**适用场景** \\n下面是`import()`的一些适用场合。\\n（1）按需加载。\\n`import()`可以在需要的时候，再加载某个模块。\\n\\n```\\nbutton.addEventListener(\'click\', event => {\\n  import(\'./dialogBox.js\')\\n  .then(dialogBox => {\\n    dialogBox.open();\\n  })\\n  .catch(error => {\\n    /* Error handling */\\n  })\\n});\\n```\\n\\n上面代码中，`import()`方法放在`click`事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。\\n（2）条件加载\\n`import()`可以放在`if`代码块，根据不同的情况，加载不同的模块。\\n\\n```\\nif (condition) {\\n  import(\'moduleA\').then(...);\\n} else {\\n  import(\'moduleB\').then(...);\\n}\\n```\\n\\n上面代码中，如果满足条件，就加载模块 A，否则加载模块 B。\\n（3）动态的模块路径\\n`import()`允许模块路径动态生成。\\n\\n```\\nimport(f())\\n.then(...);\\n```\\n\\n上面代码中，根据函数`f`的返回结果，加载不同的模块。\\n\\n## 浏览器加载 js\\n\\n**传统方式**\\n\\n- `<script src=\\"/a/b/c.js\\"/>`\\n- `<script>some code...<\/script>`\\n\\n由于 js 单线程的关系，渲染引擎会等到执行完脚本再继续向下渲染。如果是外部脚本，还得算上下载时间\\n\\n因此如果脚本体积庞大，就会阻塞浏览器，所以浏览器允许异步加载\\n\\n```javascript\\n<script src=\\"path/to/myModule.js\\" defer><\/script>\\n<script src=\\"path/to/myModule.js\\" async><\/script>\\n```\\n\\n- defer: dom 完全生成，以及其他脚本执行完毕，才执行\\n- async: 一旦下载完，渲染引擎终端渲染，执行此脚本\\n\\n**注意**  多个 defer 按出现顺序加载，多个 async 不能保证加载顺序\\n\\n**加载 es6 模块** \\n`<script type=\\"module\\" src=\\"./xxx.js\\"><\/script>` \\n带有 `type=\\"module\\"`  的都是异步加载，等到页面渲染完才执行，等同于 defer\\n\\n需要 **注意** ：模块顶层的 this 返回 undefined，而不是指向 window\\n可以用来判断是否是 es6 模块 `const isNotModuleScript=this!==undefined`\\n\\n## ES6 VS CommonJS\\n\\n- CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\\n- CommonJS 模块是运行时加载(对象)，ES6 模块是编译时输出接口（静态定义）。\\n- CommonJS 模块的`require()`是同步加载模块，ES6 模块的`import`命令是异步加载，有一个独立的模块依赖的解析阶段。\\n\\n#\\n\\n# Promise、async、await\\n\\n## Promise\\n\\n作用：\\n\\n1. 规范了异步事件处理的写法\\n1. 避免了出现回调地狱\\n1. 方便错误捕获\\n\\n### 什么是回调地狱？\\n\\n为了获取异步结果而造成的层层嵌套\\n![回调地狱.png](./images/callback-hell.png)\\n或是这样\\n\\n```javascript\\nfunction a() {\\n  function b() {\\n    function c() {\\n      function d() {}\\n      d();\\n    }\\n    c();\\n  }\\n  b();\\n}\\na();\\n```\\n\\n而使用 `Promise` ，就可以优雅地处理异步事件\\n\\n只要用`return new Promise((resolve,reject)=>{})`就能创建一个异步事件\\n\\n`Promise`  对象存放着某个未来才会结束的事件。有两个 **特点** ：\\n\\n1. 对象的状态不受外界影响。 共有三种状态`pending`  `fulfilled`  `rejected`\\n2. 一旦状态改变，就不会再变，任何时候都可以获得这个结果。状态的改变，只有两种可能：从 `pending`  变为 `fulfilled`  和从 `pending`  变为 `rejected`\\n\\n### 常见用法\\n\\n1. 创建 `Promise`  实例\\n\\n```javascript\\nconst promise = new Promise(function(resolve, reject) {\\n  // ... some code\\n\\n  if (/* 异步操作成功 */){\\n    //将Promise对象的状态从pending变为resolved\\n    resolve(value);\\n  } else {\\n    //将Promise对象的状态从pending变为rejected\\n    reject(error);\\n  }\\n});\\n```\\n\\n2. `Promise.prototype.then `\\n\\n- 如何使用\\n\\n  接受两个回调函数。\\n\\n```javascript\\npromise.then(\\n  //resolved状态调用\\n  function (value) {\\n    // success\\n  },\\n  //rejected状态调用，可选\\n  function (error) {\\n    // failure\\n  }\\n);\\n```\\n\\n- then 的返回值大致有两种情况：\\n\\n情况 1：返回 Promise 实例对象。返回的该实例对象可调用下一个 then。\\n情况 2：返回普通值。返回的普通值会直接传递给下一个 then，根据 promise 的状态，通过 then 参数中函数的参数接收该值。 因此，then 可以进行链式调用，避免了层层的回调地狱\\n\\n### 具体应用  \\n\\n如 ajax 请求\\n\\n```javascript\\n//普通版\\nconst ajax = url => {\\n  let request = new XMLHttpRequest();\\n  request.open(\'GET\', url);\\n  request.onreadystatechange = function () {\\n    if (this.readyState == 4 && this.status == 200) {\\n      console.log(request.response);\\n    }\\n  };\\n  request.send();\\n};\\n```\\n\\n```javascript\\n//Promise版\\nconst ajax=(url)=>{\\n  return new Promise((resolve,reject)=>{\\n    let request=new XMLHttpRequest()\\n    request.open(\'GET\',url)\\n    request.onreadystatechange=function(){\\n       if (this.readyState == 4 && this.status == 200) {\\n          resolve(request.response)\\n       }else{\\n          reject(new Error(this.statusText))\\n       }\\n    }\\n    request.send()\\n  }\\n}\\najax(\\"/a/b/c\\").then(\\n    (resp)=>{\\n      console.log(resp)},\\n    (err)=>{\\n      console.log(err)}\\n  )\\n```\\n\\n### 其他常用的 api\\n\\n1. `Promise.prototype.catch()`\\n\\n`reject`  和抛出 `Error`  是等同的，都可以用 `catch`  捕获，但是不能在状态已经变成 `resolved`  后再抛出错误，一般不在 `then()`  方法里定义 reject 状态的回调函数，总是使用 catch 方法\\n要注意的是， `Promise`  内部的错误不会影响外部代码的执行，只能用 `catch`  捕获\\n\\n```javascript\\n// 写法一\\nconst promise = new Promise(function (resolve, reject) {\\n  try {\\n    throw new Error(\'test\');\\n  } catch (e) {\\n    reject(e);\\n  }\\n});\\npromise.catch(function (error) {\\n  console.log(error);\\n});\\n// 写法二\\nconst promise = new Promise(function (resolve, reject) {\\n  reject(new Error(\'test\'));\\n});\\npromise.catch(function (error) {\\n  console.log(error);\\n});\\n```\\n\\n2. `Promise.prototype.finally()`\\n\\n   无论 promise 对象最后的状态如何都会执行回调。\\n\\n```javascript\\npromise\\n.then(result => {···})\\n.catch(error => {···})\\n.finally(() => {···});\\n```\\n\\n     简单实现：\\n\\n```javascript\\nPromise.prototype.finally = function (callback) {\\n  let P = this.constructor;\\n  return this.then(\\n    value => P.resolve(callback()).then(() => value),\\n    reason =>\\n      P.resolve(callback()).then(() => {\\n        throw reason;\\n      })\\n  );\\n};\\n```\\n\\n3.  `Promsie.prototype.all() `\\n\\n         接受一个promise实例的数组，\\n\\n```javascript\\nconst p = Promise.all([p1, p2, p3]);\\n```\\n\\n     p1 p2 p3都为fulfilled，p才会变为fulfilled，此时p1 p2 p3的返回值组成一个数组，传递给p的回调\\n     若是其中有一个为rejected，p的状态就是rejected，此时第一个被reject的实例的返回值传递给p的回调函数\\n\\n4. `Promsie.prototype.race()`\\n\\n   与 all()不同的是，只要有一个实例率先改变状态，p 的状态就跟着改变。率先改变的 Promise 实例的返回值，就传给 p 的回调函数\\n\\n5. `Promsie.prototype.allSettled() `\\n\\n接收一组 Promise 实例作为参数，包装成一个新的 Promise，只有等这些实例都返回结果（不管是成功还是失败），包装实例才会结束。生成的新的 Promise 实例，一旦结束，状态总是 fulfilled，它的监听函数会接收到一个数组，每个数组成员对应一个 Promise 实例的结果\\n\\n```javascript\\nconst resolved = Promise.resolve(42);\\nconst rejected = Promise.reject(-1);\\nconst allSettledPromise = Promise.allSettled([resolved, rejected]);\\nallSettledPromise.then(function (results) {\\n  console.log(results);\\n});\\n// [\\n//    { status: \'fulfilled\', value: 42 },\\n//    { status: \'rejected\', reason: -1 }\\n// ]\\n```\\n\\n6. `Promise.prototype.any()`\\n\\n也是接受一组`Promise`实例作为参数，包装成一个新的`Promise`实例返回，只要有一个是`fulfilled`，包装实例就是`fulfilled`，如果所有的实例参数都是`rejected`，包装实例就会变成`rejected`\\n假如接收三个`promise`实例，一个`resolve`，两个`reject`，结果回调中的参数会是成功的结果，如果都是`reject`，结果会是一个数组，每个成员对应一个`rejected`的实例抛出的错误。这个数组是一个`AggregateError`实例\\n\\n```javascript\\nvar resolved = Promise.resolve(42);\\nvar rejected = Promise.reject(-1);\\nvar alsoRejected = Promise.reject(Infinity);\\nPromise.any([resolved, rejected, alsoRejected]).then(function (result) {\\n  console.log(result); // 42\\n});\\nPromise.any([rejected, alsoRejected]).catch(function (results) {\\n  console.log(results); // [-1, Infinity]\\n});\\n```\\n\\n7. `Promise.prototype.resolve()`\\n\\n能将现有对象转为 Promise 对象，参数有四种情况\\n（1）是一个 Promise 实例，原封不动返回\\n（2）是一个带有 then 方法的对象。这个对象会被转为 Promise 对象，然后立即执行其中的 then 方法\\n（3）参数不具有 then 方法，或根本不是对象。会返回一个新的 Promise 对象，状态为 resolved\\n（4）不带有任何参数。直接返回一个 resolved 状态的 Promise 对象\\n\\n8. `Promise.prototype.reject()`\\n\\n返回一个新的状态为 rejected 的 Promise 实例\\n它的参数，会原封不动地作为 reason 变成后续方法的参数\\n\\n### Promise 的简单实现\\n\\n```javascript\\nclass Promise {\\n  constructor(executor) {\\n    this.state = \'pending\';\\n    this.value = undefined;\\n    this.reason = undefined;\\n    this.onResolvedCallbacks = [];\\n    this.onRejectedCallbacks = [];\\n    let resolve = value => {\\n      if (this.state === \'pending\') {\\n        this.state = \'resolved\';\\n        this.value = value;\\n        this.onResolvedCallbacks.forEach(fn => fn());\\n      }\\n    };\\n    let reject = reason => {\\n      if (this.state === \'pending\') {\\n        this.state = \'rejected\';\\n        this.reason = reason;\\n        this.onRejectedCallbacks.forEach(fn => fn());\\n      }\\n    };\\n    try {\\n      executor(resolve, reject);\\n    } catch (error) {\\n      reject(error);\\n    }\\n  }\\n  then(onFulfilled, onRejected) {\\n    // onFulfilled如果不是函数，就忽略onFulfilled，直接返回value\\n    onFulfilled = typeof onFulfilled === \'function\' ? onFulfilled : value => value;\\n    // onRejected如果不是函数，就忽略onRejected，直接扔出错误\\n    onRejected =\\n      typeof onRejected === \'function\'\\n        ? onRejected\\n        : err => {\\n            throw err;\\n          };\\n    //返回一个新的promise对象实现链式调用\\n    return new Promise((resolve, reject) => {\\n      if (this.state === \'fulfilled\') {\\n        let x = onFulfilled(this.value);\\n        resolve(x);\\n      }\\n      if (this.state === \'rejected\') {\\n        let x = onRejected(this.reason);\\n        reject(x);\\n      }\\n      if (this.state === \'pending\') {\\n        this.onResolvedCallbacks.push(() => {\\n          let x = onFulfilled(this.value);\\n          resolve(x);\\n        });\\n        this.onRejectedCallbacks.push(() => {\\n          let x = onRejected(this.reason);\\n          reject(x);\\n        });\\n      }\\n    });\\n  }\\n}\\nlet promise1 = new Promise((resolve, reject) => {\\n  setTimeout(() => {\\n    resolve(\'我成功执行了\');\\n  }, 1000);\\n});\\npromise1\\n  .then(onfulFilled => {\\n    console.log(onfulFilled);\\n    return onfulFilled;\\n  })\\n  .then()\\n  .then()\\n  .then(e => {\\n    console.log(e);\\n  });\\n复制代码;\\n```\\n\\n## async、await\\n\\n### Iterator 和 for...of\\n\\nIterator 遍历器是一种接口，为不同的数据结构提供统一的访问机制。当使用 for...of 时，会自动去寻找 Iterator 接口。es6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，一个数据结构只要有这个属性，就是可遍历的。\\n原生具备 Iterator 接口的数据结构如下。\\n\\n- Array\\n- Map\\n- Set\\n- String\\n- TypedArray\\n- 函数的 arguments 对象\\n- NodeList 对象\\n\\n### Generator\\n\\n这是 es6 提供的一种异步解决方案\\n在这之前，异步编程的解决方案有\\n\\n- 回调函数\\n- 事件监听\\n- 发布/订阅\\n- Promise 对象\\n\\nGenerator 是一个状态机，封装多个内部状态，函数返回一个遍历器对象。\\nGenerator 是分段执行的，每次调用 next 就执行一步，遇到下一个 yield 就停止。\\n遍历结束时 done 属性会变为 true\\nnext()一下走一步\\n\\n```javascript\\nfunction* doWhat() {\\n  yield \'吃饭\';\\n  return \'睡觉\';\\n}\\nlet man = doWhat();\\nconsole.log(man.next());\\nconsole.log(man.next());\\n/*\\n{\\n  done: false,\\n  value: \\"吃饭\\"\\n}\\n{\\n  done: true,\\n  value: \\"睡觉\\"\\n}\\n*/\\n复制代码;\\n```\\n\\n- `function* xxx`和`function *xxx`一样\\n- yield 将函数截成多个状态\\n- Generator 不会自己执行，而是返回一个遍历器对象\\n- 遍历器对象通过.next()方法调用各个状态\\n\\n**Generator 可用于消息传递**\\n\\n```javascript\\nfunction* x() {\\n  let x = yield \'我启动了！\';\\n  let y = yield x + 3;\\n  let z = yield y * 3;\\n  return x * 2;\\n}\\nlet y = x();\\nconsole.log(y.next(1)); // {value: \\"我启动了！\\", done: false}\\nconsole.log(y.next(2)); // {value: 5, done: false}\\nconsole.log(y.next(100)); // {value: 300, done: false}\\nconsole.log(y.next(1000)); // {value: 4, done: true}\\n复制代码;\\n```\\n\\n**async、await 就是 Genarator 的语法糖** \\n通过 Generator 函数加自动执行器实现，于是不需要一直 next()\\n\\n```javascript\\nfunction f() {\\n  return new Promise(resolve => {\\n    resolve(\'hhh\');\\n  });\\n}\\nasync function doSomething1() {\\n  let x = await f();\\n  console.log(x);\\n}\\ndoSomething1();\\n//hhh\\n复制代码;\\n```\\n\\n1. async 修饰符表示这个函数是异步函数\\n1. await 是个运算符，阻塞后面代码\\n1. await 如果等到的 Promise 对象就得到其 resolve 值\\n\\n```javascript\\nasync function doSomething1() {\\n  let x = await \'hhh\';\\n  return x;\\n}\\nconsole.log(doSomething1());\\ndoSomething1().then(res => {\\n  console.log(res);\\n});\\n//打印结果：\\n//Promise {<pending>}\\n//hhh\\n复制代码;\\n```\\n\\n1. async 返回一个 Promise 对象，async 修饰的函数内部返回的值，会成为 then 中回调方法的参数\\n1. await 如果等到的不是 Promise 对象，就得到一个表达式的运算结果\\n\\n## Event Loop\\n\\n是 js 实现异步的解决方案。js 是单线程的，任务被分为同步任务和异步任务，所有同步任务都在主线程上执行，形成一个执行栈。而所有的异步任务都会进入“任务队列”，任务队列又分成宏任务队列和微任务队列，同步任务优先、异步任务挂起，处理顺序根据任务队列情况而定，宏任务优先级低，只有微任务队列清空才会去拿一个宏任务出来执行\\n\\n# 防抖和节流\\n\\n## 节流  \\n\\n规定一个单位时间，这个单位时间内只能有一次触发事件的回调函数执行，如果该时间内事件触发多次，只有一次生效  \\n代码：\\n\\n```javascript\\nfunction throttle(fn, delay) {\\n  let canUse = true;\\n  return function () {\\n    const _this = this;\\n    if (canUse) {\\n      canUse = false;\\n      setTimeout(() => {\\n        canUse = true;\\n        fn.apply(_this, arguments);\\n      }, delay);\\n    }\\n  };\\n}\\n```\\n\\n**适用场景**\\n可用于 dom 元素拖拽、高频重复点击提交等等。以下是实现一个可拖动的 div，利用节流来减少回调的执行次数\\n\\n```html\\n<!DOCTYPE html>\\n<html>\\n  <head>\\n    <meta charset=\\"utf-8\\" />\\n    <meta name=\\"viewport\\" content=\\"width=device-width\\" />\\n    <title>JS Bin</title>\\n  </head>\\n  <body>\\n    <div class=\\"box\\">拖动我</div>\\n  </body>\\n</html>\\n```\\n\\n```css\\n.box {\\n  background: blue;\\n  color: white;\\n  width: 3em;\\n  line-height: 2em;\\n  user-select: none;\\n  position: absolute;\\n  cursor: move;\\n}\\n```\\n\\n```javascript\\nlet box = document.querySelector(\'.box\');\\nlet down = {\\n  x: 0,\\n  y: 0\\n};\\nlet move = {};\\n\\nfunction throttle(fn, delay) {\\n  let canUse = true;\\n  return function () {\\n    let _this = this;\\n    if (canUse) {\\n      canUse = false;\\n      setTimeout(() => {\\n        fn.apply(_this, arguments);\\n        canUse = true;\\n      }, delay);\\n    }\\n  };\\n}\\nfunction moveFn() {\\n  box.style.left = move.x - down.x + \'px\';\\n  box.style.top = move.y - down.y + \'px\';\\n}\\nfunction moveDiv() {\\n  box.addEventListener(\'mousedown\', e => {\\n    down.x = e.clientX - box.offsetLeft;\\n    down.y = e.clientY - box.offsetTop;\\n    let canMove = true;\\n    window.addEventListener(\'mouseup\', () => {\\n      canMove = false;\\n    });\\n    let throttled = throttle(moveFn, 50);\\n    window.addEventListener(\'mousemove\', e => {\\n      if (canMove === true) {\\n        move.x = e.clientX;\\n        move.y = e.clientY;\\n        throttled();\\n      }\\n    });\\n  });\\n}\\n\\nmoveDiv();\\n```\\n\\n## 防抖\\n\\n规定一个时间 n，事件触发后在 n 秒后执行回调，如果 n 秒内又被触发，则重新计时\\n代码：\\n\\n```javascript\\nfunction debounce(fn, delay) {\\n  let timerId = null;\\n  return function () {\\n    const _this = this;\\n    if (timerId) {\\n      window.clearTimeout(timerId);\\n    }\\n    timerId = setTimeout(() => {\\n      fn.apply(_this, arguments);\\n      timerId = null;\\n    }, delay);\\n  };\\n}\\n```\\n\\n**适用场景** \\n如防止表单多次提交、减少 ajax。以下是模拟一个表单，使用防抖减少持续输入过程过程中的冗余提交\\n\\n```javascript\\nfunction debounce(fn, delay) {\\n  let timerId = null;\\n  return function () {\\n    const _this = this;\\n    if (timerId) {\\n      clearTimeout(timerId);\\n    }\\n    timerId = setTimeout(() => {\\n      fn.apply(_this, arguments);\\n      timerId = null;\\n    }, delay);\\n  };\\n}\\nfunction submit(val) {\\n  console.log(val);\\n}\\nlet text = document.querySelector(\'#text\');\\nlet debounced = debounce(submit, 1000);\\ntext.addEventListener(\'input\', e => {\\n  debounced(e.target.value);\\n});\\n```\\n\\n## 面试题\\n\\n<!--@include: ./FAQ.md-->\\n\\n## 参考\\n\\n[前端基础进阶（一）：内存空间详细图解](https://www.jianshu.com/p/996671d4dcc4)\\n[前端基础进阶（四）：作用域与作用域链](https://www.jianshu.com/p/9b984874776c)\\n[JavaScript 深入之词法作用域和动态作用域](https://juejin.cn/post/6844903473012539405)\\n[前端基础进阶（二）：执行上下文详细图解](https://www.jianshu.com/p/a6d37c77e8db)\\n[JavaScript 深入之执行上下文栈](https://juejin.cn/post/6844903473301946381)\\n[JavaScript 深入之执行上下文](https://juejin.cn/post/6844903474027560968)\\n[前端基础进阶（十一）：详解面向对象、构造函数、原型与原型链](https://www.jianshu.com/p/15ac7393bc1f)\\n[前端基础进阶（七）：全方位解读 this](https://www.jianshu.com/p/d647aa6d1ae6)\\n[JavaScript 深入之从 ECMAScript 规范解读 this](https://juejin.cn/post/6844903473872371725)\\n[前端基础进阶（五）：闭包](https://www.jianshu.com/p/21a16d44f150)\\n[前端基础进阶（六）：setTimeout 与循环闭包面试题详解](https://www.jianshu.com/p/9b4a54a98660)\\n[JavaScript 深入之闭包](https://juejin.cn/post/6844903475998900237)\\n[前端基础进阶（十四）：深入核心，详解事件循环机制](https://www.jianshu.com/p/12b9f73c5a4f)\\n[说说事件循环机制](https://juejin.cn/post/6844904079353708557)\\n浏览器工作原理与实践 --- 15-消息队列和事件循环：页面是怎么“活”起来的？\\n[Promise 链式调用顺序引发的思考](https://juejin.cn/post/6844903972008886279) 配合作业 1 食用\\n[理解 Promise.then 回调的执行顺序](https://juejin.cn/post/6876686095954903048)\\n","frontmatter":{"title":"js","desc":"《JavaScript设计模式》、《大话设计模式》笔记","keywords":"设计模式、笔记","date":"2020-02-17T01:01:00.000Z","cover":"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg"},"url":"/front-end/js/"},{"src":"# 微前端\\n\\n## 什么是微前端\\n\\n微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。就是在一个 web 应用中可以独立的运行另一个 web 应用\\n\\n### 核心价值\\n\\n- 技术栈无关\\n  主框架不限制接入应用的技术栈，微应用具备完全自主权\\n\\n- 独立开发、独立部署\\n  微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新\\n\\n- 增量升级\\n  在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略\\n\\n- 独立运行时\\n  每个微应用之间状态隔离，运行时状态不共享\\n\\n### 为什么不直接用 iframe？\\n\\n如果不考虑体验问题，iframe 几乎是最完美的微前端解决方案。存在问题如下\\n\\n- 浏览器原生隔离，完美解决 js、css 隔离问题，但是应用上下文难以共享，包括内存变量、数据同步、内外通信、cookie 透传\\n- 路由状态丢失，浏览器刷新一下，iframe 的 url 状态就丢失了\\n- 慢。每次打开白屏时间太长，对于 SPA 应用来说无法接受\\n- dom 结构不共享。弹框只能在 iframe 内部展示，无法覆盖全局\\n\\n## 微前端编年史\\n\\n### 1. 概念阶段\\n\\n微前端的概念是由 ThoughtWorks 在 2016 年提出的，它借鉴了微服务的架构理念，核心在于将一个庞大的前端应用拆分成多个独立灵活的小型应用，每个应用都可以独立开发、独立运行、独立部署，再将这些小型应用融合为一个完整的应用，或者将原本运行已久、没有关联的几个应用融合为一个应用。微前端既可以将多个项目融合为一，又可以减少项目之间的耦合，提升项目扩展性，相比一整块的前端仓库，微前端架构下的前端仓库倾向于更小更灵活。\\n\\n主力工具：iframe\\n\\n### 2. 模块化加载\\n\\n随着前端模块化工具的发展，微前端解决方案开始引入模块化加载器，如 Webpack 和 SystemJS\\n\\n- Webpack：通过使用 Webpack 的动态导入（Dynamic Imports）和插件，可以实现模块的按需加载。\\n- SystemJS：是一种模块加载器，可以用于动态加载模块，尤其是在单页面应用（SPA）中\\n\\n```js\\n// 通过 Webpack 4 的 import() 实现动态加载\\n\\nimport(\'path/to/module\').then(module => {\\n  // 使用模块\\n  module.someFunction();\\n});\\n```\\n\\n优点：\\n\\n- 按需加载，提高了资源利用效率。\\n- 更少的性能开销，相较于 iframe。\\n\\n缺点：\\n\\n- 依然较为复杂的配置。\\n- 需要解决模块间依赖和共享的问题。\\n\\n### 3. 微前端框架的出现\\n\\n为了更好地解决微前端的复杂性和多样性需求，出现了一些专门的微前端框架和平台。\\n\\n- Single-SPA：是一个 JavaScript 框架，可以帮助你在一个页面上组合多个微前端子应用，支持多种框架（如 React、Vue、Angular 等）。核心思想是将不同的微前端应用按照路由来分离，并在路由切换的时候激活相应的子应用。\\n- qiankun：qiankun 是基于 Single-SPA 的进行封装和扩展的一个微前端解决方案，它提高了开发体验和框架兼容性。配置化的应用接入更简单，拓展提供了 css、js 沙箱及主子通讯方法，还提供了预加载的能力\\n- wujie：使用 shadowDom 隔离 css，使用空的 iframe 隔离 js，通讯使用的是 proxy\\n- micro-app：初期基于 webcomponent + qiankun js 沙箱的微前端方案，后基于 iframe 实现 js 沙箱\\n\\n:::code-group\\n\\n```js [single-spa]\\n// single-spa\\nimport { registerApplication, start } from \'single-spa\';\\n\\nregisterApplication(\\n  \'app1\',\\n  () => import(\'path/to/app1\'),\\n  location => location.pathname.startsWith(\'/app1\')\\n);\\n\\nstart();\\n\\nexport const bootstrap = async function () {\\n  console.log(\'应用正在启动\');\\n};\\nexport const mount = async function () {};\\nexport const unmount = async function () {\\n  console.log(\'应用正在卸载\');\\n  document.body.removeChild(childContainer);\\n};\\n```\\n\\n```js [qiankun]\\n// 主应用\\nimport { registerMicroApps, start } from \'qiankun\';\\n\\nregisterMicroApps([\\n  {\\n    name: \'app1\',\\n    entry: \'//localhost:7100\',\\n    container: \'#container\',\\n    activeRule: \'/app1\'\\n  },\\n  {\\n    name: \'app2\',\\n    entry: \'//localhost:7200\',\\n    container: \'#container\',\\n    activeRule: \'/app2\'\\n  }\\n]);\\n\\nstart();\\n\\n// 子应用\\nexport async function mount(props) {\\n  ReactDOM.render(\\n    <App />,\\n    props.container ? props.container.querySelector(\'#root\') : document.getElementById(\'root\')\\n  );\\n}\\n```\\n\\n```js [模块联邦]\\n// 模块联邦\\n// 模块提供方\\n// webpack.config.js\\nmodule.exports = {\\n  // ...\\n  plugins: [\\n    new ModuleFederationPlugin({\\n      name: \'app1\',\\n      filename: \'remoteEntry.js\',\\n      exposes: {\\n        \'./Button\': \'./src/Button\'\\n      }\\n    })\\n  ]\\n};\\n\\n// 模块消费方\\n// webpack.config.js\\nmodule.exports = {\\n  // ...\\n  plugins: [\\n    new ModuleFederationPlugin({\\n      name: \'app2\',\\n      remotes: {\\n        app1: \'app1@http://localhost:3001/remoteEntry.js\'\\n      }\\n    })\\n  ]\\n};\\n```\\n\\n:::\\n\\n以 qiankun 为代表的方案\\n\\n> [!TIP]\\n>\\n> - 监听路由自动的加载、卸载当前路由对应的子应用\\n> - 完备的沙箱方案，js 沙箱做了 SnapshotSandbox、LegacySandbox、ProxySandbox 三套渐进增强方案，css 沙箱做了两套 strictStyleIsolation、experimentalStyleIsolation 两套适用不同场景的方案\\n> - 路由保持，浏览器刷新、前进、后退，都可以作用到子应用\\n> - 应用间通信简单，全局注入\\n\\n> [!CAUTION]\\n>\\n> - 基于路由匹配，无法同时激活多个子应用，也不支持子应用保活\\n> - 改造成本较大，从 webpack、代码、路由等等都要做一系列的适配\\n> - css 沙箱无法绝对的隔离，js 沙箱在某些场景下执行性能下降严重\\n> - 无法支持 vite 等 ESM 脚本运行\\n\\n以 wujie 为代表的方案\\n\\n:::tip\\n\\n1. 多应用同时激活在线。\\n\\n- 框架具备同时激活多应用，并保持这些应用路由同步的能力\\n\\n2. 组件式的使用方式。\\n\\n- 无需注册，更无需路由适配，在组件内使用，跟随组件装载、卸载\\n\\n3. 应用级别的 keep-alive。\\n\\n- 子应用开启保活模式后，应用发生切换时整个子应用的状态可以保存下来不丢失，结合预执行模式可以获得类似 ssr 的打开体验\\n\\n4. 纯净无污染。\\n\\n- 无界利用 iframe 和 webcomponent 来搭建天然的 js 隔离沙箱和 css 隔离沙箱\\n- 利用 iframe 的 history 和主应用的 history 在同一个 top-level browsing context 来搭建天然的路由同步机制\\n- 副作用局限在沙箱内部，子应用切换无需任何清理工作，没有额外的切换成本\\n\\n5. 性能和体积兼具。\\n\\n- 子应用执行性能和原生一致，子应用实例 instance 运行在 iframe 的 window 上下文中，避免 with(proxyWindow){code}这样指定代码执行上下文导致的性能下降，但是多了实例化 iframe 的一次性的开销，可以通过 preload 提前实例化\\n- 体积比较轻量，借助 iframe 和 webcomponent 来实现沙箱，有效的减小了代码量\\n\\n6. 开箱即用。\\n\\n- 不管是样式的兼容、路由的处理、弹窗的处理、热更新的加载，子应用完成接入即可开箱即用无需额外处理，应用接入成本也极低\\n  :::\\n\\n### 4. 模块联邦\\n\\n模块联邦使多个独立的构建可以形成一个应用程序。这些独立的构建不会相互依赖，因此可以单独开发和部署它们。去中心化的思路，每个应用都可以是提供者和使用者，不同应用间可以实现共同依赖的复用，避免重复加载。\\n\\n::: danger\\n\\n- 使用成本高，配置项繁琐\\n- 仅提供了共享模块的能力，其余的问题如 js 沙箱、css 沙箱、跨应用状态共享、共享模块 ts 声明都需要自行解决\\n  :::\\n\\n百度 emp 是基于模块联邦的微前端解决方案，在共享模块能力之上提供了更多的特性支持，如远程拉取 ts 声明文件、跨应用状态共享、跨框架组件调用。但其核心依然是面向模块共享，需要自行实现 js、css 沙箱\\n\\n## 个推中台业务微前端落地\\n\\n### 业务背景介绍\\n\\n中台业务部门提供通用的大数据能力，在给业务部门赋能的同时，自身也沉淀了一套大数据操作系统\\n\\n![数据智能操作系统](./images/middle-ground.png)\\n![业务赋能](./images/solution.png)\\n![介绍](./images/intro.png)\\n\\n### 微前端为团队带来了什么价值\\n\\n1. 既独立又统一\\n\\n- 主应用统一引入皮肤包。子应用统一使用 css 变量，仅修改主应用即可完成所有应用的皮肤新增、切换\\n- 主应用统一做数据埋点。子应用无需做任何改动\\n- 统一的全局业务、配置管理\\n\\n基座。作为微前端的入口，负责登录校验、权限配置、部门管理、用户管理等所有公共的模块，并向子应用下发诸如皮肤变量、用户信息、公用状态等数据\\n\\n![首页](./images/index.png)\\n\\n2. 灵活的业务场景构想\\n\\n- 自由组合子应用页面。细分到子应用菜单级别，用户可自定义创建拖拽创建页面组合即“自定义应用”，实现场景化、定制化的业务流\\n- 自由嵌套子应用组件。每个应用自身作为子应用接入的同时，还可提供自身的组件，极大减少业务开发量\\n- 定制化部署。对于不同客户的定制化部署需求，无需多次打包，一份配置项即可完成子应用的接入与否\\n- 对现有业务的整合。高效、快速的将现有业务集成，聚合成如工作流\\n\\n建模平台。子应用接入运行\\n\\n![建模平台](./images/modeling.png)\\n\\n机器学习平台。子应用嵌套\\n![机器学习平台](./images/word-cloud.png)\\n\\n应用市场。子应用页面自由组合\\n![应用市场](./images/app-market.png)\\n\\n3. 独立开发、部署带来的便利\\n\\n- 独立仓库、独立团队，并行开发、独立打包提测，能够更加快速且针对性地响应客户需求。\\n- 兼容不同技术栈。对于远古项目使用的老旧技术栈能够快速接入，已接入项目技术栈重构也可以按项目逐个迭代，甚至可以进一步按模块拆分，颗粒度更细\\n- 降低单个项目复杂度，减少维护成本\\n- 安全。沙箱的存在使得不同技术栈项目的渐进式融合更加方便，且风险降低\\n\\n### 微前端带来了什么问题\\n\\n1. 多应用运行与单应用运行行为不一致的问题。single-spa 重写了某些原生方法，比如 history.push，使其必然触发 popstate 事件，会导致路由守卫等路由相关行为不符合正常的预期\\n2. 微前端提供了沙箱，但各应用间并非完完全全的隔离。如 localStorage、sessionStorage、history 等都是共用的，需要针对各个共用部分，拉齐团队规范，避免出现如 A 团队往 localStorage 中存了变量被 B 团队覆盖的问题\\n3. 各团队独立打包，存在多余的代码引入，且版本可能不一。A、B 团队都使用了 vue 技术栈，各自本地打包\\n4. 共有问题的修改成本高。子应用统一使用了某组件库，但该组件库仅为单体应用设计，并未考虑多应用实例，导致多应用场景下出现问题，如果子应用是自行打包，需要在组件库修改完后，子应用逐个更新依赖并部署。同时，由于项目的负责团队不同，往往涉及到非常长的沟通流程\\n\\n## 我们真的需要微前端吗\\n\\n如果你不知道自己是否需要用微前端，那么大概率是不需要\\n\\n- [2023 微前端技术方案选型](https://juejin.cn/post/7236021829000691771#heading-10)\\n- [微前端方案解析](https://lianpf.github.io/posts/frontend-develop/microfrontend_framework_compare#1%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%a1%88-2)\\n\\n## qiankun 是怎么做 js 隔离的\\n\\nsandbox，参数默认为 true，对于 js 隔离，默认使用 proxy 沙箱，有个文档上没写的隐藏参数 loose，区分使用 legacySandbox 和 proxySandbox\\n\\n```ts\\ntype QiankunSpecialOpts = {\\n  /**\\n   * @deprecated internal api, don\'t used it as normal, might be removed after next version\\n   */\\n  $$cacheLifecycleByAppName?: boolean;\\n  prefetch?: PrefetchStrategy;\\n  sandbox?:\\n    | boolean\\n    | {\\n        strictStyleIsolation?: boolean;\\n        experimentalStyleIsolation?: boolean;\\n        /**\\n         * @deprecated We use strict mode by default\\n         */\\n        loose?: boolean;\\n        /**\\n         * use speed sandbox mode, enabled by default from 2.9.0\\n         */\\n        speedy?: boolean;\\n        patchers?: Patcher[];\\n      };\\n  /*\\n    with singular mode, any app will wait to load until other apps are unmouting\\n    it is useful for the scenario that only one sub app shown at one time\\n  */\\n  singular?: boolean | ((app: LoadableApp<any>) => Promise<boolean>);\\n  /**\\n   * skip some scripts or links intercept, like JSONP\\n   */\\n  excludeAssetFilter?: (url: string) => boolean;\\n\\n  globalContext?: typeof window;\\n};\\n```\\n\\n```ts\\nconst useLooseSandbox = typeof sandbox === \'object\' && !!sandbox.loose;\\n// enable speedy mode by default\\nconst speedySandbox = typeof sandbox === \'object\' ? sandbox.speedy !== false : true;\\nlet sandboxContainer;\\nif (sandbox) {\\n  sandboxContainer = createSandboxContainer(\\n    appInstanceId,\\n    // FIXME should use a strict sandbox logic while remount, see https://github.com/umijs/qiankun/issues/518\\n    initialAppWrapperGetter,\\n    scopedCSS,\\n    useLooseSandbox,\\n    excludeAssetFilter,\\n    global,\\n    speedySandbox\\n  );\\n  // 用沙箱的代理对象作为接下来使用的全局对象\\n  global = sandboxContainer.instance.proxy as typeof window;\\n  mountSandbox = sandboxContainer.mount;\\n  unmountSandbox = sandboxContainer.unmount;\\n}\\n```\\n\\nqinakun 在创建沙箱时有以下代码\\n\\n```ts\\nfunction createSandboxContainer(\\n  appName: string,\\n  elementGetter: () => HTMLElement | ShadowRoot,\\n  scopedCSS: boolean,\\n  useLooseSandbox?: boolean,\\n  excludeAssetFilter?: (url: string) => boolean,\\n  globalContext?: typeof window,\\n  speedySandBox?: boolean\\n) {\\n  let sandbox: SandBox;\\n  if (window.Proxy) {\\n    // 如果浏览器支持Proxy，使用LegacySandBox或者ProxySandbox\\n    sandbox = useLooseSandbox\\n      ? new LegacySandbox(appName, globalContext)\\n      : new ProxySandbox(appName, globalContext, { speedy: !!speedySandBox });\\n  } else {\\n    // 否则使用SnapshotSandBox\\n    sandbox = new SnapshotSandbox(appName);\\n  }\\n\\n  // ...\\n}\\n```\\n\\n### 快照沙箱\\n\\n基于 diff 实现，只适用单例，且会污染 window\\n\\n原理：将 window 的快照信息存到 windowSnapshot 中，将应用对于 window 属性的丢该记录到 modifyPropsMap 中，加载应用时用来还原，卸载应用时还原 window\\n\\n### 代理沙箱\\n\\n#### legacySandbox\\n\\n单例，跟快照沙箱差不多，也会污染 window，但是性能比快照好\\n\\n#### ProxySandbox\\n\\n创建了 fakeWindow，set 操作都在 fakeWindow 上，取值优先从 fakeWindow 上取，不会污染 window，且支持多例\\n\\n需要注意对于 window 的拷贝是浅拷贝，一些对象属性如 history，主子应用是共用的\\n\\n## qiankun 是怎么做 css 隔离的\\n\\nsandbox 参数，有两个是关于 css 的，strictStyleIsolation 默认 false、experimentalStyleIsolation 默认 false\\n\\nstrictStyleIsolation 为 true 时，用 shadowDom 隔离，shadowDom 的特点是：\\n\\n- 影子节点内的导入样式不会影响外层\\n- mode 为 closed 时，外层无法获取影子节点内的元素\\n- 影子节点内的元素样式会继承其宿主元素的样式\\n- 影子节点内的元素无法被外层选择器选中\\n\\nexperimentalStyleIsolation 为 true 时，类似 vue 的 scoped 实现，通过属性选择器隔离\\n","frontmatter":{},"url":"/front-end/micro-front/"},{"src":"# 小程序\\n\\n主要是微信小程序\\n\\n## 踩坑记录\\n\\n### 单页模式，提示无法触发\\n\\n小程序转发到朋友圈，会进入单页模式，该模式下，大多数内置 api 被禁用，调用会提示“请前往小程序使用完整功能”，在特定情况下无法触发该提示\\n\\n```typescript\\n// 能触发提示\\nsetTimeout(() => {\\n  wx.navigateTo({ url: \'test\' });\\n});\\n\\n// 无法触发提示\\nsetTimeout(() => {\\n  wx.navigateTo({ url: \'test\' });\\n}, 100);\\n```\\n\\n出现在按钮调用 debounce 函数包裹的业务逻辑中，可以使用 lodash 提供的 debounce 的 leading:true 设置点击立即触发来解决\\n\\n### 遮罩层导致的 ios 键盘无法呼出的问题\\n\\n```html\\n<van-overlay>\\n  <van-field focus=\\"{{openKeyBoard}}\\" />\\n  <van-button disabled=\\"{{disabled}}\\" bind:click=\\"handleSubmit\\">发送</van-button>\\n</van-overlay>\\n```\\n\\n- 使用 van-overlay，将 openKeyBoard 置为 true，ios、鸿蒙皆无法唤起键盘\\n- 使用微信官方提供的 page-container 组件，安卓、鸿蒙可唤起键盘，ios 不能，键盘弹出即消失\\n- 自行使用 fixed 实现遮罩，键盘呼出正常，发送按钮点击无效，使用 bind:tap + 事件函数逻辑中判断是否禁用解决\\n","frontmatter":{},"url":"/front-end/miniprogram/"},{"src":"---\\ntitle: node\\ndesc: 《JavaScript设计模式》、《大话设计模式》笔记\\nkeywords: 设计模式、笔记\\ndate: 2020-02-17 01:01:00\\ncover: https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg\\n---\\n\\n# nodejs\\n\\n## nodejs 是什么？\\n\\n不是 web 框架，也不是编程语言，而是一个将多种技术组合起来的平台\\n用到了 v8 引擎，libuv，c/c++实现的 c-ares、http-parser、OpenSSL、zlib 等\\n![NodeJS的API.png](./images/nodejs-API.png)\\n源代码看 0.10 版本，因为使用了很久一段时间\\n\\n## nodejs bindings\\n\\n- 为了让 js 能够调用 c++库，需要对其进行封装，使它符合某些要求，如对 http_parser 封装为 http_parser_bindings.cpp\\n- 用 node 提供的编译工具将其编译为.node 文件，于是 js 可以直接 require 这个.node 文件\\n- binding 是 js 调用 c++库的桥梁\\n\\n[官方示例](http://nodejs.cn/api/addons.html#addons_function_arguments)\\n\\n## libuv&v8\\n\\n### libuv\\n\\n- libuv 让 nodejs 具备跨平台的异步 IO 能力\\n- 因为 FreeBSD 系统上有 kqueue、windows 上有 IOCP、Linux 上有 epoll，nodejs 之父 Ryan 为了实现一个跨平台的异步 I/O 库写了 libuv，会根据系统自动选择合适的方案\\n- 可以用于 TCP/UDP/DNS/文件等异步操作\\n\\n### v8\\n\\n- 将 js 源代码变成本地代码并执行\\n- 维护调用栈，确保 JS 的执行顺序\\n- 内存管理，为所有对象分配内存\\n- 垃圾回收，重复利用无用的内存\\n- 实现 JS 的标准库\\n\\n注意点：\\n\\n- v8 不提供 DOM API，dom 是浏览器提供的\\n- v8 执行 JS 是单线程的\\n- 可以开启两个线程分别执行 JS\\n- V8 本身是包含多个线程的，如垃圾回收为单独线程\\n- 自带 Event Loop，但 nodejs 基于 libuv 实现了一版\\n\\n## nodejs Event Loop 简述\\n\\n事件存在优先级，处理起来分先后\\n操作系统可以触发事件，JS 可以处理事件，Event Loop 就是对事件处理的顺序管理\\n\\n--\\n\\n![timers.png](./images/event-loop.png)\\n\\n- poll 阶段处理大部分的请求\\n- timers 检查计时器\\n- poll 轮询，检查系统事件\\n- check 检查 setImmediate 回调\\n- 其他阶段用得较少\\n","frontmatter":{"title":"node","desc":"《JavaScript设计模式》、《大话设计模式》笔记","keywords":"设计模式、笔记","date":"2020-02-17T01:01:00.000Z","cover":"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg"},"url":"/front-end/nodejs/"},{"src":"## 基于 Quill.js 拆解富文本编辑器设计思想\\n\\n---\\n\\n## 你会怎么设计一个富文本编辑器？\\n\\n- 数据驱动 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"1\\" -->\\n- 模块化架构可插拔 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"2\\" -->\\n- 一致性 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"3\\" -->\\n\\n---\\n\\n**思考：如何表示富文本内容？**\\n\\n- 符合直觉的树形结构 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"1\\" -->\\n\\n```json\\n// 我们可能想到的结构\\n{\\n  \\"id\\": \\"132123123\\",\\n  \\"type\\": \\"paragraph\\",\\n  \\"content\\": \\"Hello World\\",\\n  \\"format\\": { \\"bold\\": true },\\n  \\"children\\": [\\n    {\\n      \\"id\\": \\"132123123\\",\\n      \\"type\\": \\"paragraph\\",\\n      \\"content\\": \\"Hello World\\",\\n      \\"format\\": { \\"bold\\": true }\\n    }\\n  ]\\n}\\n```\\n\\n---\\n\\n**实际实现：**\\n\\n```json\\n// Slate.js - 树形嵌套结构\\n[\\n  {\\n    \\"type\\": \\"paragraph\\",\\n    \\"children\\": [\\n      { \\"text\\": \\"Hello \\" },\\n      { \\"text\\": \\"World\\", \\"bold\\": true }\\n    ]\\n  }\\n]\\n\\n// TipTap - 基于 ProseMirror 的 JSON 文档\\n{\\n  \\"type\\": \\"doc\\",\\n  \\"content\\": [\\n    {\\n      \\"type\\": \\"paragraph\\",\\n      \\"content\\": [\\n        { \\"type\\": \\"text\\", \\"text\\": \\"Hello \\" },\\n        { \\"type\\": \\"text\\", \\"marks\\": [{ \\"type\\": \\"bold\\" }], \\"text\\": \\"World\\" }\\n      ]\\n    }\\n  ]\\n}\\n```\\n\\n---\\n\\n**思考：如何设计架构？**\\n\\n- 模块化、可插拔 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"1\\" -->\\n\\n```ts\\n// 可能的设计\\nclass Editor {\\n  plugins: Plugin[] = [];\\n  registerPlugin(plugin: Plugin) {\\n    this.plugins.push(plugin);\\n  }\\n}\\n```\\n\\n---\\n\\n**实际实现：**\\n\\n```ts\\n// TipTap - 扩展系统\\nimport { Editor } from \'@tiptap/core\';\\nimport Bold from \'@tiptap/extension-bold\';\\nimport Image from \'@tiptap/extension-image\';\\n\\nconst editor = new Editor({\\n  extensions: [Bold, Image.configure({ inline: true })]\\n});\\n\\n// Quill - Blot 模块系统\\nimport Quill from \'quill\';\\nimport { ImageBlot } from \'./blots/ImageBlot\';\\nQuill.register(ImageBlot);\\n\\n// wangEditor - 菜单和命令分离\\neditor.config.menus = [\'bold\', \'italic\', \'image\'];\\n```\\n\\n**为什么模块化？** <!-- .element: class=\\"fragment\\" data-fragment-index=\\"1\\" -->\\n\\n体积可控、功能灵活、易于扩展 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"2\\" -->\\n\\n---\\n\\n**思考：如何保证行为一致？**\\n\\n- Web 端：浏览器差异 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"1\\" -->\\n- 跨端：不同宿主环境（Web、移动端、桌面端）渲染差异 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"2\\" -->\\n\\n```ts\\n// 可能的设计\\nclass Bold {\\n  // 统一操作接口，屏蔽底层差异\\n  format(type: string, value: any) {\\n    // 浏览器差异处理\\n    // 跨端渲染适配\\n  }\\n}\\n```\\n\\n---\\n\\n**实际实现：**\\n\\n#### 跨浏览器一致性处理\\n\\n```ts\\n// Quill - Parchment 抽象层统一 DOM 操作\\nclass BoldBlot extends InlineBlot {\\n  static create() {\\n    // 统一创建 <strong>，不依赖浏览器默认行为\\n    return document.createElement(\'strong\');\\n  }\\n  // 所有浏览器都使用相同的标签和结构\\n}\\n\\n// Slate - 操作抽象 + 标准化选区\\nTransforms.setNodes(editor, { bold: true });\\n// 内部统一处理：\\n// 1. 标准化选区（normalizeSelection）\\n// 2. 统一 DOM 操作（不依赖 execCommand）\\n// 3. 处理浏览器差异（Chrome/Firefox/Safari）\\n\\n// TipTap/ProseMirror - Schema 规范化\\nconst schema = new Schema({\\n  marks: {\\n    bold: { parseDOM: [{ tag: \'strong\' }, { tag: \'b\' }] }\\n    // 统一将 <b> 和 <strong> 解析为 bold mark\\n  }\\n});\\n```\\n\\n---\\n\\n#### 跨端一致性处理\\n\\n```ts\\n// TipTap - 统一编辑器接口，不同渲染器\\n// Web 端\\nimport { useEditor } from \'@tiptap/react\';\\nconst editor = useEditor({ extensions: [...] });\\n\\n// React Native 端\\nimport { useEditor } from \'@tiptap/react-native\';\\nconst editor = useEditor({ extensions: [...] });\\n// 相同的 API，不同的底层渲染实现\\n\\n// Slate - 自定义渲染器\\n<Slate editor={editor}>\\n  <Editable\\n    renderElement={renderElement}  // Web: DOM\\n    renderLeaf={renderLeaf}\\n  />\\n</Slate>\\n\\n// React Native\\n<Slate editor={editor}>\\n  <Editable\\n    renderElement={renderElementRN}  // RN: View/Text\\n    renderLeaf={renderLeafRN}\\n  />\\n</Slate>\\n// 相同的数据模型，不同的渲染层\\n\\n// Quill - 数据模型统一，渲染层可替换\\nconst delta = editor.getContents(); // 获取 Delta\\n// Delta 可以在任何平台使用，只需实现对应的渲染器\\n```\\n\\n---\\n\\n### 基本与我们的设想一致 😀\\n\\n---\\n\\n### quill 是什么？\\n\\n一个高度可定制的免费开源富文本编辑器 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"1\\" -->\\n\\n---\\n\\n### 启用一个 quill 编辑器\\n\\n```js\\nconst quill = new Quill(\'#editor\', {\\n  modules: { toolbar: true },\\n  theme: \'snow\'\\n});\\n```\\n\\n---\\n\\n## 一、概述\\n\\n---\\n\\n### 核心设计理念\\n\\n- **数据驱动**：Delta 数据模型\\n- **模块化架构**：易于扩展和定制\\n- **跨浏览器一致性**：Parchment 抽象层\\n\\n---\\n\\n![](./images/quill-detail.jpeg)\\n\\n---\\n\\n## 二、Delta 数据模型\\n\\n---\\n\\n**Delta = 极为紧凑的 JSON 数据结构**\\n\\n```json\\n{\\n  \\"ops\\": [\\n    { \\"insert\\": \\"Hello \\" },\\n    { \\"insert\\": \\"World\\", \\"attributes\\": { \\"bold\\": true } },\\n    { \\"insert\\": \\"\\\\n\\" }\\n  ]\\n}\\n```\\n\\n---\\n\\n### Delta 描述富文本\\n\\n```json\\n{\\n  \\"ops\\": [\\n    { \\"insert\\": { \\"image\\": \\"https://quilljs.com/assets/images/logo.svg\\" } },\\n    { \\"insert\\": \\"\\\\n\\" },\\n    { \\"insert\\": { \\"formula\\": \\"e=mc^2\\" } }\\n  ]\\n}\\n```\\n\\n可以自定义任何富文本内容和格式，比如思维导图、3D 模型等等 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"1\\" -->\\n\\n---\\n\\n### Delta 的三种操作类型\\n\\n| 操作       | 说明         | 示例                                              |\\n| ---------- | ------------ | ------------------------------------------------- |\\n| **insert** | 插入内容     | `{ \\"insert\\": \\"text\\" }`                            |\\n| **retain** | 保留并格式化 | `{ \\"retain\\": 5, \\"attributes\\": { \\"bold\\": true } }` |\\n| **delete** | 删除内容     | `{ \\"delete\\": 3 }`                                 |\\n\\n监听`text-change`事件，可以看到 quill 对用户每一步操作的定义 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"1\\" -->\\n\\n---\\n\\n### Delta 格式与操作变换的精妙配合\\n\\nDelta 记录的是`操作日志`而非`快照`\\n\\n```javascript\\n// 插入文本\\"hello\\"并设置加粗\\n{ \\"ops\\": [{ \\"insert\\": \\"hello\\", \\"attributes\\": { \\"bold\\": true } }] }\\n// 删除3个字符\\n{ \\"ops\\": [{ \\"delete\\": 3 }] }\\n// 保留5个字符（无变更），再插入\\"world\\"\\n{ \\"ops\\": [{ \\"retain\\": 5 }, { \\"insert\\": \\"world\\" }] }\\n```\\n\\n- 极高效的存储，100 次编辑日志远远小于 100 份数据/文档快照 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"2\\" -->\\n- 极低计算成本，反向 Delta，而非整个数据快照的重新加载 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"3\\" -->\\n- 数据不可变，每一步操作都是增量，天然对协同编辑友好 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"4\\" -->\\n\\n---\\n\\n**对比其他编辑器：**\\n\\n- Quill/Draft：操作日志型（Delta/ContentState），存储高效 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"2\\" -->\\n- Slate/TipTap：状态驱动型（树形结构），类型安全 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"3\\" -->\\n- TinyMCE/UEditor：快照型（HTML），简单但存储成本高 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"4\\" -->\\n\\n---\\n\\n## 三、Parchment 文档模型\\n\\n---\\n\\n### Blot 的层次结构\\n\\n![](./images/parchment.jpeg)\\n\\n---\\n\\n### 架构思想\\n\\n- 与 DOM 平行的抽象树 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"1\\" -->\\n- Blot 类型系统（类似 DOM Node）<!-- .element: class=\\"fragment\\" data-fragment-index=\\"2\\" -->\\n- 跨浏览器一致性 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"3\\" -->\\n\\n**对比其他编辑器：**<!-- .element: class=\\"fragment\\" data-fragment-index=\\"4\\" -->\\n\\n- Quill：Parchment/Blot 抽象层 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"5\\" -->\\n- ProseMirror/TipTap：Schema + Node 类型系统 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"6\\" -->\\n- Slate：Node + Element 树形结构 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"7\\" -->\\n\\n---\\n\\n### Blot 生命周期\\n\\n```javascript\\nclass CustomBlot extends Parchment.Inline {\\n  static tagName = \'DIV\';\\n  static create(value) {\\n    /* 1. 自定义创建 DOM */\\n  }\\n\\n  optimize() {\\n    /* 4. 优化合并 */\\n  }\\n\\n  attach() {\\n    /* 新建时触发 */\\n  }\\n\\n  detach() {\\n    /* 删除时触发 */\\n  }\\n}\\n```\\n\\n---\\n\\n### 关键 Blot 类型\\n\\n#### ScrollBlot（文档根）\\n\\n- 对应 `<div class=\\"ql-editor\\">`\\n- 管理整个文档的 Delta ↔ DOM 转换\\n\\n#### BlockBlot（块级）\\n\\n- 段落、标题等块级元素\\n- 每个块以 `\\\\n` 结尾\\n\\n---\\n\\n## 关键 Blot 类型\\n\\n#### InlineBlot（内联格式）\\n\\n- 加粗、斜体、颜色等文本格式\\n- 可嵌套\\n\\n#### EmbedBlot（嵌入）\\n\\n- 图片、视频等不可编辑内容\\n- 在 Delta 中表示为对象：`{ \\"insert\\": { \\"image\\": \\"url\\" } }`\\n\\n---\\n\\n### Parchment 的优化机制\\n\\n**节点合并**\\n\\n```html\\n<!-- 优化前 -->\\n<p><strong>Hello</strong><strong>World</strong></p>\\n\\n<!-- 优化后 -->\\n<p><strong>HelloWorld</strong></p>\\n```\\n\\n---\\n\\n## 四、实现原理\\n\\n---\\n\\n### 编辑流程\\n\\n#### 用户输入 → Delta\\n\\n```\\nDOM 变化 → MutationObserver → 计算 Delta → 触发事件\\n```\\n\\n#### Delta → DOM 渲染\\n\\n```\\nDelta → Blot 操作 → 计算更新范围 → 最小化 DOM 更新 → 优化\\n```\\n\\n---\\n\\n### MutationObserver 机制\\n\\n```javascript\\n// 监听 DOM 变化\\nobserver.observe(root, {\\n  childList: true,\\n  subtree: true,\\n  characterData: true\\n});\\n\\n// 双向同步\\nDOM 变化 → 计算 Delta → 更新内部状态\\n```\\n\\n**对比其他编辑器：**<!-- .element: class=\\"fragment\\" data-fragment-index=\\"1\\" -->\\n\\n- Quill：MutationObserver 监听 DOM → 计算 Delta <!-- .element: class=\\"fragment\\" data-fragment-index=\\"2\\" -->\\n- Slate：React 状态驱动 → 统一 DOM 操作 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"3\\" -->\\n- ProseMirror：Transaction 系统 → 状态更新 → 视图渲染 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"4\\" -->\\n\\n---\\n\\n### 撤销/重做实现\\n\\n```javascript\\nclass History {\\n  record(change, oldDelta) {\\n    this.stack.push({\\n      undo: change.invert(oldDelta), // 反向操作\\n      redo: change\\n    });\\n  }\\n\\n  undo() {\\n    this.quill.updateContents(item.undo);\\n  }\\n}\\n```\\n\\n基于 Delta 的不可变性，保存操作历史<!-- .element: class=\\"fragment\\" data-fragment-index=\\"1\\" -->\\n\\n---\\n\\n**对比其他编辑器：**<!-- .element: class=\\"fragment\\" data-fragment-index=\\"1\\" -->\\n\\n- Quill/Draft：操作反转（invert），存储操作序列<!-- .element: class=\\"fragment\\" data-fragment-index=\\"2\\" -->\\n- Slate：状态快照栈，存储完整状态<!-- .element: class=\\"fragment\\" data-fragment-index=\\"3\\" -->\\n- ProseMirror：Transaction 历史，支持分支历史<!-- .element: class=\\"fragment\\" data-fragment-index=\\"4\\" -->\\n\\n---\\n\\n## 五、定制逻辑\\n\\n---\\n\\n### 自定义 Blot 示例\\n\\n```javascript\\nclass ImageBlot extends Parchment.EmbedBlot {\\n  static blotName = \'image\';\\n  static tagName = \'img\';\\n\\n  static create(value) {\\n    const node = super.create(value);\\n    const wrapper = document.createElement(\'div\');\\n    wrapper.appendChild(node);\\n    wrapper.style.display = \'inline-block\';\\n    wrapper.style.maxWidth = \'100%\';\\n    wrapper.style.verticalAlign = \'top\';\\n    return wrapper;\\n  }\\n\\n  value(domNode) {\\n    return domNode.src;\\n  }\\n}\\n\\nParchment.register(ImageBlot);\\n```\\n\\n---\\n\\n### 自定义 Blot 关键步骤\\n\\n1. 继承对应的 Blot 基类 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"1\\" -->\\n2. 定义 blotName 和 tagName <!-- .element: class=\\"fragment\\" data-fragment-index=\\"2\\" -->\\n3. 实现 create、value <!-- .element: class=\\"fragment\\" data-fragment-index=\\"3\\" -->\\n4. 注册 Blot <!-- .element: class=\\"fragment\\" data-fragment-index=\\"4\\" -->\\n\\n---\\n\\n### 自定义工具栏\\n\\n```javascript\\n// 方式1：配置工具栏容器和处理器\\nconst quill = new Quill(\'#editor\', {\\n  modules: {\\n    toolbar: {\\n      container: \'#toolbar\', // 自定义工具栏容器\\n      handlers: {\\n        custom: function () {\\n          const range = this.quill.getSelection();\\n          this.quill.formatText(range, \'custom\', value);\\n        }\\n      }\\n    }\\n  }\\n});\\n\\n// 方式2：HTML 定义工具栏，使用 ql-{format} 类名\\n// <div id=\\"toolbar\\">\\n//   <button class=\\"ql-bold\\"></button>\\n//   <button class=\\"ql-italic\\"></button>\\n//   <button class=\\"ql-custom\\"></button>\\n// </div>\\n\\n// 方式3：数组配置工具栏\\nconst quill = new Quill(\'#editor\', {\\n  modules: {\\n    toolbar: [\\n      [\'bold\', \'italic\'],\\n      [{ header: [1, 2, 3, false] }],\\n      [\'custom\'] // 自定义格式\\n    ]\\n  }\\n});\\n```\\n\\n---\\n\\n### 自定义模块\\n\\n```javascript\\nclass CustomModule {\\n  constructor(quill, options) {\\n    this.quill.on(\'text-change\', this.onTextChange);\\n    this.quill.on(\'selection-change\', this.onSelectionChange);\\n  }\\n}\\n\\n// 使用\\nconst quill = new Quill(\'#editor\', {\\n  modules: {\\n    custom: {\\n      /* 配置 */\\n    }\\n  }\\n});\\n```\\n\\n---\\n\\n### 自定义快捷键\\n\\n```javascript\\nconst Keyboard = Quill.import(\'modules/keyboard\');\\n\\nKeyboard.addBinding({\\n  key: \'B\',\\n  shortKey: true,\\n  handler: function (range, context) {\\n    this.quill.format(\'bold\', !context.format.bold);\\n  }\\n});\\n```\\n\\n---\\n\\n### 自定义粘贴处理\\n\\n```javascript\\nclass CustomClipboard extends Clipboard {\\n  onPaste(e) {\\n    const html = e.clipboardData.getData(\'text/html\');\\n    const cleanedHTML = this.cleanHTML(html); // 清理\\n    const delta = this.quill.clipboard.convert(cleanedHTML);\\n    this.quill.updateContents(delta, \'user\');\\n  }\\n}\\n\\nQuill.register(\'modules/clipboard\', CustomClipboard, true);\\n```\\n\\n---\\n\\n## 六、最佳实践\\n\\n---\\n\\n### 数据结构设计\\n\\n✅ **优先使用 Delta**\\n\\n- 存储、传输都用 Delta 格式\\n- 避免直接操作 DOM\\n\\n✅ **保持不可变性**\\n\\n- 禁止直接修改 Delta 对象\\n- 使用 `compose`、`transform` 等方法\\n\\n---\\n\\n## 七、总结\\n\\n---\\n\\n### 富文本编辑器的共性设计\\n\\n---\\n\\n**1. 数据模型抽象**<!-- .element: class=\\"fragment\\" data-fragment-index=\\"1\\" -->\\n\\n- 统一的数据表示（Delta/Node/Schema），与 DOM 解耦 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"2\\" -->\\n- 不可变数据结构，支持时间旅行和协同编辑 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"3\\" -->\\n\\n**2. 抽象层设计**<!-- .element: class=\\"fragment\\" data-fragment-index=\\"4\\" -->\\n\\n- 文档模型抽象（Parchment/ProseMirror/Slate），屏蔽浏览器差异 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"5\\" -->\\n- 类型系统（Blot/Node/Element），保证结构一致性<!-- .element: class=\\"fragment\\" data-fragment-index=\\"6\\" -->\\n\\n**3. 双向同步机制**<!-- .element: class=\\"fragment\\" data-fragment-index=\\"7\\" -->\\n\\n- 用户输入 → 数据模型 → DOM 渲染 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"8\\" -->\\n- DOM 变化 → 数据模型 → 状态更新 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"9\\" -->\\n\\n---\\n\\n**4. 模块化架构**<!-- .element: class=\\"fragment\\" data-fragment-index=\\"10\\" -->\\n\\n- 插件/扩展系统，按需加载功能 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"11\\" -->\\n- 命令/操作抽象，统一行为接口 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"12\\" -->\\n\\n**5. 性能优化**<!-- .element: class=\\"fragment\\" data-fragment-index=\\"13\\" -->\\n\\n- 最小化 DOM 操作，批量更新 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"14\\" -->\\n- 虚拟化渲染，处理大文档 <!-- .element: class=\\"fragment\\" data-fragment-index=\\"15\\" -->\\n\\n---\\n\\n谢谢观看 🙂\\n","frontmatter":{},"url":"/front-end/quill/"},{"src":"1. 实现以下类型（尽量使用 util type）:\\n\\n- 一类对象, 它的 value 值为 string 或者 number\\n\\n```ts\\n// 解答\\ntype union = string | number;\\n\\ninterface Obj {\\n  [key: union]: union;\\n}\\n\\n// 或者\\n\\ntype Obj1 = Record<any, union>;\\n```\\n\\n- 已知 interface T1, T2, 求类型 T3, 要求 T3 拥有 T1 和 T2 的所有属性, 对应 value 的类型也和 T1,T2 一样\\n\\n```ts\\n// 解答\\n\\ninterface T1 {\\n  name: string;\\n}\\n\\ninterface T2 {\\n  age: number;\\n}\\n\\ntype T3 = Omit<T1, keyof T2> & T2; // 如果直接使用交叉类型，会使同名属性为 nerver\\n```\\n\\n1. 求 ItemWithoutType, 要求能正确反映函数 omitType 的返回类型（尽量使用 util type）\\n\\n```ts\\ninterface Item {\\n  type: string;\\n  value: any;\\n}\\n\\n// 解答\\ntype ItemWithoutType = Omit<Item, \'type\'>;\\n\\nfunction omitType<T extends Item>(obj: T): ItemWithoutType {\\n  const result = { ...obj };\\n  delete result.type;\\n  return result;\\n}\\n```\\n\\n3. 已知函数 getAPlusB, 用 ts 限制它的入参, 使它总能符合我们的预期(返回数字)\\n\\n```ts\\ninterface PlusObj {\\n  [key: string]: any;\\n  a: number;\\n  b: number;\\n}\\n\\nfunction getAPlusB(obj: PlusObj) {\\n  return obj.a + obj.b;\\n}\\n```\\n\\n4. 考虑在工作中你碰到这样的场景: `IFoo` 来自于一个依赖库, 随着升级它可能会不断增加新的属性, 请实现 interface `IFooMapping`, 要求: 对于 `IFoo` 所有的 key, 都满足 `IFooMapping[key]` 的类型是返回为 `IFoo[key]` 的函数。 比如 `IFoo[\'a\']` 为 `string`, 则 `IFooMapping[\'a\']` 为返回类型为 `string` 的函数(如能使用泛型实现更好)\\n\\n```ts\\ninterface IFoo {\\n  a: string;\\n  b: number;\\n  // ...\\n}\\n\\n// 解答\\ntype IFooMapping<T> = {\\n  [K in keyof T]: () => T[K];\\n};\\n```\\n\\n1. 请写出 event 的类型\\n\\n```ts\\n// 答案\\ntype Foo = (event: MouseEvent) => void;\\n\\nconst foo: Foo = event => {\\n  // ...\\n};\\n\\nwindow.addEventListener(\'click\', foo);\\n```\\n\\n2. 请实现这样的泛型: 当 T 的 type 属性类型为 string 时, 得到 `{ obj: T }` , 否则得到 `null`\\n\\n```ts\\n// 答案\\ntype IFoo<T> = T extends string ? { obj: T } : null;\\n```\\n\\n```ts\\n/**\\n * extends 继承关键字\\n * 复杂类型对象，子只需包含父的属性，即符合继承关系\\n * 文档上的例子说明https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints\\n * 简单类型，ts允许使用extends关键字对类型做判断，不是严格意义上的继承\\n * String类允许被继承，继承的是一系列的String类的属性和方法\\n * 其他语言比如java，String类，被final修饰符修饰，是不可被继承和改变的\\n */\\n\\ntype Bar<T> = T extends { name: string } ? string : number;\\n\\nconst bar1: Bar<{ name: string; age: number }> = \'张三\'; // 包含父中的属性即合法\\nconst bar2: Bar<{ age: number }> = \'张三\'; // 不能将类型“string”分配给类型“number\\n\\ntype IFoo<T> = T extends string ? { obj: T } : null;\\n\\nconst foo1: IFoo<string> = { obj: \'123\' }; // ok\\nconst foo2: IFoo<\'str\'> = { obj: \'123\' }; // 不能将类型“\\"123\\"”分配给类型“\\"str\\"”\\n\\n// string 是类型，String是类\\ntype IFooStringObj<T> = T extends String ? { obj: T } : null;\\nconst foo3: IFooStringObj<\'123\'> = { obj: \'123\' }; // ok\\nconst foo4: IFooStringObj<string> = { obj: \'123\' }; // ok\\n\\ninterface FakeString extends String {\\n  a: number;\\n} // 报错，缺少一系列String的方法\\n\\ntype FakeString2 = 123 extends string // 报错，类型声明type中的extends关键字不是严格意义上的继承\\ninterface N3 extends string {} // 报错\\"string\\"仅表示类型，但在此处却作为值使用\\ninterface N4 extends String {} // ok\\n```\\n\\n3. 请用 jsdoc 在 js 中实现第一题, 建议把类型写在 .d.ts 文件中, 在 js 文件中 import 类型\\n\\n```js\\n/**\\n *\\n * @param {MouseEvent} event\\n */\\nconst foo = event => {\\n  // ...\\n  console.log(event);\\n};\\n```\\n","frontmatter":{},"url":"/front-end/ts/FAQ.html"},{"src":"---\\ntitle: node\\ndesc: 《JavaScript设计模式》、《大话设计模式》笔记\\nkeywords: 设计模式、笔记\\ndate: 2020-02-17 01:01:00\\ncover: https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg\\n---\\n\\n# typescript\\n\\n## 启用 ts\\n\\n- webpack+babel\\n\\n- vite2\\n\\n- tsc typescript compiler 执行编译，会把 ts 编译成 js\\n\\n## 类型 type vs 类 class\\n\\ntype js 基本类型 NaN、undefined、string、bool、number、symbol、bigint、object\\n\\n类比如 Array、Object，都是 object，但需要更准确的区分\\n\\nts 类型兼容 js 的类型\\n\\n## 基本语法\\n\\n```ts\\nconst a: undefined = undenfined;\\nconst b: null = null;\\nconst c: Object = {};\\nconst d: Array = [];\\n// 泛型\\nconst d: Array<string | number> = [\'1\', \'2\', 5];\\n// 函数\\nconst add1 = (a: number, b: number): number => a + b;\\nconst add2: (a: number, b: number) => number = (a, b) => a + b;\\n\\n// interface 声明多个属性\\ninterface xxx {\\n  (a: number, b: number): number;\\n  a: string;\\n}\\n```\\n\\n## TS 的类型\\n\\n```ts\\nlet a: any = \'hi\';\\n// a.name\\n\\n// unkown需要用断言\\n// let b:unknown=JSON.parse(\'{name:\'jarrett\'}\')\\n(b as { name: string }).name;\\n\\nconst print: () => void = function () {};\\n\\n// 空集，什么都没有\\nconst c: never = 12;\\n\\n// 元组，固定长度的数组，ts特有，js可随意改变数组\\n\\nlet x: [number, number] = [100, 200];\\n\\n// 枚举，一般不用，前端用 type=东|南|西|北 更香\\nenum Dir {\\n  东,\\n  南,\\n  西,\\n  北\\n}\\n\\nlet d: Dir = Dir.东; //即Dir.东是0\\n```\\n\\n## 注意点\\n\\n- typeof null 会返回 object，错误点\\n\\n- typeof funtion 会返回 function，但函数也是对象\\n\\n- class 包括 Array、Function，class 既是 value 也是 type\\n\\n```ts\\nclass A {}\\n// A可以被当作值来赋值\\nconst B = A;\\n// 左侧是类型，右侧是值\\nconst a: A = new A();\\n\\n// A的类型是object;\\n```\\n\\n## 联合类型和交差类型\\n\\n```ts\\ntype A = {\\n  name: string;\\n};\\nconst f = (n: A | string) => {};\\nA.name.toString();\\n// 存在问题，不知道何时是什么类型\\n// 用typeof判断类型再调用api，比如string的toString()\\n// ts可以在你写条件判断的时候自动推测、收窄类型\\nif (typeof n === \'string\') {\\n  A.name.toString();\\n} else {\\n}\\n```\\n\\n```ts\\ntype A = number & string; // never\\nconst a: A = 1; //报错\\n\\n// 把两个复杂类型合并\\ntype B = { name: string } & { age: number };\\n\\n// 声明div的类型\\nlet div1: HTMLDivElement;\\n```\\n\\n## 泛型\\n\\n```ts\\ntype A = \'hi\' | 123;\\ntype FNumber = F<number>;\\n\\nconst add = (a: number, b: number) => a + b;\\n\\ntype Add<T> = (a: T, b: T) => T;\\n\\n// T可代表任何类型\\nconst addN: Add<number> = (a, b) => a + b;\\nconst addS: Add<string> = (a, b) => a + b;\\n```\\n\\n```ts\\n// react的例子\\ntype P = {\\n  name: string;\\n};\\nconst App: FunctionComponent<P> = props => {\\n  props.name;\\n  return <div></div>;\\n};\\n\\n// 把泛型当作函数来理解\\n```\\n\\n```ts\\n// 重载\\ntype Add<T> = (a: T, b: T) => T;\\n\\nconst add: Add<number | string> = (a, b) => {\\n  return a + b;\\n};\\n\\n// type Add2 = (a: number, b: number) => number;\\nfunction add(a: number, b: number): number;\\nfunction add(a: string, b: string): string;\\nfunction add(a: any, b: any): any {\\n  if (typeof a === \'number\' && typeof b === \'number\') {\\n    return a + b;\\n  } else {\\n    return a + \'\' + b;\\n  }\\n}\\n```\\n\\n```ts\\n// 封装网络请求\\ntype User = {\\n  id: string | number;\\n  name: string;\\n};\\ntype CreateResource = (path: string) => {\\n  create: (attrs: Omit<Partial<User>, \'id\'>) => Promise<Response<User>>;\\n};\\nconst createResource = (path: string) => {\\n  return {\\n    create(attrs: Omit<Partial<User>, \'id\'>) {},\\n    delete() {},\\n    update() {},\\n    get() {}\\n  };\\n};\\nvar userResource = createFetcher(\'/api/v1/user\');\\n```\\n\\n## 面试题\\n\\n<!--@include: ./FAQ.md-->\\n","frontmatter":{"title":"node","desc":"《JavaScript设计模式》、《大话设计模式》笔记","keywords":"设计模式、笔记","date":"2020-02-17T01:01:00.000Z","cover":"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg"},"url":"/front-end/ts/"},{"src":"---\\ntitle: vue\\ndesc: 《JavaScript设计模式》、《大话设计模式》笔记\\nkeywords: 设计模式、笔记\\ndate: 2020-02-17 01:01:00\\ncover: https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg\\n---\\n\\n# vue\\n\\n## 为什么要使用单页面应用\\n\\n### 传统的网页应用\\n\\n---\\n\\n![](./images/browser-server.png)\\n![](./images/mvc.png)\\n传统的网页应用，浏览器作为展示层，路由处理、服务调用、页面跳转都由后端处理，即便有 ajax，但也并不是标准的单页面应用。\\n这种网页应用的重心都在后端，后端几乎包揽了 MVC，浏览器端仅是一个展示层\\n\\n### 单页面应用\\n\\n---\\n\\nMVC 前置到浏览器端，前端负责路由，各个小的组件组成页面，在路由变化时，不刷新整个页面，仅仅是组合小的组件，替换变化部分。甚至数据层也在前端，前端封装后端 API，这种情况下，后端只是提供操作数据库的 API\\n\\n### 单页面应用的优点\\n\\n---\\n\\n- 不刷新页面，相应快速，提升了用户体验\\n- 前端组件化，代码的结构和组织更加规划化，利于修改和维护，并且可以开发独立的组件库，开发时直接使用即可，极大提高了开发效率\\n- API 共享，如果要多端开发（浏览器、微信、安卓、ios），只需要修改容易变化的前端 UI，对后端 API 的调用基本是相同的，极大的降低了开发成本\\n\\n### 单页面应用的缺点\\n\\n---\\n\\n- 首次加载大量资源\\n- 提高了前端的技术门槛\\n- 不利于 SEO，因为数据在前端渲染，动态的数据不利于爬虫抓取\\n- 不方便使用浏览器自带的导航\\n\\n---\\n\\n## vue 核心\\n\\n### vue 的响应式原理\\n\\nvue2 通过数据劫持 ➕ 发布订阅模式实现数据响应式\\n主要由`Object.defineProperty`、`Observer`、`Dep`、`Watcher`实现\\n![](./images/vue-reactive.png)\\n\\n#### Observer、Dep 和 Watcher\\n\\n---\\n\\nVue 封装了一个`defineReactive`方法来对数据进行`defineProperty`改造\\n\\n```javascript\\nfunction defineReactive(obj: Object, key: string, val: any) {\\n  Object.defineProperty(obj, key, {\\n    get: function reactiveGetter() {\\n      //添加依赖\\n      dep.depend();\\n      return value;\\n    },\\n\\n    set: function reactiveSetter(newVal) {\\n      //发布\\n      dep.notify();\\n    }\\n  });\\n}\\n复制代码;\\n```\\n\\n`defineReactive`方法在改造数据的时候，数据 get 时进行依赖的添加，set 时发布\\n\\n```javascript\\nclass Observer {\\n  value: any;\\n  dep: Dep;\\n\\n  constructor (value: any) {\\n    this.value = value\\n    this.dep = new Dep()\\n    if(Array.isArray(value)){\\n      //遍历出来挨个用Observer去new一下\\n    }else{\\n       //是对象就遍历，挨个进行响应式改造改造\\n       const keys = Object.keys(obj)\\n       for (let i = 0; i < keys.length; i++) {\\n           defineReactive(obj, keys[i])\\n       }\\n    }\\n }\\n复制代码\\n```\\n\\n`Observer`的作用其实就是**数据劫持**，而 Vue 让每一个**响应式**的数据都是被`Observer`改造过的\\n\\n```javascript\\nclass Dep {\\n  static target: ?Watcher;\\n  id: number;\\n  subs: Array<Watcher>;\\n  constructor() {\\n    this.id = uid++;\\n    this.subs = [];\\n  }\\n  addSub(sub: Watcher) {\\n    this.subs.push(sub);\\n  }\\n  removeSub(sub: Watcher) {\\n    remove(this.subs, sub);\\n  }\\n  depend() {\\n    if (Dep.target) {\\n      Dep.target.addDep(this);\\n    }\\n  }\\n  notify() {\\n    const subs = this.subs.slice();\\n\\n    for (let i = 0, l = subs.length; i < l; i++) {\\n      subs[i].update();\\n    }\\n  }\\n}\\n复制代码;\\n```\\n\\n`dep`里维护一个`watcher`列表`subs`，并且有`depend`和`notify`方法，能添加`watcher`并且发布通知，在 get 数据时，添加`watcher`到`subs`，`set`数据时，遍历`subs`并挨个执行更新\\n`Watcher`  类，`addDep`添加依赖（订阅），并具有`update`方法\\n\\n```javascript\\nclass Watcher {\\n  addDep (dep: Dep) {\\n    const id = dep.id\\n    //添加依赖（订阅操作）\\n    dep.addSub(this)\\n  }\\n  update () {\\n      this.run()\\n  }\\n  run () {\\n    if (this.active) {\\n       //执行数据更新\\n    }\\n  }\\n复制代码\\n```\\n\\n## 关于对象\\n\\nvue 无法检测属性的添加或移除，对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是可以用`Vue.set(object,propertyName,value)`\\n如果要为已有对象赋值多个新的 property，应该用原对象与要混合进去的对象的 property 一起创建一个新的对象。\\n\\n```javascript\\n// 代替 `Object.assign(this.someObject, { a: 1, b: 2 })`\\nthis.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 });\\n```\\n\\n## 关于数组\\n\\n数据也不是响应式的，直接修改数组内某项和修改数组的长度都是无法被检测的。也需要用 Vue.set\\n\\n```javascript\\n// Vue.set\\nVue.set(vm.items, indexOfItem, newValue);\\n```\\n\\nvue 改写了数组的常用方法，用这些方法操作数组能使数组被检测到\\n\\n- `push()`\\n- `pop()`\\n- `shift()`\\n- `unshift()`\\n- `splice()`\\n- `sort()`\\n- `reverse()`\\n\\n## 生命周期\\n\\n生命周期钩子自动绑定 this 上下文，所以不能用尖头函数，因为箭头函数绑定了父上下文，而不是当前实例\\n\\n| 生命周期钩子                                                                              | 调用时机                                                                                                                                  |\\n| ----------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |\\n| beforeCreate                                                                              | 实例初始化后，还没有进行数据观测 (data observer) 和 event/watcher 事件配置                                                                |\\n| created                                                                                   | 实例创建完成之后立即调用，已经完成数据观测 (data observer)，property 和方法的运算，watch/event 事件回调，但还没有挂载 dom，所以$el 不可用 |\\n| beforeMount                                                                               | 挂载开始之前，render 首次被调用                                                                                                           |\\n| mounted                                                                                   | 挂载完毕时调用，此时根实例已经挂载到了某个文档元素上。但是不保证所有子组建也都被挂载，用 vm.$nextTick 可等到整个视图渲染完毕              |\\n| beforeUpdate                                                                              | 数据更新时调用，但是是在虚拟 dom 打补丁之前                                                                                               |\\n| updated                                                                                   | 虚拟 dom 重新渲染和打补丁完毕后调用。                                                                                                     |\\n| updated 不会保证所有的子组件一起被重绘，如果要等到整个视图重绘完毕，需要使用 vm.$nextTick |\\n| activated                                                                                 | kepp-alive 缓存的组建激活时调用                                                                                                           |\\n| deactivated                                                                               | keep-alive 的组件停用时调用                                                                                                               |\\n| beforeDestroy                                                                             | 实例销毁前调用，这一步里实例仍然完全可用                                                                                                  |\\n| destroyed                                                                                 | 实例销毁后调用                                                                                                                            |\\n\\n## 组件间通信\\n\\n1. 父传子用 prop\\n1. 子向父用$on和$emit，子组件通知父组件改值\\n1. 兄弟组件传值，通过父组件传递或者用 eventBus\\n\\n举例：\\n\\n```javascript\\n//Bus.js\\nimport Vue from \'vue\'\\n\\nexport default new Vue()\\n\\n//Child1.vue\\n<template>\\n    <button @click=\\"clickHandle\\"> {{n}}</button>\\n</template>\\n<script>\\nimport Event from \'../bus\'\\n\\nexport default {\\n  name: \'Child1\',\\n  data(){\\n    return{\\n      n:100\\n    }\\n  },\\n  methods: {\\n    clickHandle () {\\n      Event.$emit(\'update:count\',n)\\n    }\\n  }\\n}\\n<\/script>\\n<style>\\n ...\\n</style>\\n\\n//Child2.vue\\n<template>\\n    <p>这是新的n:{{n}}</p>\\n</template>\\n<script>\\nimport Event from \'../bus\'\\n\\nexport default {\\n  name: \'Child2\',\\n  data(){\\n    return{\\n      n:0\\n    }\\n  }\\n  created(){\\n      Event.$on(\'update:count\',(n)=>{\\n        console.log(n)\\n        this.n=n\\n      })\\n  }\\n}\\n<\/script>\\n<style>\\n ...\\n</style>\\n```\\n\\n4. 任意组件传值，用 vuex\\n\\n## 其他不常用的方法\\n\\n1. 所有子组件都可以通过`$root`获取根实例。\\n\\n可以直接`this.$root.xxx`读写根组件的数据、计算属性和方法。\\n可以将根实例作为一个全局 store 来使用\\n只适用于小型 demo，大型项目直接用 vuex\\n\\n2. 子组件可以通过`$parent`访问父组件\\n\\n用法同上，但是不推荐使用，因为这样会导致程序复杂时无法得知父组件的变更是从哪里发起的\\n\\n3. 依赖注入 provide/inject\\n\\n祖先组件提供一个数据/方法\\n\\n```javascript\\nprovide: function () {\\n  return {\\n    getMap: this.getMap\\n  }\\n}\\n```\\n\\n任意的后代获取这个数据/方法\\n\\n```javascript\\ninject: [\'getMap\'];\\n```\\n\\n4. ref 访问子组件实例或子元素\\n\\n你可以通过 `ref` 这个 attribute 为子组件赋予一个 ID 引用。例如：\\n\\n```vue\\n<base-input ref=\\"usernameInput\\"></base-input>\\n```\\n\\n现在在你已经定义了这个 `ref` 的组件里，你可以使用：\\n\\n```vue\\nthis.$refs.usernameInput\\n```\\n\\n`$refs`只会在组件渲染完成后生效，并且不是响应式的。避免在模版或计算属性中访问$refs\\n\\n## vuex 核心\\n\\nvuex 是一个单一状态树，作为一个唯一数据源使用\\n\\n### State\\n\\n全局注册\\n\\n```javascript\\nconst app = new Vue({\\n  el: \'#app\',\\n  // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件\\n  store,\\n  components: { Counter },\\n  template: `\\n    <div class=\\"app\\">\\n      <counter></counter>\\n    </div>\\n  `\\n});\\n```\\n\\n通过 this.$store 访问，vuex 也是响应式的，我们可以用计算属性获取 vuex 中的数据\\n\\n### Getters\\n\\nvuex 的计算属性\\n接受 state 作为第一个参数\\n\\n```javascript\\nconst store = new Vuex.Store({\\n  state: {\\n    todos: [\\n      { id: 1, text: \'...\', done: true },\\n      { id: 2, text: \'...\', done: false }\\n    ]\\n  },\\n  getters: {\\n    doneTodos: state => {\\n      return state.todos.filter(todo => todo.done);\\n    }\\n  }\\n});\\n```\\n\\n同样通过 `this.$store.getters.xxx`  访问\\ngetter 也可以返回一个函数，可以实现给 getter 传参，但是这样会每次都进行调用，而不会缓存结果\\n\\n### Mutations\\n\\n注册一个事件，接收 state 作为第一个参数\\n\\n```javascript\\nconst store = new Vuex.Store({\\n  state: {\\n    count: 1\\n  },\\n  mutations: {\\n    increment(state) {\\n      // 变更状态\\n      state.count++;\\n    }\\n  }\\n});\\n```\\n\\n子组件中触发这个事件\\n\\n```javascript\\nstore.commit(\'increment\');\\n```\\n\\n可以传参数，vuex 里叫做 **载荷 payload** \\n可以传单个参数，推荐用对象的形式提交载荷\\n\\n```javascript\\n// ...\\nmutations: {\\n  increment (state, payload) {\\n    state.count += payload.amount\\n  }\\n}\\n```\\n\\n```javascript\\nstore.commit(\'increment\', {\\n  amount: 10\\n});\\n```\\n\\n此外，还有对象风格的提交方式，其他用法照常\\n\\n```javascript\\nstore.commit({\\n  type: \'increment\',\\n  amount: 10\\n});\\n```\\n\\nmutation 需要遵守 Vue 的响应规则\\n\\n### Actions\\n\\nmutation 必须是同步函数，异步回调中进行的状态的改变都是不可追踪的\\nAction 类似于 mutation，但是\\n\\n- Action 提交的是 mutation，而不是直接变更状态\\n- Action 可以包含任意异步操作\\n\\n```javascript\\nconst store = new Vuex.Store({\\n  state: {\\n    count: 0\\n  },\\n  mutations: {\\n    increment(state) {\\n      state.count++;\\n    }\\n  },\\n  actions: {\\n    increment(context) {\\n      context.commit(\'increment\');\\n    }\\n  }\\n});\\n```\\n\\n### Modules\\n\\n为了避免 store 太过臃肿，我们可以分割模块\\n\\n```javascript\\nconst moduleA = {\\n  state: () => ({ ... }),\\n  mutations: { ... },\\n  actions: { ... },\\n  getters: { ... }\\n}\\nconst moduleB = {\\n  state: () => ({ ... }),\\n  mutations: { ... },\\n  actions: { ... }\\n}\\nconst store = new Vuex.Store({\\n  modules: {\\n    a: moduleA,\\n    b: moduleB\\n  }\\n})\\n```\\n\\n","frontmatter":{"title":"vue","desc":"《JavaScript设计模式》、《大话设计模式》笔记","keywords":"设计模式、笔记","date":"2020-02-17T01:01:00.000Z","cover":"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/1.jpg"},"url":"/front-end/vue/"},{"src":"## 简单 diff\\n\\n遍历新旧两组子节点中数量较多的那组，逐个进行递归 patch，比较两组子节点数量，数量多说明有新子节点需要挂载，数量少说明有节点需要卸载。key 的租用在于方便找到可复用的节点，尽可能通过移动 dom 节点来完成更新，避免频繁的销毁、创建 dom 元素\\n\\n核心逻辑是：拿新的一组子节点中的节点去旧的一组子节点中寻找可复用的节点，如果找到就记录索引位置，称为最大索引。如果一个节点值小于最大索引，则说明该节点对应的真实 dom 元素需要移动\\n\\n## 双端 diff（vue2）\\n\\n简单 diff 的移动操作并不是最优的。\\n\\n双端 diff 对新旧两组子节点分别设置了两对首尾指针\\n\\nnewStartIdx、oldStartIdx、newEndIdx、oldEndIdx\\n\\n依次进行 oldStartIdx->newStartIdx，oldEndIdx->newEndIdx，oldStartIdx->newEndIdx，oldEndIdx->newStartIdx，如果可复用，进行元素移动，如果不可复用，跳过不做处理。非理想条件下，一趟下来没有任何可复用元素，进入 else 的处理逻辑，直接取 newStartIdx 对应的元素，在 oldChildren 中寻找可复用节点，如果有，进行移动处理。新增、删除元素需要做额外的条件判断，否则会遗漏处理\\n\\n## 快速 diff（vue3）\\n\\n最早应用于 ivi、inferno 框架，vue3 借鉴并扩展了它。\\n\\n快速 diff 算法包含了`预处理`步骤。借鉴了纯文本 diff 算法的思路\\n\\n在对两端文本进行 diff 之前，可以先进行全等比较，这被称为快捷路径。\\n\\n在 dom diff 中，使用头指针 j，和 oldEndIdx、newEndIdx，对首尾进行比对，直到出现不同节点，只需处理不同的部分即可。根据 j 和两个尾指针的值做添加、删除元素的判断。\\n\\n对于处理元素的复用移动，需要用到最长递增子序列。根据未处理节点的数量创建一个元素全为-1 的数组，将用来存储新的一组子节点中的节点在旧的一组子节点中的位置索引，用其计算出一个最长递增子序列，辅助完成 dom 移动。最长递增子序列所指向的节点即为不需要移动的节点，尽最大可能减少操作的 dom 数量。\\n","frontmatter":{},"url":"/front-end/vue3/diff.html"},{"src":"# vue3\\n\\n## Vue2 和 Vue3 的区别\\n\\n除了 api 和使用上的变化之外，主要有如下几点\\n\\n1. 响应式的变化\\n\\n   - 借助 proxy，实现更精细的响应式转换，比起 vue2 需要对对象进行深度遍历，vue3 只会将 get 到的对象属性进行包装，并且能够拦截新增的对象属性\\n   - 可选的响应式转换，对于渲染函数中的变量传递更为自由，可以直接 return js 变量使用，省去了多余的响应式包装\\n\\n2. diff 算法\\n   - vue2 双端 diff 算法。vue3 双端对比 + 最长递增子序列\\n3. 模版编译优化\\n   - 更改了编译优化策略。vue2 会标记静态节点和静态根节点，vue3 以 patchFlag 区分不同类型的动态节点，以 block 为维度收集子级树中所有的动态节点，更新时跳过所有静态节点直接更新动态节点，并且得益于 patchFlag 的区分，能做到精准的靶向更新\\n   - 静态提升。把生成的静态的子树或者静态 prop 提升到渲染函数之外，只持有引用\\n4. 组合式 api\\n   - 利于 tree shaking，可以结合使用特性开关去掉 options api，只使用 composition api，进一步减少打包体积\\n   - 比起 vue2 将所有东西都挂在 this 上，很多时候只能靠 mixin 复用逻辑，hook 的写法更方便逻辑复用，且更加类型友好\\n5. 自定义渲染器\\n   - vue3 开放了自定义渲染器的接口 createRenderer，可以非常方便的实现自定义渲染逻辑，使用场景更广\\n6. 新增了 Fragment vNode 类型，允许多根节点模版\\n\\n## 为什么要使用 composition api\\n\\n### mixin、高阶组件（HOC）、renderLess components（插槽） 存在的问题\\n\\n- 模版中的数据来源不清晰\\n- 命名冲突\\n- 性能。高阶组件、renderLess components 都需要额外的组件实例来封装逻辑\\n\\n### composition api 的优势\\n\\n- TS 对函数参数、返回值和泛型的支持比较完善\\n- 每一个函数都可以都可以单独引入，且代码压缩效率更高（所有的函数名和 setup 函数体内部的变量名都可以被压缩，但对象和 class 的属性/方法名却不可以），tree-shaking 友好\\n- 更好的逻辑复用、更灵活的代码组织\\n\\n![](./images/conposition-api.png)\\n\\n### 实际应用\\n\\n```shell\\ntodoList\\n|____index.vue\\n|____hooks\\n| |____useDataList.js\\n| |____useLiEvent.js\\n```\\n\\n```js\\nimport { customRef } from \'vue\';\\n\\nexport function useDebouncedRef(value, delay = 200) {\\n  let timeout;\\n  return customRef((track, trigger) => {\\n    return {\\n      get() {\\n        track();\\n        return value;\\n      },\\n      set(newValue) {\\n        clearTimeout(timeout);\\n        timeout = setTimeout(() => {\\n          value = newValue;\\n          trigger();\\n        }, delay);\\n      }\\n    };\\n  });\\n}\\n```\\n\\n```vue\\n<script setup>\\nimport { useDebouncedRef } from \'./debouncedRef\';\\nconst text = useDebouncedRef(\'hello\');\\n<\/script>\\n\\n<template>\\n  <input v-model=\\"text\\" />\\n</template>\\n```\\n\\n- [Vue Function-based API RFC](https://zhuanlan.zhihu.com/p/68477600)\\n- [hook 示例](https://github.com/antfu/vueuse/blob/main/packages/core/useNow/index.ts)\\n- [awesome-vue3](https://github.com/vuesomedev/awesome-vue-3)\\n- [和 React Hooks 的对比](https://cn.vuejs.org/guide/extras/composition-api-faq.html#comparison-with-react-hooks)\\n\\n## 常见 composition api 原理\\n\\n```js\\nimport { ref, watchEffect } from \'vue\';\\n\\nconst count = ref(0);\\n\\nwatchEffect(() => {\\n  document.body.innerHTML = `计数：${count.value}`; // 执行某个行为，比如更新视图\\n});\\n\\n// 更新 DOM\\ncount.value++;\\n```\\n\\ngetter、setter，以及依赖的收集和追踪\\n\\n```js\\nfunction createGetter(isReadonly = false, shallow = false) {\\n  return function get(target, key) {\\n    const res = Reflect.get(target, key);\\n    if (shallow) return res;\\n    if (isRef(res)) return res.value;\\n    // 对于嵌套的对象进行响应式处理\\n    if (isObject(res)) {\\n      return isReadonly ? readonly(res) : reactive(res);\\n    }\\n    !isReadonly && track(target, key);\\n    return res;\\n  };\\n}\\n\\nfunction createSetter() {\\n  return function set(target, key, value) {\\n    const res = Reflect.set(target, key, value);\\n    // 触发依赖\\n    trigger(target, key);\\n    return res;\\n  };\\n}\\n\\nlet activeEffect;\\nlet targetMap = new WeakMap();\\n\\nfunction track(target, key) {\\n  if (activeEffect) {\\n    const effects = getSubscribersForProperty(target, key);\\n    effects.add(activeEffect);\\n  }\\n}\\n\\nfunction trigger(target, key) {\\n  const effects = getSubscribersForProperty(target, key);\\n  effects.forEach(effect => effect());\\n}\\n```\\n\\n基于上述，我们可以实现一系列的响应式 api\\n\\n```js\\nfunction reactive(target) {\\n  if (isReadonly(target)) return target;\\n  return new Proxy(target, {\\n    get: createGetter(),\\n    set: createSetter()\\n  });\\n}\\n\\nfunction shallowReactive(target) {\\n  return new Proxy(target, {\\n    get: createGetter(false, true),\\n    set: createSetter()\\n  });\\n}\\n\\nfunction ref(value) {\\n  const refObject = {\\n    get value() {\\n      track(refObject, \'value\');\\n      return value;\\n    },\\n    set value(newValue) {\\n      value = newValue;\\n      trigger(refObject, \'value\');\\n    }\\n  };\\n  return refObject;\\n}\\n\\n// function readonlySet(target, key, value) {\\n//   console.warn(`key:${key}set失败，因为 target 是 readonly`, target);\\n//   return true;\\n// }\\n\\nfunction readonly(target) {\\n  return new Proxy(target, {\\n    get: createGetter(true),\\n    set: readonlySet\\n  });\\n}\\n\\nfunction shallowReadonly() {\\n  return new Proxy(target, {\\n    get: createGetter(true, true),\\n    set: readonlySet\\n  });\\n}\\n```\\n\\n实现了依赖的收集和触发，我们还需要实现一个副作用函数的注册机制\\n最终的目的是实现 **数据变更->触发副作用函数**\\n\\n```js\\nlet activeEffect;\\n\\nclass ReactiveEffect {\\n  private _fn;\\n  active = true;\\n  constructor(fn, public scheduler) {\\n    this._fn = fn;\\n  }\\n  run() {\\n    if (!this.active) return this._fn();\\n    shouldTrack = true;\\n    activeEffect = this;\\n    // 在执行this.fn的时候，fn里所用到的reactive变量，会将本对象作为依赖收集\\n    const result = this._fn();\\n    // 已经收集好依赖了，将shouldTrack置为false，表明在这个fn中所用到的reactive变量都已完成依赖收集\\n    // 不会再有另外的reactive变量以此为依赖了，因此关闭掉\\n    shouldTrack = false;\\n    return result;\\n  }\\n\\n  stop() {\\n    if (this.active) {\\n      cleanupEffect(this);\\n      this.active = false;\\n      shouldTrack = false;\\n    }\\n  }\\n}\\n\\n\\n```\\n\\nReactiveEffect 封装了副作用函数的注册机制\\n\\n由此可以封装出以下 api\\n\\n```js\\nfunction effect(fn, options) {\\n  const _effect = new ReactiveEffect(fn, options.scheduler);\\n  _effect.run();\\n  return runner;\\n}\\n\\nfunction watchEffect(update) {\\n  effect(update);\\n}\\n\\nfunction computed(getter) {\\n  let dirty = true;\\n  const effect = new ReactiveEffect(getter, () => {\\n    if (!dirty) {\\n      dirty = true;\\n    }\\n  });\\n  let value;\\n  return {\\n    get value() {\\n      if (dirty) {\\n        dirty = false;\\n        // 只在执行get时才去run\\n        value = this._effect.run();\\n      }\\n      return value;\\n    }\\n  };\\n}\\n```\\n\\n## 为什么需要包装对象\\n\\n函数直接返回一个原始值，如 number、string，是无法追踪变化的\\n\\n包装对象的意义就在于提供一个让我们能够在函数之间以引用的方式传递任意类型值的容器\\n\\n但不同的是 Vue 的包装对象同时还是响应式的数据源。有了这样的容器，我们就可以在封装了逻辑的组合函数中将状态以引用的方式传回给组件。组件负责展示（追踪依赖），组合函数负责管理状态（触发更新）\\n\\n- (响应性语法糖（已废弃）)[https://cn.vuejs.org/guide/reactivity-transform.html]\\n\\n## 什么是副作用函数\\n\\n_会产生副作用的函数_\\n\\n```js\\n// effect函数的执行会直接或间接影响其他函数的执行\\nlet a = 1;\\nfunction effect() {\\n  document.body.innerText = \'hello vue3\';\\n  a = 2; // 修改了全局变量也是一个副作用\\n}\\n```\\n\\n## 为什么使用 Proxy\\n\\n真正的拦截\\n\\n- 无需`$set`动态添加对象属性\\n- 无需 hack 数组方法\\n- 无需深度遍历，惰性响应式转换\\n\\n## Proxy 的原理\\n\\nECMAScript 规范里将对象分为两种，一种叫常规对象，一种叫异质对象。\\n\\n对象有各种内部方法比如`[[Get]]`、`[[Call]]`、`[[Construct]]`。他们有对应的规定实现，所有步符合规定实现的对象都是异质对象，由于 Proxy 的内部方法`[[Get]]`没有使用 ECMA 的规范实现（方法具有多态性），所以 Proxy 是异质对象。\\n\\n正是由于 Proxy 的`[[Get]]`方法实现了不同的逻辑，才能够拦截操作。如果创建代理对象时没有指定拦截函数，代理对象的`[[Get]]`方法会调用原始对象的内部方法`[[Get]]`来获取属性值，这其实就是代理透明性质。\\n\\n## 为什么使用 reflect api\\n\\n```js\\nconst obj = {\\n  foo: 1,\\n  get bar() {\\n    return this.foo;\\n  }\\n};\\n\\nconst p = new Proxy(obj, {\\n  get(target, key) {\\n    return target[key];\\n  }\\n});\\n```\\n\\n调用 p.bar 时，this 指向 obj，相当于 obj.foo，通过原始对象访问它的某个属性值是不会建立联系的，而 Reflect.get 的第三个参数 receiver 很好的解决了这个问题。receiver 是 Proxy 或者继承 Proxy 的对象，能够避免上述使用原始对象的问题\\n\\n```js\\nconst p = new Proxy(obj, {\\n  get(target, key, receiver) {\\n    console.log(target, key, receiver);\\n    return Reflect.get(target, key, receiver);\\n  }\\n});\\n```\\n\\n<!--@include: ./diff.md-->\\n","frontmatter":{},"url":"/front-end/vue3/"},{"src":"---\\nlayout: home\\nhero:\\n  name: Jarrett\\n  tagLine: 做一个有灵魂的前端工程师\\n  image:\\n    src: /background.jpeg\\n    alt: VitePress\\n  actions:\\n    - theme: brand\\n      text: 概览\\n      link: /knowledge-map\\n    - theme: alt\\n      text: View on GitHub\\n      link: https://github.com/Jarrett817/Jarrett-blog\\nfeatures:\\n  - icon: 🌿\\n    title: 前端基础知识\\n    details: js、ts、浏览器、nodejs\\n  - icon: 🌱\\n    title: 计算机基础知识\\n    details: 数据结构、算法、计算机网络\\n  - icon: 🌴\\n    title: 读书笔记\\n    details: 《Vuejs设计与实现》、《javascript设计模式》、《数据结构与算法之美》\\n---\\n","frontmatter":{"layout":"home","hero":{"name":"Jarrett","tagLine":"做一个有灵魂的前端工程师","image":{"src":"/background.jpeg","alt":"VitePress"},"actions":[{"theme":"brand","text":"概览","link":"/knowledge-map"},{"theme":"alt","text":"View on GitHub","link":"https://github.com/Jarrett817/Jarrett-blog"}]},"features":[{"icon":"🌿","title":"前端基础知识","details":"js、ts、浏览器、nodejs"},{"icon":"🌱","title":"计算机基础知识","details":"数据结构、算法、计算机网络"},{"icon":"🌴","title":"读书笔记","details":"《Vuejs设计与实现》、《javascript设计模式》、《数据结构与算法之美》"}]},"url":"/"},{"src":"---\\nlayout: home\\nisMapMode: true\\n---\\n\\n<KnowledgeMap/>\\n","frontmatter":{"layout":"home","isMapMode":true},"url":"/knowledge-map.html"},{"src":"<script setup>\\n  import ApiTest from \'./components/ApiTest.vue\'\\n<\/script>\\n\\n# 接口测试平台\\n\\n## yapi 简介\\n\\nyapi 是一个开源的接口管理平台，目前 star 数量 27.3k，具备以下特性：\\n\\n1. 权限管理\\n2. 项目管理\\n3. 可视化接口管理，接口修改记录可追溯\\n4. 基于 mock.js，方便的 mock 数据生成器\\n5. 接口自动化测试\\n6. 数据导入，支持 swagger、postman、har 数据格式，便于迁移\\n\\n## 快速上手\\n\\n新建项目->新建分类->添加接口\\n\\n> 手动演示\\n\\n配置接口代理，使用`nginx`或者`代理工具`配置代理\\n\\n#### 举例 nginx 代理配置\\n\\n```nginx\\nserver {\\n  listen 443 ssl;\\n  server_name test.jarrett.com;\\n\\n  ssl_certificate SSL/test.jarrett.com.crt;\\n  ssl_certificate_key SSL/test.jarrett.com.key;\\n\\n  location / {\\n    proxy_pass https://xx.xx.x.xxx:443/;\\n    proxy_set_header Host https://xx.xx.x.xxx:443/;\\n    proxy_set_header X-Real-IP $remote_addr;\\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\\n    proxy_set_header X-Forwarded-Photo $scheme;\\n  }\\n\\n  location /api/getUsers{\\n    proxy_pass http://xx.xx.x.xxx:3000/mock/83/api/getUsers;\\n    proxy_set_header Host http://xx.xx.x.xxx:3000;\\n    proxy_set_header X-Real-IP $remote_addr;\\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\\n    proxy_set_header X-Forwarded-Photo $scheme;\\n  }\\n}\\n```\\n\\nvite 热更新配置\\n\\n```json\\n{\\n  \\"server\\": {\\n    \\"hmr\\": {\\n      \\"port\\": 8888 // 对应nginx监听的端口\\n    }\\n  }\\n}\\n```\\n\\n接口测试\\n<ClientOnly>\\n<ApiTest/>\\n</ClientOnly>\\n\\n## 创建模拟数据\\n\\n### mockjs 使用语法\\n\\n[数据模板定义示例](http://mockjs.com/examples.html)\\n\\n常用语法\\n\\n```json\\n{\\n  \\"age|1-100\\": 100,\\n  \\"value|123.3\\": 123.111,\\n  \\"isVip|1-2\\": true,\\n  \\"list|1-100\\": [{ \\"name\\": \\"test\\" }],\\n  \\"address|2\\": {\\n    \\"310000\\": \\"上海市\\",\\n    \\"320000\\": \\"江苏省\\",\\n    \\"330000\\": \\"浙江省\\",\\n    \\"340000\\": \\"安徽省\\"\\n  }\\n}\\n```\\n\\n### json-schema\\n\\n![json-schema](/plan/api-test/images/schema-mock.png)\\n\\n## 高级 mock\\n\\n### Mock 期望\\n\\n- 自定义过滤规则，返回自定义数据，支持 mock\\n- 可定义接口延时\\n- 可定义 http 状态码\\n\\n### 自定义 Mock 脚本\\n\\n#### 全局变量\\n\\n请求\\n\\n- `header` 请求的 HTTP 头\\n- `params` 请求参数，包括 Body、Query 中所有参数\\n- `cookie` 请求带的 Cookies\\n\\n响应\\n\\n- `mockJson` 接口定义的响应数据 Mock 模板\\n- `resHeader` 响应的 HTTP 头\\n- `httpCode` 响应的 HTTP 状态码\\n- `delay` Mock 响应延时，单位为 ms\\n- `Random` Mock.Random 方法，可以添加自定义占位符,详细使用方法请查看\\n\\n示例 1，根据请求参数重写 mockJson\\n\\n```js\\nif (params.type == 1) {\\n  mockJson.errcode = 400;\\n  mockJson.errmsg = \'error\';\\n}\\n\\nif (header.token == \'t\') {\\n  mockJson.errcode = 300;\\n  mockJson.errmsg = \'error\';\\n}\\n\\nif (cookie.type == \'a\') {\\n  mockJson.errcode = 500;\\n  mockJson.errmsg = \'error\';\\n}\\n```\\n\\n## 自动化测试\\n\\n传统的接口自动化测试成本高，大量的项目没有使用自动化测试保证接口的质量，仅仅依靠手动测试，是非常不可靠和容易出错的。\\n\\nYApi 为了解决这个问题，开发了可视化接口自动化测试功能，只需要配置每个接口的入参和对 RESPONSE 断言，即可实现对接口的自动化测试，大大提升了接口测试的效率。\\n\\n![自动化测试](/plan/api-test/images/case-list.gif)\\n\\n用例之间可以互相引用数据\\n\\n![](/plan/api-test/images/case_key_list.png)\\n\\n![](/plan/api-test/images/case_key_query.png)\\n\\n## 竞品\\n\\n市面上还有一些商业化接口管理平台，如 Apifox，提供了更加丰富的功能，可付费私有化部署\\n\\n[Apifox](https://app.apifox.com/main/teams/2803313?tab=project)\\n\\n### 数据模型\\n\\n![数据模型](/plan/api-test/images/model.png)\\n\\n### 组件\\n\\n![编辑组件](/plan/api-test/images/edit-component.png)\\n\\n![使用组件](/plan/api-test/images/use-component.png)\\n","frontmatter":{},"url":"/plan/api-test/"},{"src":"# 前端基建 ——— 接口、数据、类型在前端开发中的管理及应用\\n\\n## 背景\\n\\n前端基建，包括`构建工具、规范与质量保障、自动化测试、组件库、前后端协作`等等\\n\\n目的是为了实现标准化 + 规范化 + 工具化 + 自动化，业务支撑是活在当下，技术基建是活好未来\\n\\n本文主要针对前后端协作及质量保障展开。\\n\\n接口、数据、类型贯穿了开发流程的始终：\\n\\n<Intro/>\\n\\n::: warning 开发过程中的痛点：\\n\\n1. 前端 mock 数据写在项目代码里，如果没有及时清理，会增加不必要的项目体积\\n2. 前期开发阶段没有真实的接口调用全流程，影响联调\\n3. 后端给出的接口文档不具备修改通知和 diff 功能，需要仔细询问核对哪些经过修改，且后续无历史记录\\n4. TS 使用不高效，没有起到应有的作用\\n5. 后端多个服务互相调用时，频繁出现数据类型变动的问题，未及时发现可能导致 bug\\n   :::\\n\\n::: tip 如何改进？\\n\\n1. 可追溯、可 mock、交互友好的接口文档、测试平台\\n2. 更高效、规范地使用 TS\\n3. 建立运行时数据校验体系\\n   :::\\n\\n<!--@include: ../api-test/index.md{5,}-->\\n\\n<!--@include: ../how-to-make-ts-useful/index.md-->\\n","frontmatter":{},"url":"/plan/front-end-infrastructure/"},{"src":"<script setup>\\n  import Intro from \'../front-end-infrastructure/components/Intro.vue\'\\n  import ApiTest from \'../api-test/components/ApiTest.vue\'\\n  import DaylyUse from \'/plan/how-to-make-ts-useful/components/DailyUse.vue\'\\n  import Zod from \'/plan/how-to-make-ts-useful/components/Zod.vue\'\\n\\n  const demo1 =`/** This is a cool guy. */\\ninterface Person {\\n  /** This is name. */\\n  name: string,\\n}\\n\\nconst p: Person = {\\n    name: \'cool\'\\n}`\\nconst conditionalType=`\\ntype MyType<T> = T extends string ? T : \'1\';\\nconst a: MyType<string> = \'test\';\\nconst b: MyType<number> = 1\\n`\\n\\nconst wxmini = `\\ndeclare namespace MySpace {\\n  interface UserType {}\\n}\\n\\nconst user: MySpace.UserType = {};\\n\\n\\ndeclare namespace WechatMiniprogram {\\n    type IAnyObject = Record<string, any>\\n    interface Target<DataSet extends IAnyObject = IAnyObject> {\\n        /** 事件组件的 id */\\n        id: string\\n        /** 当前组件的类型 */\\n        tagName?: string\\n        /** 事件组件上由 \'data-\' 开头的自定义属性组成的集合 */\\n        dataset: DataSet\\n        /** 距离页面顶部的偏移量 */\\n        offsetTop: number\\n        /** 距离页面左边的偏移量 */\\n        offsetLeft: number\\n    }\\n\\n    /** 基础事件参数 */\\n    interface BaseEvent<\\n        Mark extends IAnyObject = IAnyObject,\\n        CurrentTargetDataset extends IAnyObject = IAnyObject,\\n        TargetDataset extends IAnyObject = CurrentTargetDataset\\n    > {\\n        /** 事件类型 */\\n        type: string\\n        /** 页面打开到触发事件所经过的毫秒数 */\\n        timeStamp: number\\n        /** 事件冒泡路径上所有由 \'mark:\' 开头的自定义属性组成的集合 */\\n        mark?: Mark\\n        /** 触发事件的源组件 */\\n        target: Target<TargetDataset>\\n        /** 事件绑定的当前组件 */\\n        currentTarget: Target<CurrentTargetDataset>\\n    }\\n\\n       /** 自定义事件 */\\n    interface CustomEvent<\\n        Detail extends IAnyObject = IAnyObject,\\n        Mark extends IAnyObject = IAnyObject,\\n        CurrentTargetDataset extends IAnyObject = IAnyObject,\\n        TargetDataset extends IAnyObject = CurrentTargetDataset\\n    > extends BaseEvent<Mark, CurrentTargetDataset, TargetDataset> {\\n        /** 额外的信息 */\\n        detail: Detail\\n    }\\n}\\n\\n\\nfunction handleTap(e:WechatMiniprogram.CustomEvent<{name:string}>){\\n  console.log(e.detail.name);\\n}\\n`\\n\\nconst generics = `\\n// 使用泛型声明对象\\ninterface Student<Sex = string, Info = string> {\\n  name: string;\\n  age: number;\\n  sex: Sex;\\n  info: Info extends string ? Info : {\\n    address: string;\\n    phone: number;\\n  }\\n}\\n\\n// 默认导出也可使用泛型约束类型\\nexport default <Student>{\\n  name: \'谷雨\',\\n  age: 18,\\n  sex: \'male\'\\n}\\n\\nconst student: Student<\'female\', []> = {\\n  name: \'谷雨\',\\n  age: 18,\\n  sex: \'male\'\\n}\\n\\n// 你可能会这样声明函数\\nconst add = (a: number, b: number) => a + b;\\n\\n// 更好的方式\\ntype Add<T> = (a: T, b: T) => T;\\n\\n// T可代表任何类型\\nconst addN: Add<number> = (a, b) => a + b;\\nconst addS: Add<string> = (a, b) => a + b;\\n\\naddN(1, \'2\');\\naddS(2, 3);\\n\\nfunction getDetail<T extends object>(id: number): Promise<T> {\\n  return new Promise((resolve) => {\\n    setTimeout(() => {\\n      const data = {} as T\\n      resolve(data)\\n    }, 1000)\\n  })\\n}\\n\\ninterface Result {\\n  name: string;\\n  age: number;\\n}\\n\\nconst detail = getDetail<Result>(1234);\\n\\ndetail.then(res => {\\n  res.age;\\n  res.name;\\n})\\n\\n`\\n\\nconst typeOrInterface =`\\n// 继承\\ninterface Person {\\n  name: string;\\n  age: number;\\n}\\n\\ninterface Employee extends Person{\\n  id: number;\\n}\\n\\ninterface Employee {\\n  payed: number;\\n}\\n\\n// 交叉类型可以实现继承的效果\\ntype Employer = { title: string } & Person;\\ntype SomeOne = Employee | Employer\\n\\nconst person1: Employee = {\\n  id: 123,\\n  name: \'老王\',\\n  age: 30\\n}\\n\\nconst person2: Employer = {\\n  title: \'部门主管\',\\n  name: \'王老板\',\\n  age: 40\\n}\\n\\nconst person3: SomeOne = {\\n\\n}\\n`\\n\\nconst enumerate = `\\n// 能生成真实对象并操作\\nenum Status{\\n SUCCESS,\\n FAIL,\\n PENDING,\\n}\\n\\nconst enum ConstStatus {\\n SUCCESS,\\n FAIL,\\n PENDING,\\n}\\n\\nconst _ConstStatus = {\\n  SUCCESS: 0,\\n  FAIL: 1,\\n  PENDING: 2\\n} as const;\\n\\n \\t\\nconsole.log(Status.SUCCESS,ConstStatus.SUCCESS,_ConstStatus.SUCCESS);\\n\\nStatus.SUCCESS = 111;\\nConstStatus.SUCCESS = 111;\\n_ConstStatus.SUCCESS = 111;\\nStatus[0] === \'SUCCESS\'\\n`\\n\\nconst dailyUse =`\\n/* service层定义接口及入参出参类型 */\\n\\n/*--------------- /services/base/types.ts ----------------*/\\n\\nexport interface BaseResponse {\\n  msg: string;\\n  code: number;\\n}\\n\\ninterface RequestParams<T> {\\n  url: string;\\n  method: \'GET\' | \'POST\';\\n  query: T;\\n}\\n\\n/*---------------------------------------------------------*/\\n\\n\\n\\n/*--------------- /services/base/request.ts ----------------*/\\n\\nfunction sendRequest<Response extends object, Params>(params?: RequestParams<Params>): Promise<Response> {\\n  return new Promise((resolve) => {\\n    setTimeout(() => {\\n      console.log(params);\\n      const data = {} as Response\\n      resolve(data)\\n    }, 1000)\\n  })\\n}\\n\\n/*---------------------------------------------------------*/\\n\\n\\n\\n/*--------------- /services/order-service/types.ts ---------------*/\\nenum Status {\\n  SUCCESS,\\n  FAIL\\n}\\nexport interface ListItem {\\n  name: string;\\n  age: number;\\n  status: Status;\\n  children: ListItem[];\\n}\\nexport interface DetailResponse extends BaseResponse {\\n  data: {\\n    id: string;\\n    name: string;\\n    list: ListItem[]\\n  }\\n}\\n\\nexport type Data = DetailResponse[\'data\']\\nexport type List = DetailResponse[\'data\'][\'list\']\\nexport type DataWithoutId = Omit<Data, \'id\'>\\n\\n/*---------------------------------------------------------*/\\n\\n\\n\\n/*--------------- /services/order-services/api.ts ---------------*/\\nexport function getDetail<Params extends { id: number }>(query: Params) {\\n  return sendRequest<DetailResponse, Params>({\\n    method: \'GET\',\\n    url: \'/spi/detail\',\\n    query\\n  })\\n}\\n/*---------------------------------------------------------*/\\n\\n\\n\\n\\n/*--------------- 业务层使用 ---------------*/\\n\\nconst data = {\\n  list: [] as Data[\'list\'],\\n  info: {} as Pick<Data, \'id\' | \'name\'>\\n}\\ngetDetail({ id: 123 }).then(res => {\\n  res.data.id\\n  res.code\\n  console.log(res)\\n  data.list = res.data.list\\n  data.info.name = res.data.name\\n})\\n/*---------------------------------------------------------*/\\n\\n`\\n\\n<\/script>\\n\\n# 10 分钟速通 TS\\n\\n## TS 必知必会\\n\\n用 20% 的知识解决 80% 的日常开发\\n\\n### type & interface\\n\\n- type 类型别名。适用于定义复杂的类型组合，如联合类型和交叉类型。**当需要表示一个值可能是多种类型之一，或者一个类型需要同时满足多种类型的特征时，类型别名非常方便**\\n- interface 接口。更适合用于定义对象的形状，尤其是在面向对象编程或者定义 API 的返回值和参数类型时。**当需要描述一个类应该实现的契约（如具有哪些方法和属性）时，接口是很好的选择**\\n\\n<CodeEditor :value=\\"typeOrInterface\\" />\\n\\n### 条件类型\\n\\nextends 既可以用于继承，也可用于类型约束\\n\\n<CodeEditor :value=\\"conditionalType\\" />\\n\\n### namespace\\n\\n用于防止类型重命名冲突，比如微信小程序提供了全局类型的 namespace\\n\\n<CodeEditor :value=\\"wxmini\\"/>\\n\\n### 泛型\\n\\n合理使用泛型是 ts 的精髓，能够更好的封装通用方法\\n\\n学会泛型能够轻松阅读各类社区库的类型声明，良好的变量命名、类型声明很多时候可以替代文档\\n\\n<CodeEditor :value=\\"generics\\" />\\n\\n### 枚举 & 常量枚举\\n\\n业务代码中常有关于枚举的判断，比如`data.status===1`，这可能分散在各个项目文件，并且缺失语义\\n\\n:::danger 建议\\n如果不想在业务变动时一处处地逐个修改枚举判断，建议所有使用常量或枚举而不是硬编码\\n:::\\n\\n<CodeEditor :value=\\"enumerate\\" />\\n\\n编译结果如下\\n\\n```js\\n\'use strict\';\\nvar Status;\\n(function (Status) {\\n  Status[(Status[\'SUCCESS\'] = 0)] = \'SUCCESS\';\\n  Status[(Status[\'FAIL\'] = 1)] = \'FAIL\';\\n  Status[(Status[\'PENDING\'] = 2)] = \'PENDING\';\\n})(Status || (Status = {}));\\nconst _ConstStatus = {\\n  SUCCESS: 0,\\n  FAIL: 1,\\n  PENDING: 2\\n};\\nconsole.log(Status.SUCCESS, 0 /* ConstStatus.SUCCESS */, _ConstStatus.SUCCESS);\\n```\\n\\n### Utility Types 实用工具类型\\n\\n#### 1. `Partial<T>`\\n\\n定义和用途：\\n`Partial<T>`用于将一个类型 `T` 的所有属性变为可选的。这在处理对象类型时非常有用，比如在创建对象的部分属性更新函数时。\\n示例：\\n\\n```typescript\\ninterface User {\\n  name: string;\\n  age: number;\\n  email: string;\\n}\\nlet partialUser: Partial<User> = {\\n  name: \'John\'\\n};\\n```\\n\\n在这个例子中，`partialUser` 可以只包含 User 接口中部分属性，因为 `Partial<User>`将 `User` 接口的所有属性都变成了可选属性。\\n\\n#### 2. `Required<T>`\\n\\n定义和用途：\\n与 `Partial<T>`相反，`Required<T>`将类型 `T` 的所有可选属性变为必选属性。这有助于确保在某些场景下对象的完整性。\\n示例：\\n\\n```typescript\\ninterface PartialProduct {\\n  name?: string;\\n  price?: number;\\n}\\nlet requiredProduct: Required<PartialProduct> = {\\n  name: \'Phone\',\\n  price: 599\\n};\\n```\\n\\n这里 `Required<PartialProduct>`强制要求 `requiredProduct` 必须包含 `name` 和 `price` 属性，不能有缺失。\\n\\n#### 3. `Readonly<T>`\\n\\n定义和用途：\\n`Readonly<T>`用于创建一个新的类型，其所有属性都是只读的。这在需要确保对象属性不被意外修改的场景下非常有用，比如配置对象或者常量对象。\\n示例：\\n\\n```typescript\\ninterface Settings {\\n  theme: string;\\n  fontSize: number;\\n}\\nlet readonlySettings: Readonly<Settings> = {\\n  theme: \'dark\',\\n  fontSize: 14\\n};\\n// readonlySettings.theme = \'light\'; // 这行代码会报错，因为属性是只读的\\n```\\n\\n#### 4. `Pick<T, K>`\\n\\n定义和用途：\\n`Pick<T, K>`从类型 T 中挑选出属性集 K 所指定的属性，创建一个新的类型。K 是一个联合类型，代表要选择的属性名。\\n示例：\\n\\n```typescript\\ninterface Car {\\n  brand: string;\\n  model: string;\\n  year: number;\\n  color: string;\\n}\\ntype CarInfo = Pick<Car, \'brand\' | \'model\'>;\\nlet myCarInfo: CarInfo = {\\n  brand: \'Toyota\',\\n  model: \'Corolla\'\\n};\\n```\\n\\n在这个例子中，CarInfo 类型只包含 Car 接口中的 brand 和 model 属性。\\n\\n#### 5. `Omit<T, K>`\\n\\n定义和用途：\\n与 `Pick<T, K>`相反，`Omit<T, K>`从类型 `T` 中排除属性集 `K` 所指定的属性，生成一个新的类型。这在想要去除某些不需要的属性时很有用。\\n示例：\\n\\n```typescript\\ninterface Person {\\n  name: string;\\n  age: number;\\n  address: string;\\n  phone: string;\\n}\\ntype PersonWithoutAddress = Omit<Person, \'address\'>;\\nlet person: PersonWithoutAddress = {\\n  name: \'Alice\',\\n  age: 30,\\n  phone: \'1234567890\'\\n};\\n```\\n\\n这里 `PersonWithoutAddress` 类型是从 `Person` 接口中排除了 `address` 属性后的新类型。\\n\\n#### 6. `Record<K, T>`\\n\\n定义和用途：\\n`Record<K, T>`用于创建一个新的类型，其属性键的类型为 `K`，属性值的类型为 `T`。`K` 通常是一个字符串字面量类型或者联合类型，`T` 可以是任何类型。\\n示例：\\n\\n```typescript\\ntype Colors = \'red\' | \'green\' | \'blue\';\\ntype ColorMap = Record<Colors, string>;\\nlet colorMap: ColorMap = {\\n  red: \'#FF0000\',\\n  green: \'#00FF00\',\\n  blue: \'#0000FF\'\\n};\\n```\\n\\n这个例子中，`ColorMap` 类型的对象以 `Colors` 联合类型中的字符串作为键，以 `string` 类型作为值。\\n\\n#### 7. `Exclude<T, U>`\\n\\n定义和用途：\\n`Exclude<T, U>`用于从类型 `T` 中排除可以赋值给类型 `U` 的元素，返回剩余的类型。它主要用于处理联合类型。\\n示例：\\n\\n```typescript\\ntype Numbers = 1 | 2 | 3 | 4 | 5;\\ntype OddNumbers = Exclude<Numbers, 2 | 4>;\\nlet oddNumber: OddNumbers = 1;\\n```\\n\\n在这里，`OddNumbers` 是从 `Numbers` 联合类型中排除了偶数 2 和 4 后剩下的奇数类型。\\n\\n#### 8. `Extract<T, U>`\\n\\n定义和用途：\\n与 `Exclude<T, U>`相反，`Extract<T, U>`从类型 `T` 中提取可以赋值给类型 `U` 的元素，生成一个新的类型。\\n示例：\\n\\n```typescript\\ntype AllNumbers = 1 | 2 | 3 | 4 | 5;\\ntype EvenNumbers = Extract<AllNumbers, 2 | 4>;\\nlet evenNumber: EvenNumbers = 2;\\n```\\n\\n此例中，`EvenNumbers` 是从 `AllNumbers` 联合类型中提取出偶数 2 和 4 后的类型。\\n\\n## 业务应用实践\\n\\n<DaylyUse/>\\n\\n<CodeEditor :value=\\"dailyUse\\" />\\n\\n以上是静态类型校验，那么如何过渡到动态类型校验？\\n\\n## 运行时数据校验\\n\\n:::warning 解决什么问题\\n\\n- 后端服务互相调用，数据类型不确定\\n- 可能出现的属性空值\\n- 可能由类型导致的问题，比如 falsy 判断、字符串和数字相加\\n  :::\\n\\n### 碰到的挑战\\n\\n![使用组件](/plan/how-to-make-ts-useful/images/challenges.png)\\n\\n经过调研，选用了 zod 库作为方案实现的核心库\\n\\n该库较为成熟，社区活跃，原生支持 TS，且能够完全对标 TS 语法，一份 schema 同时生成校验器和 TS 静态类型，使用简单、直观、轻便\\n\\n<Zod/>\\n\\n:::code-group\\n\\n```ts [/base-service/validator.ts]\\nconst safeString = () =>\\n  string().catch(ctx => {\\n    log2wx(ctx.error.message);\\n    try {\\n      const data = JSON.stringify(ctx.input);\\n      return data || \'\';\\n    } catch (e) {\\n      return \'\';\\n    }\\n  });\\n\\n// coerce number 解析如\'测试文本\'这样的文本字符串，无法类型强转，会parse error\\nconst safeNumber = () =>\\n  number().catch(ctx => {\\n    log2wx(ctx.error.message);\\n    const { success, data } = coerce.number().safeParse(ctx.input);\\n    if (success) return data;\\n    else return 0;\\n  });\\n\\nconst safeBoolean = () =>\\n  boolean().catch(ctx => {\\n    log2wx(ctx.error.message);\\n    const { success, data } = coerce.boolean().safeParse(ctx.input);\\n    if (success) return data;\\n    else return false;\\n  });\\n\\nconst safeArray = <T extends ZodTypeAny>(\\n  schema: T,\\n  params?: RawCreateParams & { filter?: (val: unknown[]) => unknown[] }\\n) => {\\n  return array(schema).catch(ctx => {\\n    log2wx(ctx.error.message);\\n    if (Array.isArray(ctx.input)) {\\n      return params?.filter ? params.filter(ctx.input) : ctx.input; // 避免混合类型数组报错 [{name:\'test\'},null]\\n    } else {\\n      return [];\\n    }\\n  });\\n};\\ntype ObjectParams = ZodObject<ZodRawShape>;\\nconst safeObject = <\\n  T extends\\n    | ObjectParams\\n    | ZodDefault<ObjectParams>\\n    | ZodNullable<ObjectParams>\\n    | ZodDefault<ZodNullable<ObjectParams>>\\n>(\\n  schema: T\\n) => {\\n  return schema.catch((ctx: { error: ZodError }) => {\\n    log2wx(ctx.error.message);\\n    return {};\\n  }) as ZodCatch<typeof schema>;\\n};\\n\\nconst safeLiteral = <T extends Primitive>(schema?: T) =>\\n  literal(schema).catch(ctx => {\\n    log2wx(ctx.error.message);\\n    return schema;\\n  });\\n\\nconst safeNativeEnum = <T extends EnumLike>(schema: T) =>\\n  nativeEnum(schema).catch(ctx => {\\n    log2wx(ctx.error.message);\\n    return Object.values(ctx.input)[0];\\n  });\\n\\nconst safeNull = () =>\\n  zodNull().catch(ctx => {\\n    log2wx(ctx.error.message);\\n    return null;\\n  });\\n\\nconst safeUnion = <T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>>(schema: T) => {\\n  return union(schema).catch(ctx => {\\n    log2wx(ctx.error.message);\\n    return \'\';\\n  });\\n};\\n\\nconst createBaseResponseValidator = <Data extends ZodType, Meta extends ZodType>(\\n  data?: Data,\\n  meta?: Meta\\n) => {\\n  return safeObject(\\n    object({\\n      code: number(),\\n      msg: string(),\\n      data: preprocess(val => val || null, data || safeNull()),\\n      meta: preprocess(val => val || null, meta || safeNull())\\n    }).partial({\\n      meta: true,\\n      msg: true,\\n      data: true\\n    })\\n  );\\n};\\n```\\n\\n```ts [/detail-service/api.ts]\\nimport { createDetailValitor } from \'./validator\'\\nclass DetailService extends BaseServices {\\n  constructor() {\\n    super();\\n  }\\n\\n  getDetail(query: { orderId: string }) {\\n    return this.sendRequest(\\n      {\\n        url:\'/api/detail\'\\n        method: \'POST\',\\n        query,\\n        validator: createDetailValitor\\n      },\\n    );\\n  }\\n}\\n\\nexport const detailService = new DetailServices();\\n```\\n\\n```ts [/detail-service/validator.ts]\\n/*\\nenum Status {\\n  SUCCESS,\\n  FAIL\\n}\\nexport interface ListItem {\\n  name: string;\\n  age: number;\\n  status: Status;\\n  children?: ListItem[];\\n}\\nexport interface DetailResponse extends BaseResponse {\\n  data: {\\n    id: string;\\n    name: string;\\n    tags: string[];\\n    list: ListItem[];\\n  };\\n}\\n*/\\n\\nconst listItem = safeObjectWrap(\\n  object({\\n    status: safeNativeEnum(Status).default(Status.FAIL),\\n    name: safeString().default(\'\'),\\n    age: safeNumber().default(20)\\n  }).passthrough()\\n);\\n\\nconst createDetailValidator = () => {\\n  type Input = input<typeof listItem> & {\\n    children?: Input[];\\n  };\\n  type Output = output<typeof listItem> & {\\n    children?: Output[];\\n  };\\n  const schema: ZodType<Output, ZodTypeDef, Input> = listItem\\n    .extend({\\n      children: lazy(() => schema.array())\\n    })\\n    .partial({ children: true });\\n  return createBaseResponseValidator(\\n    safeObjectWrap(\\n      object({\\n        id: safeString(),\\n        name: safeString(),\\n        tags: safeArray(safeString()).default([]),\\n        list: safeArray(schema)\\n      }).partial({ list: true })\\n    )\\n  );\\n};\\n\\nexport const detailSchema = createDetailValidator();\\n```\\n\\n```ts [/detail-service/types.ts]\\nimport { detailSchema } from \'./validator\';\\n\\ntype DetailSchema = z.infer<typeof detailSchema>;\\n\\nexport type Data = DetailSchema[\'data\'];\\nexport type List = DetailSchema[\'data\'][\'list\'];\\nexport type DataWithoutId = Omit<Data, \'id\'>;\\n```\\n\\n:::\\n","frontmatter":{},"url":"/plan/how-to-make-ts-useful/"},{"src":"# 微前端架构下的主子通信\\n\\n## 背景\\n\\n微前端架构下的应用之间仍然存在交互场景，并非完全无关\\n\\n- 子应用控制主应用的登出\\n- 子应用需要知晓主应用的一些全局性操作如全局性的路由跳转\\n- 子应用之间存在互相跳转的情况，写死的 url 在项目的持续性维护中存在问题\\n\\n需要一套更普适的方法\\n\\n## 微前端通信方式调研\\n\\n### umi/qiankun、single-spa\\n\\n通过监听 url change 事件，在路由变化时匹配到渲染的子应用并进行渲染，这个思路也是目前实现微前端的主流方式，对于应用间的跳转是通过路由库的方式\\n\\nqiankun 官方对于跳转的回应是：在主子都是 hash 模式时，直接跳转；在主子都是 history 模式时，使用 history.pushState（不推荐、会触发所有应用的路由监听） 或者主应用下发路由实例的方式跳转\\n\\n因此在 qiankun 中，**props 下发** 是较为推荐的通信方式\\n\\nqiankun 提供了两种方式：\\n\\n1. props 直接下发\\n2. initGlobalState\\n\\n```js\\n// 主应用：\\nimport { initGlobalState, MicroAppStateActions } from \'qiankun\';\\n\\n// 初始化 state\\nconst actions: MicroAppStateActions = initGlobalState(state);\\n\\nactions.onGlobalStateChange((state, prev) => {\\n  // state: 变更后的状态; prev 变更前的状态\\n  console.log(state, prev);\\n});\\nactions.setGlobalState(state);\\nactions.offGlobalStateChange();\\n\\n//微应用：\\n// 从生命周期 mount 中获取通信方法，使用方式和 master 一致\\nexport function mount(props) {\\n  props.onGlobalStateChange((state, prev) => {\\n    // state: 变更后的状态; prev 变更前的状态\\n    console.log(state, prev);\\n  });\\n\\n  props.setGlobalState(state);\\n}\\n```\\n\\n### 腾讯/wujie\\n\\nwebcomponents + iframe 的方式\\n\\n- props 注入机制\\n  子应用通过$wujie.props 可以轻松拿到主应用注入的数据\\n\\n```js\\n// 主应用可以通过props注入数据和方法：\\n<WujieVue name=\\"xxx\\" url=\\"xxx\\" :props=\\"{ data: xxx, methods: xxx }\\"></WujieVue>\\n\\n\\n// 子应用可以通过$wujie来获取：\\nconst props = window.$wujie?.props; // {data: xxx, methods: xxx}\\n```\\n\\n- window.parent 通信机制\\n  子应用 iframe 沙箱和主应用同源，子应用可以直接通过 window.parent 和主应用通信\\n\\n```js\\n// 主应用调用子应用的全局数据\\nwindow.document.querySelector(\'iframe[name=子应用id]\').contentWindow.xxx;\\n\\n// 子应用调用主应用的全局数据\\nwindow.parent.xxx;\\n```\\n\\n- 去中心化的通信机制\\n  无界提供了 EventBus 实例，注入到主应用和子应用，所有的应用可以去中心化的进行通信\\n\\n```js\\n// 主应用使用方式:\\n\\n// 如果使用wujie\\nimport { bus } from \\"wujie\\";\\n\\n// 如果使用wujie-vue\\nimport WujieVue from \\"wujie-vue\\";\\nconst { bus } = WujieVue;\\n\\n// 如果使用wujie-react\\nimport WujieReact from \\"wujie-react\\";\\nconst { bus } = WujieReact;\\n\\n// 主应用监听事件\\nbus.$on(\\"事件名字\\", function (arg1, arg2, ...) {});\\n// 主应用发送事件\\nbus.$emit(\\"事件名字\\", arg1, arg2, ...);\\n// 主应用取消事件监听\\nbus.$off(\\"事件名字\\", function (arg1, arg2, ...) {});\\n\\n// 子应用使用方式:\\n// 子应用监听事件\\nwindow.$wujie?.bus.$on(\\"事件名字\\", function (arg1, arg2, ...) {});\\n// 子应用发送事件\\nwindow.$wujie?.bus.$emit(\\"事件名字\\", arg1, arg2, ...);\\n// 子应用取消事件监听\\nwindow.$wujie?.bus.$off(\\"事件名字\\", function (arg1, arg2, ...) {});\\n\\n```\\n\\n### 京东/micro-app\\n\\nwebcomponents 的思路\\n\\n- history.pushState 结合主动触发 popState 事件\\n\\n```js\\nwindow.history.pushState(null, \'\', \'page2\'); // history\\nwindow.history.pushState(null, \'\', \'#/page2\'); // hash\\n\\n// 主动触发一次popstate事件\\nwindow.dispatchEvent(new PopStateEvent(\'popstate\', { state: null }));\\n```\\n\\n:::warning\\n不推荐\\n\\n1、popstate 事件是全局发送的，所有正在运行的应用都会接受到新的路由地址并进行匹配，要防止兜底到应用的 404 页面。\\n\\n2、window.history 并非适用于所有场景，一些框架如 vue-router4，angular 会出现问题，此时建议使用下面的方式 2、3。\\n:::\\n\\n- 数据通信控制跳转\\n\\n```js\\n// 子应用中监听数据变化;\\n\\n// 监听基座下发的数据变化\\nwindow.microApp.addDataListener(data => {\\n  // 当基座下发跳转指令时进行跳转\\n  if (data.path) {\\n    router.push(data.path);\\n  }\\n});\\n\\n// 基座下发跳转指令;\\n\\nimport microApp from \'@micro-zoe/micro-app\';\\n\\nmicroApp.setData(\'子应用name\', { path: \'/new-path/\' });\\n```\\n\\n- 传递路由实例\\n\\n主应用下发跳转函数\\n\\n### 字节/garfish\\n\\n- 提供了类似的 EventBus 机制 `Garfish.channel`\\n\\n### 阿里/icestack\\n\\n- 全局 `store`\\n\\n```js\\n// 主应用\\nimport { store } from \'@ice/stark-data\';\\n\\nconst userInfo = { name: \'Tom\', age: 18 };\\nstore.set(\'language\', \'CH\'); // 设置语言\\nstore.set(\'user\', userInfo); // 设置登录后当前用户信息\\nsetTimeout(() => {\\n  store.set(\'language\', \'EN\');\\n}, 3000);\\n\\n// 微应用\\nimport { store } from \'@ice/stark-data\';\\n\\n// 监听语言变化\\nstore.on(\\n  \'language\',\\n  lang => {\\n    console.log(`current language is ${lang}`);\\n  },\\n  true\\n);\\n\\n// 获取当前用户\\nconst userInfo = store.get(\'user\');\\n```\\n\\n- EventBus\\n\\n```js\\n// 主应用\\nimport { event } from \'@ice/stark-data\';\\n\\nevent.on(\'freshMessage\', () => {\\n  // 重新获取消息数\\n});\\n\\n// 微应用\\nimport { event } from \'@ice/stark-data\';\\n\\nevent.emit(\'freshMessage\');\\n```\\n\\n- props\\n\\nprops 注入\\n\\n### 小结\\n\\n经调研，业界微前端主流的方案有以下两种\\n\\n1. EventBus\\n2. props\\n\\n## 业务场景列举\\n\\n- 主应用跳子应用\\n- 子应用跳子应用，项目内跳转、新开浏览器 tab 页\\n- 子应用跳主应用，退出登陆等\\n- 主应用切换子应用，子应用监听到切换与被切换是同步进行的，无法做一些流程上的控制\\n\\n## 方案\\n\\n### 方案一\\n\\n`props` 下发数据 + `window` 上的自定义事件\\n脱离微前端本身的 `eventBus` 的方式，通过监听与触发事件来实现通信\\n\\n#### 优点\\n\\n- 实现简单，框架无关\\n- 非常容易实现子应用间，主子应用间的通信\\n- 主子完全解耦\\n\\n#### 缺点\\n\\n- 仅仅是一个通知，不方便做一些流程上的控制，如子应用在被切换前的异步行为\\n- 实际业务使用中，仍然需要结合 `props` 下发的数据，且代码编写上是分散的，增加维护成本\\n- 当多个子应用同时存在，并且监听同个事件时，可能会导致意想不到的问题\\n- 如使用了 `window` 上的自定义事件，需要及时手动销毁监听\\n\\n### 方案二\\n\\n下发 `eventBus` 实例 + 数据\\n\\n例如 `qiankun` 提供了 `initGlobalState`，内含有对于 `state` 数据的监听和 `set` 操作\\n\\n#### 优点\\n\\n- 使用更明确，统一了入口，便于维护\\n- 框架本身提供的功能，稳定性好\\n- `qiankun`、`icestack` 下发类似 `eventBus` 的实例直接提供了数据监听的方式，无需另外去了解事件触发的方式，api 更精简，心智负担更小\\n\\n#### 缺点\\n\\n- 框架本身提供的方式，有业务局限性，如`qiankun` 的 `initGlobalState`，并未提供数据获取的 `get` 操作\\n- 下发的方式导致主子有一定程度的耦合\\n\\n### 方案三\\n\\n对于需要暴露给子应用的数据，额外 `new` 一个包括了 `mutation`、`action`、`state` 的完整 `vuex` 实例下发给子应用\\n\\n#### 优点\\n\\n- 更多的场景适配，`props` 可以在微前端各个生命周期获取，能够方便做一些针对性的流程控制，比如在项目切换时，子应用根据 `props` 判断是否需要在卸载前跳转某个指定页面\\n- 对于子应用来说，具有更强的主观能动性，而不是被动的等待主应用通知\\n- 子应用无需手动销毁事件监听，例如下发的是 `store` 的实例，应用销毁时同步销毁实例即可\\n- 对于已经使用 `vue` 生态的项目，心智负担最小\\n\\n#### 缺点\\n\\n- 下发的方式导致主子有一定程度的耦合\\n- 微前端通信需要的只是数据的 `get`、`set` 和方法的调用，`vuex` 有些重\\n\\n### 方案四\\n\\n参考上述 `icestack` 的通信方式，结合方案三，另外维护一个包，主子通过直接引入包\\n\\n`@ice/stark-data` 这个包是将数据通过命名空间存在`window`对象里，非持久（可以考虑结合`sessionStorage`、`localStorage`）\\n\\n可以维护一个类似的库满足业务需求\\n\\n#### 优点\\n\\n- 主子不强耦合\\n- 使用方便\\n- 支持按需引入\\n\\n#### 缺点\\n\\n- 需要额外维护一个包，有一定的开发成本\\n- `sessionStorage`、`localStorage` 的存储大小有限，需要斟酌存储的数据量\\n\\n## 结论\\n\\n综上所述，可以考虑下发一个 store 或者单独维护一个具备状态管理功能的包来处理微前端的通信问题\\n\\n## 参考\\n\\n- [qiankun issue 讨论：传递 vue store](https://github.com/umijs/qiankun/issues/566)\\n- [umi/qiankun](https://qiankun.umijs.org/zh/api#initglobalstatestate)\\n- [京东/micro-app](https://zeroing.jd.com/docs.html#/zh-cn/jump)\\n- [腾讯/wujie](https://wujie-micro.github.io/doc/guide/communication.html)\\n- [字节/garfish](https://www.garfishjs.org/api/channel)\\n- [阿里/icestack](https://micro-frontends.ice.work/docs/guide/advanced/communication)\\n","frontmatter":{},"url":"/plan/micro-fe-communication/"},{"src":"# 前端导航方案\\n\\n## 痛点\\n\\n在使用 vue-router 进行中后台项目开发时，存在以下痛点\\n\\n1. router.push 到一个新页面，需要有返回操作，返回操作可能会有参数携带，并且需要显示上级页面名称及当前页面名称\\n2. 多级面包屑的跳转，考虑参数携带\\n3. 基于 qiankun 等的微应用的主子跳转、子子跳转，新开 tab 的问题\\n4. 出于安全问题浏览器不提供上一个历史记录的接口\\n\\n## 相关特性\\n\\n- `http.referer` 只能够获取除了 `hash` 之外的 `url`\\n- `document.referrer` 行为与 `http.referer` 不一致，通过 a 标签跳转可以获取除了 `hash` 外的完整 `url`，链接直接点开或者粘贴网址进入都为空字符串，经测试，`push` 等方法无法改变 `document`.`referrer`，但是可以改变 `http.referer`，不包括 `hash`\\n- `history` 历史栈，`router.push` 即 `history.pushState` 压栈，`router.replace` 即 `history.replaceState` 修改当前记录，`a` 标签的跳转不会压栈，`vue-router` 的重定向也不会压栈\\n- `back()`和 `go(-1)`，mdn 描述为一致，都等于点击浏览器的回退，但是在一些说法中有人提出 `go(-1)`会重载页面，`back` 不会重载\\n- `back/forward cache`。浏览器的前进/回退缓存，可以缓存浏览过的页面快照（包括 `JavaScript` 堆），使用 `bfcache` 恢复的重复访问总是比非 `bfcache` 导航更快\\n\\n## 需求描述\\n\\n在需要返回按钮的页面，获取上一个路由的路由信息及正确的路由返回\\n\\n## 方案\\n\\n### 方案一\\n\\n选择采用 `sessionStorage`，记录上一页的路由信息\\n\\n全局混入全局前置路由守卫，记录离开页面的路由信息，如\\n\\n```js\\nrouter.beforeEach((to, from, next) => {\\n  sessionStorage.set(to.name, from);\\n});\\n```\\n\\n同时提供一个返回方法，获取缓存的路由信息并使用 `push` 返回\\n\\n#### 优点\\n\\n- 自动记录，用户无需关注参数的传递\\n\\n#### 缺点\\n\\n- 仅限两级跳转的简单场景，多级跳转情况下，来源路由会反调\\n\\n### 方案二\\n\\n同样采用 `sessionStorage`存储路由信息\\n\\n全局混入 `beforeRouteLeave` 或者`beforeRouteEnter`方法，记录离开页面的路由信息\\n\\n#### 优点\\n\\n- 仅在路由表里定义的组件会触发，且可以通过在 meta 里定义属性，做到精准控制对缓存的存取\\n\\n#### 缺点\\n\\n- 同样只适用于两级跳转的简单场景\\n\\n####\\n\\n### 方案三\\n\\n`document.referrer`虽然不能做到获取`hash`，但是可以判断与当前页是否同源\\n\\n结合思路二，将上一页的路由信息存在`session`\\n\\n在确保项目内合理使用`push、replace`的情况下，通过`referrer`判断，如果上一页与当前页同源，直接调用 `router.back()`，`router.go(-1)`\\n\\n否则`referrer`为空字符串，此时`replace`到缓存信息中的路由，\\n\\n#### 优点\\n\\n- 理论上体验会更好，可以保留浏览器的原生行为，在条件允许的情况下支持`back/forward Cache`，可以缓存浏览过的页面快照（包括 `JavaScript` 堆），使用 `bfcache` 恢复的重复访问总是比非 `bfcache` 导航更快\\n- 能够保证`history`栈的顺序，无论是使用 `push`还是 `replace` 回退，都会导致 `history` 栈不正确\\n\\n#### 缺点\\n\\n- 浏览器出于安全考虑，无法获取到真正完整的 `referrer` 地址，因此还是需要配合路由信息缓存\\n\\n### 方案四\\n\\n自行维护一个`history`栈\\n\\n- [vue-navigation](https://github.com/zack24q/vue-navigation)\\n- [vue-page-stack](https://github.com/hezhongfeng/vue-page-stack)\\n\\n以上两个库主要是针对`keep-alive`缓存页面，没有去存储上页的路由信息\\n\\n#### 优点\\n\\n- 维护了一个访问历史栈，与浏览器的 back/forward 同步\\n- 做了 keep-alive 缓存\\n\\n#### 缺点\\n\\n- 没有存储相关的路由信息，需要修改使用，取栈顶的 path 去路由表中匹配\\n- 没有对 back 行为做限制，可以结合 referrer\\n- 每次的 push/replace 都会触发对应的缓存存取操作\\n\\n## 参考\\n\\n- [referrer mdn](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/referrer)\\n- [referrer 张鑫旭](https://www.zhangxinxu.com/wordpress/2017/02/js-page-url-document-referrer/)\\n- [http-referer 阮一峰](https://www.ruanyifeng.com/blog/2019/06/http-referer.html)\\n- [浏览器滚动保存行为 张鑫旭](https://www.zhangxinxu.com/wordpress/2022/05/history-scrollrestoration/)\\n- [stackoverflow 如何获取上一个 url](https://stackoverflow.com/questions/3528324/how-to-get-the-previous-url-in-javascript)\\n- [vuejs issue-面包屑](https://github.com/vuejs/vue-router/issues/3617)\\n- [stackoverflow 获取上一个页面的 url，包括 hash](https://stackoverflow.com/questions/36447977/how-to-get-previous-url-including-hash-fragment-using-javascript)\\n- [stackoverflow 在 react-router 中检测上一个路径](https://stackoverflow.com/questions/39288915/detect-previous-path-in-react-router)\\n- [谷歌开发者文档 back/forward 缓存](https://developer.chrome.com/docs/devtools/application/back-forward-cac)\\n- [谷歌开发者文档，请求头 referrer](https://developer.chrome.com/blog/referrer-policy-new-chrome-default/)\\n- [谷歌开发者文档 referer 最佳实践](https://web.dev/i18n/zh/referrer-best-practices/#%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0-csrf-%E4%BF%9D%E6%8A%A4)\\n- [永远不要使用 unload 事件](https://web.dev/bfcache/?utm_source=devtools#never-use-the-unload-event)\\n- [vue issue bfCache 失效](https://github.com/vuejs/vue/issues/8109)\\n- [next.js issue 讨论 一](https://github.com/vercel/next.js/issues/4136)\\n- [next.js issue 讨论 二](https://github.com/vercel/next.js/discussions/36723)\\n","frontmatter":{},"url":"/plan/navigation/"},{"src":"# 力扣\\n## 两数之和\\n\\n给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。\\n你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。\\n示例:\\n给定 nums = [2, 7, 11, 15], target = 9\\n因为 nums[0] + nums[1] = 2 + 7 = 9\\n所以返回 [0, 1]\\n\\n```javascript\\n// 暴力解法\\nfunction(nums, target) {\\n  for(let i=0;i<nums.length;i++){\\n    for(let j=i+1;j<nums.length;j++){\\n      if(nums[i]+nums[j]===target)return [i,j]\\n    }\\n  }\\n  return []\\n};\\n// hash表\\nfunction(nums,target){\\n  const map=new Map()\\n  for(let i=0;i<nums.length;i++){\\n   if(map.has(target-nums[i])){\\n    return [i,map.get(target-nums[i])]\\n   }else{\\n     map.set(nums[i],i)\\n   }\\n  }\\n  return []\\n}\\n```\\n\\n## 路径总和\\n\\n给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。\\n\\n```javascript\\n// 广度优先遍历\\nfunction(root, targetSum) {\\n    if(!root) return false\\n    let nodes = [root]\\n    while(nodes.length){\\n        const current = nodes.pop()\\n        const isLeaf = !current.left && !current.right\\n        if(isLeaf && current.val ===targetSum){\\n            return true\\n        }\\n\\n         if(current.left){\\n        current.left.val=current.left.val+current.val\\n        nodes.unshift(current.left)\\n         }   \\n         if(current.right){\\n        current.right.val=current.right.val+current.val\\n        nodes.unshift(current.right)\\n         }\\n\\n    }\\n    return false\\n};\\n\\n```\\n\\n","frontmatter":{},"url":"/practice/leetcode.html"},{"src":"# 手写 promise\\n\\n## promise 基本特征\\n\\n1. 有三个状态：pengding、fullfilled、rejected\\n2. new Promise 时，需要传递一个回调，立即执行\\n3. 回调接受两个参数，resolve 和 reject\\n4. 默认状态是 pending\\n5. promise 有一个 value 保存成功状态的值，可以是 undefined、thenable、promise\\n6. promise 有一个 reason 保存失败状态的值\\n7. promise 智能从 pending 到 rejected 或者 fullfilled，状态一旦确认就不会再改变\\n8. promise 必须有一个 then 方法，接受两个参数，分别是成功的回调 onFulfilled 和失败的回调 onRejected\\n9. 如果调用 then，promise 已经成功，则执行 onFullfilled，参数是 promise 的 value\\n10. 如果调用 then，promise 已经失败，调用 onRejected，参数是 promise 的 reason\\n11. 如果 then 抛出异常，那么就把异常作为参数，传给下一个 then 的失败的回调 onRejected\\n12. then的参数onFulfilled和onRejected可以缺省，如果不是函数，就忽略，且依旧可以在下面的then中获取到之前返回的值\\n13. promise可以then多次，每次都返回新的promise\\n14. 如果promise返回一个普通值，就把这个结果作为参数，传递给下一个then的成功回调\\n15. 如果promise抛出异常，那么这个异常作为参数传递给下一个then的失败回调\\n16. 如果返回一个promise，会等这个promise执行完，如果成功就走下个then，如果失败或者抛出异常就走下个的失败\\n17. 如果then的返回值和promise是同一个引用对象，造成循环引用，那就抛出异常\\n18. 如果then的返回值是一个promise，且x同时调用resolve和reject，第一个调用优先，状态不会再次被改变\\n\\n<<< ./promise/index.js\\n\\n\\n## promise的方法实现\\n\\n```js\\nstatic resolve(data){\\n  if(data instanceof Promise){\\n\\n  }\\n\\n}\\n\\n```","frontmatter":{},"url":"/practice/promise.html"},{"src":"---\\nlayout: false\\ntitle: 王俊然-前端开发-13516724981\\ntitleTemplate: \':title\'\\nhead:\\n  - - meta\\n    - name: viewport\\n      content: \'width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover\'\\n  - - meta\\n    - charset: \'UTF-8\'\\n---\\n\\n<script setup>\\nimport MyCV from \'./index.vue\'\\n<\/script>\\n\\n<ClientOnly>\\n  <MyCV />\\n</ClientOnly>\\n","frontmatter":{"layout":false,"title":"王俊然-前端开发-13516724981","titleTemplate":":title","head":[["meta",{"name":"viewport","content":"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"}],["meta",{"charset":"UTF-8"}]]},"url":"/resume/"},{"src":"# 一键生成 ppt 的工具\\n\\n## 特性\\n\\n- 将 dom 结构转换为 md 文件，并以 ppt 的形式输出\\n- 减少在 ppt 美化上花费的时间\\n\\n## 注意事项\\n\\n对于要生成 ppt 的文章，需要自己有意识地去划分段落结构，大段落用`---`分割，小段落用`--`分割\\n\\n## 计划\\n\\n✅ 识别文本段落，自动划分\\n\\n❌ 全屏 ppt 下的退出功能\\n\\n❌ ppt 模式下更换皮肤\\n\\n❌ ppt 模式下使用背景图片\\n\\n❌ 文字大小调整\\n","frontmatter":{},"url":"/tools/slides.html"},{"src":"# WEB3\\n\\n## 学习路线\\n\\n公链-DeFi-NFT-GameFi-DAO、SocialFi-基础设施\\n\\n公链是一切的基础；DeFi 是 Web3 的发动机；NFT 相对独立又特殊，是新的应用范式；GameFi 需要“游戏+NFT+DeFi”的融会贯通；DAO 和 SocialFi 更多的是聚焦在人的角度去设计的产品；隐私、存储等基础设施赛道涉及到的知识相对比较难懂，可以作为扩展类的学习。\\n\\n## 概念\\n\\n基于区块链的去中心化，涵盖了数字货币、智能合约、区块链技术、硬件基础设置（VR、AR、存储、传感器等）、非同质化代币（NFT）、Defi 去中心化金融服务、元宇宙 Metaverse 以及全新的社区治理模式 DAO 等\\n\\n- 数字货币是 Web3 社会的灵魂。提供了社会的通行货币，用它们可以实现 Web3 自己的经济系统\\n- 区块链和智能合约，相当于 Web3 社会的土地和土壤，一切的建设、收获、活动都基于在这片土壤之上\\n- 去中心化自治组织 DAO，是 Web3 社会的组织形式，将人与人团结成为共同体的制度\\n- Web3 金融和 Defi，为 Web33 的世界提供了流动的金钱，为资产带来价值，给人们带来了激励和收入\\n- 元宇宙和 NFT 相当于人们在 Web3 领域里消费和活动的场景及数字化产品\\n\\n传统 web2 在早期用户沉淀的过程中采用免费模式、羊毛出在羊身上、现金激励等手段。\\n\\nweb3 则是把行业打造成共建社区。发行非常便宜的代币或者股份给非常分散化的用户，由大家共建社区。web3 可以把\\nweb2 的东西重做一遍。比如 2018 年的“Decentraland”，土地有限供应，可以自由买卖\\n\\n### 公链\\n\\n公链着眼于建设 Web3 的底层基础，围绕“去中心化、可扩展性、安全性”的“不可能三角”做技术的改进与探索。\\n\\n### DeFi\\n\\nDeFi 致力于提升 Web3 的资产利用效率，构建链上的去中心化金融体系，它是各类项目的发动机和连接器，极大的丰富了链上应用场景，给用户提供了新的利益来源，提升了 Token 流动性。\\n\\n- 借贷与去中心化交易所是 DeFi 的核心。\\n- 流动性挖矿使 Defi 的动力进一步增强\\n\\n### NFT\\n\\nNFT 扩展了 Web3 的应用领域。从单一的金融属性开始向品牌、实物发展。Web3 需要考虑如何与其他领域互通，NFT 可能是其中一个正确答案\\n\\n### GameFi\\n\\n用户过少是阻碍 Web3 发展的重要原因，GameFi 很有可能打开这扇流量之门。Play2Earn 的模式吸引了大量用户参与\\n\\nGameFi 的本质还是 DeFi，游戏只是它的外壳。\\n\\n### DAO、SocialFi\\n\\nDAO 是全新的团队组织架构，极具活力与效率\\n\\n## 知识图谱\\n\\n![image.png](./images/road.jpeg)\\n\\n## WAGMI\\n\\nWe’re All Going to Make It\\n\\n共建、共赢是 web3 的正确三观\\n\\n## 市场的涨跌\\n\\n任何交易市场都存在牛市、熊市，如何以正确的姿势面对熊市？\\n\\n回归本心，默念以下几个问题：\\n\\n1. 互联网巨头们垄断的世界是否真的走向了衰败\\n2. web3 是不是值得期待的对抗这些巨头们的筹码\\n3. 我们设想的新领域的构件是否仍然值得在下一阶段进行大量投资\\n4. 熊市里那些基本面强的项目是否变得更便宜了\\n5. 市场上是否有充足的资金可用于资助真正有含金量的项目\\n6. 是否相信 5-10 年内市场会重返牛市\\n\\n需要的注意的是：\\n\\n1. 非专业交易员，不要使用杠杆赌博\\n2. 不要为了不必要的投资负债\\n3. 不要做空\\n\\n在牛市需要注意的是：\\n\\n1. 市场异动引来监管风险\\n2. 比特币成为数字黄金。衡量比特币市场的基本面，用 MVRV 数值，即比特币的名义流通数值与其实际已实现市值（当下时间内链上所有比特币流通时最后价格的总和）相比，非长期持有者，当比例到 3，就是最好的抛售获益时间（约为 10-12.5 万美元之间），低于 1 就补仓\\n3. 以太坊超越（FaceBook、Apple、Microsoft、Google、Amazon）中的任何一家。代表 web3 底层成熟，也就是其币价天花板，在此之前，我们永远可以期待下一波牛市\\n4. DeFi 金融被收编。目前交易量还不到全球银行市值的 1%，但是回报率极高，有大量的诈骗属性的资金盘割了大量韭菜\\n5. 当大妈和阿姨都在讨论 NFT。虚拟货币在中国属于非法金融产品，NFT（Non-Fungible Token 非同质化代币）在中国也就被改名为 NFC 了（Non-Fungible Collection 非同质化数字藏品）。顾名思义，为一个数字作品（可以是图片、音乐、视频或者某组程序）赋予唯一的一串编码，使其具有“独一无二”的属性。但事实上，并不是所有的“独一无二”都经得起推敲的。NFT 本质上还是代币，流通性差，有价无市。国内的数字藏品不上链，更加不能用于赚钱\\n\\n## 分布式存储和去中心化物联网是 Web3 的基座\\n\\n分布式存储是 Web3 基础设施的一个关键层，将稳步抢占现有互联网基础设施供应商的利润\\n\\n## 比特币正在建立数字黄金的地位\\n\\n其地位稳固，稀缺性的马太效应能轻而易举煽动狂热\\n\\n## 以太坊能否挑战比特币\\n\\n微乎其微。eth 如果能超越比特币，更可能是市场认为这是世上最好的分布式虚拟计算机及其增长潜力比比特币更高\\n\\n## 赛道研究\\n\\n# 参考\\n\\n- [Web3 新手教程：从入门到精通](https://zhuanlan.zhihu.com/p/647524814)\\n- [Web3 漫游指南](https://mirror.xyz/tannhauser2049.eth/vPrV-lqGjFpT2VWT4kDvtjhZayxm6n8ym7ra4wiegSc)\\n","frontmatter":{},"url":"/web3/"}]'),nn={class:"slides"},en={"data-markdown":""},tn={"data-template":""},rn=N({__name:"slides-viewer",props:{visible:{type:Boolean}},emits:["close"],setup(P,{emit:E}){const _=P,D=E,M=z(),x=c(null),i=c(null),g=c(null),d=c("black"),w=c(""),o=u(null),h=u(null),j=u(null),S=u(null),O={beige:()=>e(()=>import("./beige.KH7Z96J6.js"),[]),black:()=>e(()=>import("./black.Dhl1Ax5p.js"),[]),"black-contrast":()=>e(()=>import("./black-contrast.Cz6ea3QM.js"),[]),blood:()=>e(()=>import("./blood.sGDQt6xN.js"),[]),dracula:()=>e(()=>import("./dracula.CQ3pvJzM.js"),[]),league:()=>e(()=>import("./league.CWHSdNdR.js"),[]),moon:()=>e(()=>import("./moon.DVPPdbto.js"),[]),night:()=>e(()=>import("./night.Tv9g_Qy2.js"),[]),serif:()=>e(()=>import("./serif.CmRTT4Aj.js"),[]),simple:()=>e(()=>import("./simple.DfGIR_X3.js"),[]),sky:()=>e(()=>import("./sky.sZwgIlsv.js"),[]),solarized:()=>e(()=>import("./solarized.60uazF9r.js"),[]),white:()=>e(()=>import("./white.BUeFwSHg.js"),[]),"white-contrast":()=>e(()=>import("./white-contrast.DL9BSTzh.js"),[]),"white-contrast-compact-verbatim-headers":()=>e(()=>import("./white_contrast_compact_verbatim_headers.iwFpelQc.js"),[])},s=c(null),T=[{label:"米色 (Beige)",value:"beige"},{label:"黑色 (Black)",value:"black"},{label:"黑色高对比 (Black Contrast)",value:"black-contrast"},{label:"血液 (Blood)",value:"blood"},{label:"Dracula",value:"dracula"},{label:"联盟 (League)",value:"league"},{label:"月亮 (Moon)",value:"moon"},{label:"夜晚 (Night)",value:"night"},{label:"衬线 (Serif)",value:"serif"},{label:"简约 (Simple)",value:"simple"},{label:"天空 (Sky)",value:"sky"},{label:"Solarized",value:"solarized"},{label:"白色 (White)",value:"white"},{label:"白色高对比 (White Contrast)",value:"white-contrast"},{label:"白色高对比紧凑 (White Contrast Compact)",value:"white-contrast-compact-verbatim-headers"}],f=async n=>{if(typeof window>"u")return;if(i.value){const r=T.map(a=>`theme-${a.value}`);i.value.classList.remove(...r),i.value.classList.add(`theme-${n}`)}s.value&&s.value.parentNode&&(s.value.parentNode.removeChild(s.value),s.value=null);const t=O[n];if(t)try{const r=await t(),a=r.default||r.url||r;if(a&&typeof a=="string"){const l=document.createElement("link");l.rel="stylesheet",l.href=a,l.id=`reveal-theme-${n}`,document.head.appendChild(l),s.value=l}}catch(r){console.error(`Failed to load theme ${n}:`,r)}localStorage.setItem("reveal-theme",n),d.value=n},L=async()=>{if(typeof window>"u")return;const n=localStorage.getItem("reveal-theme")||"black";await f(n)},R=()=>{const n=M.path.replace(K,"")||"/index",t=Y.find(r=>r.url===n);return(t==null?void 0:t.src)||""},q=async()=>{if(typeof window>"u"||!x.value||!i.value)return;if(!h.value)try{const t=await e(()=>import("./reveal.esm.DaHoSpNm.js"),[]);h.value=t.default||t;const r=await e(()=>import("./markdown.esm.DotuGrRK.js"),[]);j.value=r.default||r;const a=await e(()=>import("./highlight.esm.UsqGfS9W.js"),[]);S.value=a.default||a}catch(t){console.error("Failed to load reveal.js:",t);return}if(o.value){try{o.value.destroy()}catch{}o.value=null}const n=R();if(n)w.value=n;else{console.warn("No markdown content found for current page");return}await b(),await L(),await b(),o.value=new h.value(i.value,{plugins:[j.value,S.value],hash:!0,controls:!0,progress:!0,center:!0,touch:!0,keyboard:!0,overview:!0,transition:"slide",backgroundTransition:"fade",markdown:{smartypants:!0},highlight:{highlightOnLoad:!0}});try{await o.value.initialize(),i.value&&f(d.value)}catch(t){console.error("Failed to initialize Reveal.js:",t)}},B=()=>{s.value&&s.value.parentNode&&(s.value.parentNode.removeChild(s.value),s.value=null)},A=()=>{if(o.value){try{o.value.destroy()}catch{}o.value=null}B(),D("close")};return H(()=>_.visible,async n=>{n?(await b(),await q()):A()}),(n,t)=>{const r=$,a=X,l=Q;return p(),C(J,{to:"body"},[n.visible?(p(),k("div",{key:0,ref_key:"containerRef",ref:x,class:W(`theme-${d.value} reveal-container w-screen h-screen`)},[m("div",{ref_key:"revealRef",ref:i,class:"reveal"},[m("div",nn,[m("section",en,[m("textarea",tn,U(w.value),1)])])],512)],2)):v("",!0),n.visible?(p(),k("div",{key:1,ref_key:"themeContainerRef",ref:g,class:"absolute top-0 left-0 shadow-sm w-full h-15 z-[10001] flex justify-between p-4 opacity-0 hover:opacity-100 transition-all duration-300"},[g.value?(p(),C(r,{key:0,modelValue:d.value,"onUpdate:modelValue":t[0]||(t[0]=F=>d.value=F),options:T,placeholder:"选择主题",size:"small",to:g.value,class:"w-[200px]","onUpdate:value":f},null,8,["modelValue","to"])):v("",!0),y(l,{circle:"",onClick:A},{icon:I(()=>[y(a,null,{default:I(()=>[y(V(Z))]),_:1})]),_:1})],512)):v("",!0)])}}}),on=G(rn,[["__scopeId","data-v-a90c74d3"]]);export{on as default};
