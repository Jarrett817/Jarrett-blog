<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>数据结构与算法 | 🏠 JarrettBlog</title>
    <meta name="description" content="前端学习笔记">
    <link rel="stylesheet" href="/Jarrett-blog/assets/style.f2b3dc79.css">
    <link rel="modulepreload" href="/Jarrett-blog/assets/Home.c5e88031.js">
    <link rel="modulepreload" href="/Jarrett-blog/assets/reveal.esm.7135e7ce.js">
    <link rel="modulepreload" href="/Jarrett-blog/assets/highlight.esm.c7d93732.js">
    <link rel="modulepreload" href="/Jarrett-blog/assets/markdown.esm.479aed26.js">
    <link rel="modulepreload" href="/Jarrett-blog/assets/app.dff7797b.js">
    <link rel="modulepreload" href="/Jarrett-blog/assets/computer-basic_fucking-arithmetic_index.md.9900c140.lean.js">
    <link rel="modulepreload" href="/Jarrett-blog/assets/app.dff7797b.js">
    <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <meta name="twitter:title" content="数据结构与算法 | 🏠 JarrettBlog">
    <meta property="og:title" content="数据结构与算法 | 🏠 JarrettBlog">
  </head>
  <body>
    <div id="app"><!--[--><!----><!----><!--[--><div class="theme"><header class="nav-bar" data-v-675d8756><div class="sidebar-button" data-v-675d8756><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/Jarrett-blog/" aria-label="🏠 JarrettBlog, back to home" data-v-675d8756 data-v-4a583abe><!----> 🏠 JarrettBlog</a><div class="flex-grow" data-v-675d8756></div><div class="nav" data-v-675d8756><nav class="nav-links" data-v-675d8756 data-v-15acbf05><!--[--><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/Jarrett-blog/front-end/html/" data-v-b8818f8c>✏️ 前端学习笔记 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item active" href="/Jarrett-blog/computer-basic/design-pattern/" data-v-b8818f8c>⛰️ 计算机基础 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/Jarrett-blog/tools/slides" data-v-b8818f8c>🔧 工具包 <!----></a></div></div><!--]--><!----><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item isExternal" href="https://github.com/Jarrett817/Jarrett-blog" target="_blank" rel="noopener noreferrer" data-v-b8818f8c>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-b8818f8c><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div></nav></div><!--[--><!--]--></header><aside class="sidebar" data-v-83e92a68><nav class="nav-links nav" data-v-83e92a68 data-v-15acbf05><!--[--><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/Jarrett-blog/front-end/html/" data-v-b8818f8c>✏️ 前端学习笔记 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item active" href="/Jarrett-blog/computer-basic/design-pattern/" data-v-b8818f8c>⛰️ 计算机基础 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/Jarrett-blog/tools/slides" data-v-b8818f8c>🔧 工具包 <!----></a></div></div><!--]--><!----><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item isExternal" href="https://github.com/Jarrett817/Jarrett-blog" target="_blank" rel="noopener noreferrer" data-v-b8818f8c>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-b8818f8c><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div></nav><!--[--><!--]--><ul class="sidebar-links" data-v-83e92a68><!--[--><li class="sidebar-link"><a class="sidebar-link-item" href="/Jarrett-blog/computer-basic/design-pattern/">设计模式</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/Jarrett-blog/computer-basic/internet/">计算机网络</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item active" href="/Jarrett-blog/computer-basic/fucking-arithmetic/">数据结构与算法</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#时间空间复杂度">时间空间复杂度</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#数组">数组</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#为什么很多语言中数组都从-0-开始编号">为什么很多语言中数组都从 0 开始编号</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#如何实现随机访问">如何实现随机访问</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#为何数组的插入和删除操作是低效的">为何数组的插入和删除操作是低效的</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#容器能否代替数组">容器能否代替数组</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#解答：数组下标从-0-开始">解答：数组下标从 0 开始</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#链表">链表</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#循环链表">循环链表</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#双向链表">双向链表</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#链表的删除">链表的删除</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#链表-vs-数组">链表 VS 数组</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#lru-缓存淘汰算法">LRU 缓存淘汰算法</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#注意事项">注意事项</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#栈">栈</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#栈在函数调用中的应用">栈在函数调用中的应用</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#栈在表达式求值中的应用">栈在表达式求值中的应用</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#栈在括号匹配中的应用">栈在括号匹配中的应用</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#队列">队列</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#阻塞队列和并发队列">阻塞队列和并发队列</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#线程池没有空闲线程时，新的任务请求如何处理？">线程池没有空闲线程时，新的任务请求如何处理？</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#基于链表和数组的队列对于排队请求有什么区别？">基于链表和数组的队列对于排队请求有什么区别？</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#递归">递归</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#排序">排序</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#为什么插入排序比冒泡排序更受欢迎">为什么插入排序比冒泡排序更受欢迎</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#排序算法的内存消耗">排序算法的内存消耗</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#排序算法的稳定性">排序算法的稳定性</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#冒泡排序">冒泡排序</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#插入排序">插入排序</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#选择排序">选择排序</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#归并排序">归并排序</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#快速排序">快速排序</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#桶排序">桶排序</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#计数排序">计数排序</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#基数排序">基数排序</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#排序优化">排序优化</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#查找算法">查找算法</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#二分查找">二分查找</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#移除元素">移除元素</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#滑动窗口">滑动窗口</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#有序数组的平方排序">有序数组的平方排序</a><!----></li></ul></li><!--]--></ul><!--[--><!--]--></aside><!-- TODO: make this button accessible --><div class="sidebar-mask"></div><main class="page" data-v-7eddb2c4><div class="container" data-v-7eddb2c4><!--[--><!--]--><div style="position:relative;" class="content" data-v-7eddb2c4><div><h1 id="数据结构与算法"><a class="header-anchor" href="#数据结构与算法" aria-hidden="true">#</a> 数据结构与算法</h1><h2 id="时间空间复杂度"><a class="header-anchor" href="#时间空间复杂度" aria-hidden="true">#</a> 时间空间复杂度</h2><p>算法是用来操作数据、解决问题的一组方法。主要是用事后统计法和事前分析估算衡量算法之间的优劣。 事后统计是通过统计、监控、利用计时器对不同算法的运行时间进行比较，从而确定算法效率的高低，但是有非常大的局限性。 事前分析估算是在计算机程序编写之前，依据统计方法对算法进行估算 比如斐波那契数列 0，1，1，2，3，5，7，13，求第 n 个斐波那契数</p><div class="language-javascript"><pre><code><span class="token comment">// 递归实现</span>
<span class="token keyword">function</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">fun1</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fun1</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 循环实现</span>
<span class="token keyword">function</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span>
  <span class="token keyword">let</span> first <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> second <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> sum <span class="token operator">=</span> first <span class="token operator">+</span> second<span class="token punctuation">;</span>
    first <span class="token operator">=</span> second<span class="token punctuation">;</span>
    second <span class="token operator">=</span> sum<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> second<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>时间复杂度即运行消耗的时间，空间复杂度即消耗的内存空间 我们在计算时间复杂度时，代码每运行一次，记作一个单位时间，for(let i=0;i&lt;n;i++)循环就是 n 个单位时间，以此类推计算出某个函数或者某个循环的时间复杂度 **T(n)=O(f(n))**公式</p><ul><li>T(n)表示代码执行的时间</li><li>n 表示数据规模大小</li><li>f(n)表示每行代码执行的次数总和</li><li>因为这时一个公式，所以用 f(n)表示。公式中的 O，表示代码的执行时间 T(n)与 f(n)表达式成正比，代表的是一种增长趋势</li></ul><p><strong>大数据规模时可以忽略掉“常数、低阶次、系数”都可省略，主要是找出对趋势起决定性作用的那个部分。</strong> **大 O 时间复杂度实际上并不是具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以也叫做渐进时间复杂度，简称时间复杂度 ** n<em>2 及以上阶的时间复杂度效率很低，递归的时间复杂度约为 2</em>n，呈指数级，因此效率很低 ​</p><p>时间复杂度还可分为最好情况、平均情况和最坏情况。 <img src="/Jarrett-blog/assets/complexity.5eb32f19.png" alt="image.png"> 还可以考虑概率，但实际应用中，我们一般只看最坏的情况。</p><h2 id="数组"><a class="header-anchor" href="#数组" aria-hidden="true">#</a> 数组</h2><p>数组下标都是从 0 开始，内存空间的地址是连续的</p><h3 id="为什么很多语言中数组都从-0-开始编号"><a class="header-anchor" href="#为什么很多语言中数组都从-0-开始编号" aria-hidden="true">#</a> 为什么很多语言中数组都从 0 开始编号</h3><h3 id="如何实现随机访问"><a class="header-anchor" href="#如何实现随机访问" aria-hidden="true">#</a> 如何实现随机访问</h3><p>数组是一种线性表数据结构，是一组连续的内存空间，存储具有相同类型的数据</p><h4 id="关键词解析"><a class="header-anchor" href="#关键词解析" aria-hidden="true">#</a> 关键词解析</h4><blockquote><p>线性表。排成线的结构，每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈也是线性表结构 非线性表。二叉树、堆、图。因为这些数据类型不是简单的前后关系 连续的内存空间和相同类型的数据。数组正是因为如此，才得以有了随机访问的特性，但是对于数据的删除和插入，数组就显得有些低效，为了保证连续性需要做大量的搬移工作</p></blockquote><p><img src="/Jarrett-blog/assets/array-address.d9ceb039.png" alt="image.png"></p><p>如图，一个长度为 10 的数组，计算机给数组分配了一块连续内存空间 1000-1039</p><p>首地址 base_address=1000</p><p>计算机会给每个内存单元分配一个地址，寻址公式<code>a[i]_address=base_address+i*data_type_size</code></p><p><code>data_type_size</code>表示数组中每个元素大小，通过首地址+下标乘以元素大小取到内存地址</p><p><strong>数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)</strong></p><h3 id="为何数组的插入和删除操作是低效的"><a class="header-anchor" href="#为何数组的插入和删除操作是低效的" aria-hidden="true">#</a> 为何数组的插入和删除操作是低效的</h3><p>在中间插入元素，后面的都要移动，仅在末尾插入不需移动，平均时间复杂度为(1+2+...n)/n=O(n)</p><p>但如果不需要保持数组的有序性，直接插入到最后一个位置就可以了</p><p>要优化可以将多次的删除、插入操作集中在一起执行，这样元素尽量被少移动，大大减少了数据搬移的消耗</p><h3 id="容器能否代替数组"><a class="header-anchor" href="#容器能否代替数组" aria-hidden="true">#</a> 容器能否代替数组</h3><p><strong>不能</strong></p><p>比如 java 的 ArrayList、C++ STL 中的 vector</p><p>使用容器的好处在于，将很多数组操作的细节封装了起来，比如数组插入、删除时搬移其他数据时。还有个优势是支持动态扩容。</p><p>数组需要预先指定大小，因为需要分配连续的内存空胶囊，比如我们只申请了 10，但是要用 11 时，我们需要重新分配一块更大的空间，将原来的数据复制过去，然后将新的数据插入</p><p>而 ArrayList 会在存储空间不够时，自动将空间扩容为 1.5 倍大小</p><h4 id="数组的适用场景"><a class="header-anchor" href="#数组的适用场景" aria-hidden="true">#</a> 数组的适用场景</h4><ul><li>java 的 ArrayList 无法存储基本类型，int、long，需要封装为 Integer、Long 类，但是自动装箱、自动拆箱有一定的性能消耗</li><li>数据大小事先已知，操作简单</li><li>定义类型的时候更加容易。多维数组的类型声明可能会需要嵌套的泛型</li></ul><h3 id="解答：数组下标从-0-开始"><a class="header-anchor" href="#解答：数组下标从-0-开始" aria-hidden="true">#</a> 解答：数组下标从 0 开始</h3><ul><li>数组下标的确切定义是偏移（offset），如果从 1 开始计数，每次还得(k-1)*type_size，从 1 开始编号，多了一次不必要的操作，数组作为基础数据结构需要高性能，所以从 0 开始</li><li>历史原因。C 是从 0 开始，java 等等都沿用</li></ul><h2 id="链表"><a class="header-anchor" href="#链表" aria-hidden="true">#</a> 链表</h2><p>链表与数组的差别在于，数组需要连续的存储空间，这就会导致如果所需的连续空降过大，会导致内存申请失败，即便总的多余内存时足够的，这时候，链表就更合适，因为链表不需要连续的存储空间，它可以将一组零散的内存块串联起来使用</p><p>链表常见的有三种</p><ul><li>单链表</li><li>双向链表</li><li>循环链表</li></ul><p>每个链表的节点除了存储数据之外，还需要记录链表上下一个节点的地址，这个地址叫做后继指针 next</p><p>只有头节点和尾节点是特殊的，头节点记录链表的基地址，尾节点指向一个空地址 null</p><p>链表同样支持数据的插入、删除、查找，在链表中进行插入、删除操作是非常快速的，因为不需要大量的数据搬移操作，但是数组由于不连续，没法随机访问，只能一个一个遍历节点，时间复杂度 O(n)</p><h3 id="循环链表"><a class="header-anchor" href="#循环链表" aria-hidden="true">#</a> 循环链表</h3><p>循环链表是一种特殊的单链表，尾节点指针指向头节点</p><h3 id="双向链表"><a class="header-anchor" href="#双向链表" aria-hidden="true">#</a> 双向链表</h3><p>每个节点有前驱后继两个指针，比单向链表需要更多的内存空间，更加好找前驱节点</p><h3 id="链表的删除"><a class="header-anchor" href="#链表的删除" aria-hidden="true">#</a> 链表的删除</h3><p>链表的删除有两种情况</p><ol><li>删除节点中某个值等于给定值的节点</li><li>删除给定指针指向的节点</li></ol><p>第一种情况，单向链表和双向链表都需要依次遍历每个节点，O(n)</p><p>第二种情况，明显双向链表更好用，因为删除某个节点需要知道前驱节点，单链表又得遍历查找一遍</p><p>另外还有对于一个有序链表按值查找，我们可以按值决定往前还是往后查找，每次查找只需要查找一半的数据</p><p>实际使用中，双向链表也是更加广泛的，当内存空间充足的时候，追求代码的执行速度，双向链表是更好的，这也是空间换时间的思路。但如果内存吃紧，那就得采取时间换空间的思路</p><p>双向链表和循环链表还可以组合成双向循环链表</p><h3 id="链表-vs-数组"><a class="header-anchor" href="#链表-vs-数组" aria-hidden="true">#</a> 链表 VS 数组</h3><p>数组简单易用，连续内存空间可以借助 CPU 的缓存机制，预读数组中的数据，而链表不是连续存储，CPU 缓存不友好</p><p>数组的缺点大小固定，连续的存储空间不够会导致内存不足，即便是内存足够，数组的扩容是需要把原数组拷贝一份的，<strong>这个操作相当费时</strong>，而链表本身没有大小限制，天然支持动态扩容，这是它与数组最大的区别</p><p>当然链表也比数组更加耗费内存，先不说前驱后继指针导致的内存空间翻倍，频繁的插入和删除操作，会导致内存的频繁申请和释放，容易造成内存碎片，高级语言会导致频繁的垃圾回收，所以对于数组和链表的使用，需要自己权衡场景</p><h3 id="lru-缓存淘汰算法"><a class="header-anchor" href="#lru-缓存淘汰算法" aria-hidden="true">#</a> LRU 缓存淘汰算法</h3><p>思路：维护一个有序单链表，越靠近尾部的节点是越早之前访问的，当有一个新的数据被访问时，我们从链表头开始顺序遍历链表</p><ol><li>如果此数据已在链表中，我们遍历得到它后，删除，插入到头部</li><li>如果没在链表中，如果缓存未满，插入头部，如果缓存已满，删除尾节点，将新数据插入头部</li></ol><p>此时总是需要遍历的，时间复杂度 O(n)</p><p>优化可以用散列表，可以降到 O(1)</p><h3 id="注意事项"><a class="header-anchor" href="#注意事项" aria-hidden="true">#</a> 注意事项</h3><ol><li>理解指针或者引用的含义。C 语言有指针，Java 没有，叫做引用，其实都是一样的意思，存储的是所指内存对象的内存地址。变量赋值给指针，其实是把变量的地址赋值给指针，指针或者引用指向这个变量，通过指针可以找到这个变量</li><li>警惕指针丢失和内存泄露。不需要的引用要及时断掉，引用也不要指错对象</li><li>使用哨兵简化实现难度。不管链表是不是空，head 指针一直指向哨兵节点，有哨兵节点的链表叫做<strong>带头链表</strong>。其实就是加了一个头节点，返回时候返回头节点的 next 就可以</li><li>留意边界条件处理。链表为空？链表只有一个节点？链表只包含两个节点？代码逻辑能否处理头节点和尾节点？</li><li>画图举例。光想容易不清晰，画出来更容易</li><li>多练习，没有捷径</li></ol><h2 id="栈"><a class="header-anchor" href="#栈" aria-hidden="true">#</a> 栈</h2><p>栈是一种操作受限的线性表，只允许一端插入和删除数据。从功能上来说，数组和链表都可以代替栈，但是操作的接口太多了。对于某些场景，需要这种约束事情才会变得更加可控</p><p>使用数组实现叫做顺序栈，使用链表叫做链式栈。入栈和出栈的空间复杂度是 O(1)，时间复杂度也是 O(1)</p><p>出栈不涉及内存的重新申请和数据搬移，但是入栈的时候，如果空间不够，就需要重新申请内存和数据搬移，时间复杂度为 O(n)</p><h3 id="栈在函数调用中的应用"><a class="header-anchor" href="#栈在函数调用中的应用" aria-hidden="true">#</a> 栈在函数调用中的应用</h3><p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成栈这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，函数执行完就弹栈</p><p><img src="/Jarrett-blog/assets/function-stack.7958624b.png" alt="image.png"></p><h3 id="栈在表达式求值中的应用"><a class="header-anchor" href="#栈在表达式求值中的应用" aria-hidden="true">#</a> 栈在表达式求值中的应用</h3><p>求 <code>34+13\*9+44-12/3</code> 的值</p><p>编译器会通过两个栈，从左到右遍历表达式，遇到数字就压入操作数栈，遇到运算符，就与运算符栈的栈顶元素进行比较，优先级高的压入栈，优先级低或者相同的，从栈顶取出操作符和两个操作数进行计算，以此类推</p><h3 id="栈在括号匹配中的应用"><a class="header-anchor" href="#栈在括号匹配中的应用" aria-hidden="true">#</a> 栈在括号匹配中的应用</h3><p>如何检查表达式中括号使用的合法性？</p><p>可以用栈保存未匹配的左括号，从左到右依次扫描字符串，左括号压入栈中，遇到右括号，从栈顶取出一个左括号，如果匹配，则扫描剩下的字符串，如果右括号不能配对，或者栈中没有数据，说明格式非法</p><h2 id="队列"><a class="header-anchor" href="#队列" aria-hidden="true">#</a> 队列</h2><p>先进先出，入队出队，不允许其他操作，也是一种操作受限的线性表结构</p><p>有循环队列、阻塞队列、并发队列</p><p>实现队列可以用数组也可以用栈，分别叫顺序队列、链式队列</p><p>底层语言的数组在实现队列时，会导致头、尾下标的持续变化，所以需要在入队时，没有空间的情况下集中进行一次数据搬移的操作，另外，用循环队列可以更好地解决这个问题，循环的入队就可以了</p><h3 id="阻塞队列和并发队列"><a class="header-anchor" href="#阻塞队列和并发队列" aria-hidden="true">#</a> 阻塞队列和并发队列</h3><h4 id="阻塞队列"><a class="header-anchor" href="#阻塞队列" aria-hidden="true">#</a> 阻塞队列</h4><p>队列为空，从队列头取数据会被阻塞，因为没有数据可取，队列已满，插入数据会被阻塞。</p><p>这就是生产者——消费者模型的定义</p><h4 id="并发队列"><a class="header-anchor" href="#并发队列" aria-hidden="true">#</a> 并发队列</h4><p>线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。在实战篇讲 Disruptor 的时候，我会再详细讲并发队列的应用。</p><h3 id="线程池没有空闲线程时，新的任务请求如何处理？"><a class="header-anchor" href="#线程池没有空闲线程时，新的任务请求如何处理？" aria-hidden="true">#</a> 线程池没有空闲线程时，新的任务请求如何处理？</h3><ol><li>非阻塞，直接拒绝任务请求</li><li>阻塞，请求排队，等到有空闲线程时取出排队的请求继续处理</li></ol><h3 id="基于链表和数组的队列对于排队请求有什么区别？"><a class="header-anchor" href="#基于链表和数组的队列对于排队请求有什么区别？" aria-hidden="true">#</a> 基于链表和数组的队列对于排队请求有什么区别？</h3><p>链表支持无限排队的无界队列，可能会导致过多请求排队等待，等待时间长</p><p>数组队列大小有限，当线程池中排队的请求超过队列大小时，接下来的请求会被拒绝，对空间响应时间敏感的系统来说，更加合理</p><p>对于大部分资源有限的场景，当没有空闲资源时，基本都可以通过队列的数据结构来实现请求排队</p><h2 id="递归"><a class="header-anchor" href="#递归" aria-hidden="true">#</a> 递归</h2><p>递归需要满足三个条件</p><ol><li>一个问题的解可以分解为几个子问题的解。比如电影院找座位，想知道自己的座位可以分解为前一排的人在哪一排的子问题</li><li>这个问题与分解之后的子问题，除了数据规模不同，求解的思路完全一样</li><li>存在递归终止条件</li></ol><p>需要会写递归公式</p><blockquote><p>写递归要注意避免堆栈溢出，可以通过限制递归调用的最大深度，超过该深度直接报错。但这种办法没有完全解决问题，仅在最大深度比较小的时候使用，比如 10、50。</p></blockquote><blockquote><p>还要警惕重复计算，可以使用散列表来保存已经求解过 f(k)，当递归调用到时，先看下是否已经求解过了，是的话直接从三列表中取值返回，不需要重复计算</p></blockquote><p>递归的空间复杂度是 O(n)，因为每调用一次函数都会在内存栈中保存一次数据</p><p>递归有利有弊。它的表达力很强，写起来很简洁，弊端在于空间复杂度高，有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题，实际开发中，要根据实际情况来选择是否用递归的形式来实现</p><p>可以将递归改为迭代循环的非递归写法，但其实本质没有变，对于某些问题？还是无法避免</p><p>递归中还可能出现存在环形链表的问题，可以用快慢指针检测出环形链表的存在</p><h2 id="排序"><a class="header-anchor" href="#排序" aria-hidden="true">#</a> 排序</h2><h3 id="为什么插入排序比冒泡排序更受欢迎"><a class="header-anchor" href="#为什么插入排序比冒泡排序更受欢迎" aria-hidden="true">#</a> 为什么插入排序比冒泡排序更受欢迎</h3><p>排序算法的执行效率分析</p><ol><li>最好、最坏情况、平均情况时间复杂度</li><li>时间复杂度的系数、常数、低阶。虽然一般情况下都可忽略，但是由于我们平时处理的数据可能规模不大，这个时候需要把这些考虑进去</li><li>比较次数和交换次数。基于比较的排序算法的执行过程，涉及元素大小的比较、元素的交换或移动，应该把比较次数和交换次数也考虑进去</li></ol><h3 id="排序算法的内存消耗"><a class="header-anchor" href="#排序算法的内存消耗" aria-hidden="true">#</a> 排序算法的内存消耗</h3><p>算法有空间复杂度，空间复杂度为 O(1)的排序算法叫做原地排序</p><h3 id="排序算法的稳定性"><a class="header-anchor" href="#排序算法的稳定性" aria-hidden="true">#</a> 排序算法的稳定性</h3><p>待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变，叫做<strong>稳定的排序算法</strong>，否则叫做<strong>不稳定的排序算法</strong></p><h3 id="冒泡排序"><a class="header-anchor" href="#冒泡排序" aria-hidden="true">#</a> 冒泡排序</h3><p>每次对相邻的两个元素进行比较交换。可以优化当某次冒泡没有数据交换时，不再执行后续的冒泡操作</p><h4 id="分析"><a class="header-anchor" href="#分析" aria-hidden="true">#</a> 分析</h4><ol><li>冒泡排序是原地排序算法</li><li>是稳定的排序算法</li><li>最好情况时间复杂度 O(n)，最坏情况，当排序数据都是倒序排列的，需要 n 次冒泡操作，最坏情况时间复杂度 O(n^2)</li></ol><p>对于包含 n 个数据的数据，排列方式不同，冒泡排序的执行时间也是不同的，可以用有序度、逆序度来分析</p><p>2，4，3，1，5，6 的有序元素有 11 对，如(2,4),(2,5)，有序度 11，完全有序的数组，有序度是 n*(n-1)/2，叫做满有序度</p><p>逆序度以此类推，逆序度=满有序度-有序度</p><h3 id="插入排序"><a class="header-anchor" href="#插入排序" aria-hidden="true">#</a> 插入排序</h3><p>将数据分为两个区间，已排序区间和未排序区间，核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入</p><p>不同的查插入点方法，元素的比较次数是有区别的，但对于一个给定的初始序列，移动操作的次数总是固定的，等于逆序度</p><h4 id="分析-1"><a class="header-anchor" href="#分析-1" aria-hidden="true">#</a> 分析</h4><ol><li>插入排序是一个原地排序算法，因为不需要额外的存储空间，空间复杂度是 O(1)</li><li>插入排序中，对于值相同的元素，可以选择将后面出现的元素插入到前面出现的元素的后面，所以是稳定的排序算法</li><li>如果原本已经有序，复杂度为 O(n)，如果是倒叙，最坏情况时间复杂度是 O(n^2)，平均时间复杂度为 O(n^2)</li></ol><h3 id="选择排序"><a class="header-anchor" href="#选择排序" aria-hidden="true">#</a> 选择排序</h3><p>从未排序的区间中找最小的元素，与已排序的元素的末尾+1 的元素进行交换</p><p>基本跟插入排序类似</p><h4 id="分析-2"><a class="header-anchor" href="#分析-2" aria-hidden="true">#</a> 分析</h4><ol><li>是原地排序算法</li><li>不稳定。因为每次都要交换元素位置</li></ol><p>冒泡和插入排序在时间复杂度上是一样的，但冒泡排序涉及了 K 次交换操作，每次三个赋值语句，总耗时 3*K，插入排序数据移动操作只需要 K 个单位时间，性能上插入排序是更好的</p><h3 id="归并排序"><a class="header-anchor" href="#归并排序" aria-hidden="true">#</a> 归并排序</h3><p>排序一个数组，先把数组从中间分成前后两部分，再对前后两部分分别排序，递归的形式，最终整个数组就排好序了</p><p>是<strong>分治思想</strong>的体现</p><h4 id="分析-3"><a class="header-anchor" href="#分析-3" aria-hidden="true">#</a> 分析</h4><ol><li>是稳定的排序算法。合并过程中可以保证值相同的元素，合并前后的顺序不变</li><li>时间复杂度 O(nlogn)，归并算法的执行效率与要排序的原始数组的有序程度无关，时间复杂度很稳定，都是 O(nlogn)</li></ol><div class="language-"><pre><code>T(n) = 2*T(n/2) + n
     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
     ......
     = 2^k * T(n/2^k) + k * n
     ......
</code></pre></div><ol start="3"><li>不是原地排序算法，空间复杂度 O(n)</li></ol><h3 id="快速排序"><a class="header-anchor" href="#快速排序" aria-hidden="true">#</a> 快速排序</h3><p>也是利用分治思想。选择一组数据中任意一个数据作为哨兵 pivot，遍历数据，将大于 pivot 的放到右边，小于 pivot 的放到左边，pivot 在中间，我们得到三部分的数据</p><p>我们可以递归哨兵左右的数据，直至区间缩小为 1，这样数据就有序了</p><div class="language-"><pre><code>递推公式：
quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)

终止条件：
p &gt;= r
</code></pre></div><p><img src="/Jarrett-blog/assets/merge-quick.d75e8897.png" alt="image.png"></p><p>快速排序与归并排序的差别在于归并的处理过程由下到上，先处理子问题再合并，快排相反，从上到下，先分区，再处理子问题，归并虽然稳定、时间复杂度为 O(nlogn)，但是是非原地算法。而快速排序通过巧妙的原地分区函数，实现原地排序，解决了归并排序<strong>占用太多内存</strong>的问题</p><h4 id="分析-4"><a class="header-anchor" href="#分析-4" aria-hidden="true">#</a> 分析</h4><ol><li>快速排序是一种原地、不稳定的排序算法。如果每次分区都能整好把数组分成大小接近相等的两个小区间，那么快排的时间复杂度递推求解公式跟归并是相同的，时间复杂度 O(nlogn)，但如果不是，比如每次分区都是不均等的，最坏情况时间复杂度就为 O(n^2)</li></ol><div class="language-"><pre><code>T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。

T(n) = T(n/10) + T(9*n/10) + n； n&gt;1
</code></pre></div><p>用快速排序可以以 O(n)的时间复杂度找到数组中第 K 大的元素，因为每次都会选中一个哨兵 pivot，利用好这个哨兵的下标位置，就能很容易找到第 K 大的元素</p><h3 id="桶排序"><a class="header-anchor" href="#桶排序" aria-hidden="true">#</a> 桶排序</h3><p>线型排序算法</p><p>核心思想是将要排序的数据分到几个有序的桶里，每个桶里再单独进行排序，各自排序完后再取出组合，组成的序列就是有序的了</p><p>桶排序的时间复杂度 O(n)。如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k _ logk)。m 个桶排序的时间复杂度就是 O(m _ k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。</p><p>看起来很不错，但是桶排序对于数据的要求实际上是非常苛刻的</p><ol><li>首先，数据要很容易划分成桶，并且桶与桶之间有着天然的大小顺序。这样每个桶排完序才能直接合并</li><li>数据在各个桶内的分布如果是均匀的，很好，但如果不均匀，极端情况下都分到一个桶里，那就变成 O(nlogn)</li></ol><p>桶排序适合用在外部排序中</p><blockquote><p>外部排序。数据都存储在外部磁盘中，很大，但是我们的内存有限，无法全部加载到内存中</p></blockquote><p>比如 10G 的订单数据，但是我们只有 100mb 内存，需要加载进来按订单金额排序</p><p>我们可以获取订单金额的范围，比如是 1 元-10 万元，将其划分到 10 个桶里，第一个桶是 1-10000，第二个 10000-20000...如果理想的话，数据分布均匀，每个桶里就会有 10mb 左右的数据，逐个用快排排序，最后合并起来就是一份从小到大的订单数据</p><p>但是数据不可能那么均匀，我们可以针对数据量大的区间接着划分小区间，直到能读取到合适的数据量为止</p><h3 id="计数排序"><a class="header-anchor" href="#计数排序" aria-hidden="true">#</a> 计数排序</h3><p>是桶排序的一种特殊情况，往桶里塞入相同的数据，这样就不需要桶内排序，直接合并就完事了，只涉及遍历扫描，时间复杂度 O(n)</p><p>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合。而且，技术排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数（其实 js 用键值对就不存在这个问题）</p><h3 id="基数排序"><a class="header-anchor" href="#基数排序" aria-hidden="true">#</a> 基数排序</h3><p>比如给手机号排序，可以从最后一位开始排序，时间复杂度 O(n)</p><p>如果是给英文单词排序，长度不一，但是可以通过补 0 来解决，因为 ASCII 码，所有字母都大于 0，补 0 不会影响原有得大小顺序。</p><p>技术排序对数据有要求，需要可以分割出独立的位来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序</p><h3 id="排序优化"><a class="header-anchor" href="#排序优化" aria-hidden="true">#</a> 排序优化</h3><p><img src="/Jarrett-blog/assets/sort-table.1daac561.png" alt="表格"></p><p>线性排序算法时间复杂度较低，适用场景特殊，通用的排序函数不能选择线型排序算法</p><p>快速排序较为适合，但是快速排序的最坏情况时间复杂度是 O(n^2)，主要还是因为分区点选的不够合理，最理想的分区点是被分开的两个分区中，数据的数量差不多</p><p>有两个比较常用、简单的分区法</p><ol><li>三数取中法。从区间的首尾中分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点，但是如果排序的数组比较大，那可能就要五数取中或者十数取中</li><li>随机法。随机选择一个元素作为分区点</li></ol><p>在实际使用中，排序并不一定仅限于单一场景，通过针对不同情况灵活运用才能让执行效率更高。比如 qsort 函数</p><p>qsort 会优先使用归并排序，因为数据量小的时候，归并排序更快，空间换时间，但是数据量大的时候，会改用快速排序（三数取中法）。当元素个数小于等于 4 时，qsort 使用插入排序</p><h2 id="查找算法"><a class="header-anchor" href="#查找算法" aria-hidden="true">#</a> 查找算法</h2><h3 id="二分查找"><a class="header-anchor" href="#二分查找" aria-hidden="true">#</a> 二分查找</h3><p>复杂度 O(logn)，效率极高，但是有局限性</p><ol><li>二分查找依赖顺序表结构数组，其他的数据结构不适用</li><li>数组必须有序。二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中，针对动态变化的数据集合，二分查找将不再适用</li><li>如果数据量很小，没有必要用二分查找，顺序遍历即可。但是如果数据项都是长度超过 300 的字符串就要使用二分，因为 300 长度字符串的大小对比很耗时</li><li>数据量太大也不适合二分。因为二分查找要求数组，而数组是内存空间连续的数据结构，如果数据量太大，对内存空间的要求太苛刻。（JS 的数组由于是对象模拟出来的，不必在意这个）</li></ol><h4 id="二分查找的变形问题"><a class="header-anchor" href="#二分查找的变形问题" aria-hidden="true">#</a> 二分查找的变形问题</h4><div class="language-js"><pre><code><span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">46</span><span class="token punctuation">,</span> <span class="token number">46</span><span class="token punctuation">,</span> <span class="token number">46</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">bSearch</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">array<span class="token punctuation">,</span> n<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> high <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">===</span> value<span class="token punctuation">)</span> <span class="token keyword">return</span> low<span class="token punctuation">;</span>
  <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="查找第一个值等于给定值的元素"><a class="header-anchor" href="#查找第一个值等于给定值的元素" aria-hidden="true">#</a> 查找第一个值等于给定值的元素</h4><p>分两种情况，算上右侧边界，需要定 right=nums.length-1，否则不用减 1</p><div class="language-javascript"><pre><code><span class="token comment">/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">search</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span> target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> middle <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      left <span class="token operator">=</span> middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">&gt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      right <span class="token operator">=</span> middle <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> middle<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="移除元素"><a class="header-anchor" href="#移除元素" aria-hidden="true">#</a> 移除元素</h2><p>这种题目的关键在于，数组元素在内存中的地址是连续的，不能单独删除某个元素，，只能覆盖 可以采用双层 for 循环，一层遍历数组元素，一层在发现需要移除元素后，将数组集体向前移动一位，但是时间复杂度为 O(n^2)，因此不推荐 使用双指针法，只需要一层 for 循环，遇到目标元素时，会区分出快慢指针，从而移动元素位置，时间复杂度为 O(n)</p><div class="language-javascript"><pre><code><span class="token comment">/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">removeElement</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> slowIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!==</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      nums<span class="token punctuation">[</span>slowIndex<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> slowIndex<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="滑动窗口"><a class="header-anchor" href="#滑动窗口" aria-hidden="true">#</a> 滑动窗口</h2><p>像一个窗口一样，每当和大于目标值时，就移动左右窗口，这道题有个坑，就是每当和大于目标值时，计算子串长度不需要加 1，因为在这一步里必然会减去左侧的一个值，必然需要减去 1</p><div class="language-javascript"><pre><code><span class="token comment">/**
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">minSubArrayLen</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> subLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment">// 给一个不可能的值，没有改变就说明不存在目标子串</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>right<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>sum <span class="token operator">&gt;=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      subLength <span class="token operator">=</span> right <span class="token operator">-</span> left<span class="token punctuation">;</span>
      result <span class="token operator">=</span> result <span class="token operator">&lt;</span> subLength <span class="token operator">?</span> result <span class="token operator">:</span> subLength<span class="token punctuation">;</span>
      sum <span class="token operator">-=</span> nums<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 可能存在全部相加也不大于等于目标值的情况</span>
  <span class="token keyword">return</span> result <span class="token operator">&lt;=</span> nums<span class="token punctuation">.</span>length <span class="token operator">?</span> result <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="有序数组的平方排序"><a class="header-anchor" href="#有序数组的平方排序" aria-hidden="true">#</a> 有序数组的平方排序</h2><p>这类题可以用双指针法，直接将时间复杂度降到了 O(n)</p><div class="language-javascript"><pre><code><span class="token comment">/**
 * @param {number[]} nums
 * @return {number[]}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">sortedSquares</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> k <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    j <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      result<span class="token punctuation">[</span>k<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
      j<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      result<span class="token punctuation">[</span>k<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
      i<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></div></div><footer class="page-footer" data-v-7eddb2c4 data-v-fb8d84c6><div class="edit" data-v-fb8d84c6><div class="edit-link" data-v-fb8d84c6 data-v-1ed99556><a class="link" href="https://github.com/Jarrett817/Jarrett-blog/edit/master/docs/computer-basic/fucking-arithmetic/index.md" target="_blank" rel="noopener noreferrer" data-v-1ed99556>Edit this page on GitHub <svg class="icon outbound icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-1ed99556><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="updated" data-v-fb8d84c6><p class="last-updated" data-v-fb8d84c6 data-v-5797b537><span class="prefix" data-v-5797b537>Last Updated:</span><span class="datetime" data-v-5797b537></span></p></div></footer><div class="next-and-prev-link" data-v-7eddb2c4 data-v-38ede35f><div class="container" data-v-38ede35f><div class="prev" data-v-38ede35f><a class="link" href="/Jarrett-blog/computer-basic/internet/" data-v-38ede35f><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-prev" data-v-38ede35f><path d="M19,11H7.4l5.3-5.3c0.4-0.4,0.4-1,0-1.4s-1-0.4-1.4,0l-7,7c-0.1,0.1-0.2,0.2-0.2,0.3c-0.1,0.2-0.1,0.5,0,0.8c0.1,0.1,0.1,0.2,0.2,0.3l7,7c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L7.4,13H19c0.6,0,1-0.4,1-1S19.6,11,19,11z"></path></svg><span class="text" data-v-38ede35f>计算机网络</span></a></div><div class="next" data-v-38ede35f><!----></div></div></div><!--[--><!--]--></div></main></div><!----><!--]--><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"f16df007\",\"tools_slides.md\":\"ac1cf889\",\"computer-basic_design-pattern_index.md\":\"5e203ae1\",\"computer-basic_fucking-arithmetic_index.md\":\"9900c140\",\"computer-basic_internet_index.md\":\"653ef890\",\"front-end_browser_index.md\":\"6475c368\",\"front-end_canvas_index.md\":\"315c87cc\",\"front-end_css_index.md\":\"9161c7b8\",\"front-end_git_index.md\":\"572d444d\",\"front-end_html_index.md\":\"1857da16\",\"front-end_js_index.md\":\"a922a2f2\",\"front-end_nodejs_index.md\":\"76e10abc\",\"front-end_ts_index.md\":\"d8e36f4c\",\"front-end_vue_index.md\":\"0ac73585\"}")</script>
    <script type="module" async src="/Jarrett-blog/assets/app.dff7797b.js"></script>
  </body>
</html>